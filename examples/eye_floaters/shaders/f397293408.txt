#version 420
layout (vertices = 4) out;

uniform mat4x4 mvp_matrix;
uniform mat4x4 lod_mvp_matrix; // If this isn't equal to the mvp_matrix, LOD can be visualized for other views.
uniform vec2 bottom_left;
uniform vec2 top_right;
uniform float base_height;

uniform vec2 viewport_pixel_extents;

in VS_OUT {
    vec2 coord;
    vec3 corner_screen_position;
} tcs_in[];

out TCS_OUT {
    vec2 coord;
} tcs_out[];

// Approximately how long a triangle edge should be.
#define TRIANGLE_PIXELS 7

void main(void)
{
    bool visible = false;
    float buf = 0.25; //screen extent buffer, to mitigate artifacts due to culling of actually visible terrain.
    for (int i = 0; i < 4; i++) {
        if (tcs_in[i].corner_screen_position.x >= 0-buf
                && tcs_in[i].corner_screen_position.x <= 1+buf
                && tcs_in[i].corner_screen_position.y >= 0-buf
                && tcs_in[i].corner_screen_position.y <= 1+buf
                && tcs_in[i].corner_screen_position.z >= 0) {
            visible = true;
        }
    }
    if (visible) {
        float avg_outer = 0.f;
        for (int i = 0; i < 4; i++) {
            int shift = 3;
            vec2 pixel_extents = viewport_pixel_extents * (tcs_in[(i+shift)%4].corner_screen_position.xy - tcs_in[(i+1+shift)%4].corner_screen_position.xy);
            float l = length(pixel_extents);
            float o = max(1, l*(1.f/TRIANGLE_PIXELS));
            gl_TessLevelOuter[i] = o;
            avg_outer += 0.25*o;
        }
        gl_TessLevelInner[0] = avg_outer;
        gl_TessLevelInner[1] = avg_outer;
    } else {
        gl_TessLevelOuter[0] = 0;
        gl_TessLevelOuter[1] = 0;
        gl_TessLevelOuter[2] = 0;
        gl_TessLevelOuter[3] = 0;
        gl_TessLevelInner[0] = 0;
        gl_TessLevelInner[1] = 0;
    }
        
    tcs_out[gl_InvocationID].coord = tcs_in[gl_InvocationID].coord;
}
