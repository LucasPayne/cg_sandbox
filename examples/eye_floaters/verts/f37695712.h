od, offset) texelFetchOffset(sampler, position, lod, offset)
    #endif
#else
    #define HIGHP_SAMPLER_FLOAT
    #define HIGHP_FS_ADDRESS
    #if defined(PLATFORM_MACOS) && !defined(SWGL)
        // texelFetchOffset introduces a variety of shader compilation bugs on macOS Intel so avoid it.
        #define TEXEL_FETCH(sampler, position, lod, offset) texelFetch(sampler, position + offset, lod)
    #else
        #define TEXEL_FETCH(sampler, position, lod, offset) texelFetchOffset(sampler, position, lod, offset)
    #endif
#endif

#ifdef SWGL
    #define SWGL_DRAW_SPAN
    #define SWGL_CLIP_MASK
    #define SWGL_ANTIALIAS
    #define SWGL_BLEND
    #define SWGL_CLIP_DIST
#endif

#ifdef WR_VERTEX_SHADER
    #ifdef SWGL
        // Annotate a vertex attribute as being flat per each drawn primitive instance.
        // SWGL can use this information to avoid redundantly loading the attribute in all SIMD lanes.
        #define PER_INSTANCE flat
    #else
        #define PER_INSTANCE
    #endif

    #if __VERSION__ != 100
        #define varying out
        #define attribute in
    #endif
#endif

#ifdef WR_FRAGMENT_SHADER
    precision highp float;
    #if __VERSION__ != 100
        #define varying in
    #endif
#endif

// Flat interpolation is not supported on ESSL 1
#if __VERSION__ == 100
    #define flat
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define COMPONENT_TRANSFER_IDENTITY 0
#define COMPONENT_TRANSFER_TABLE 1
#define COMPONENT_TRANSFER_DISCRETE 2
#define COMPONENT_TRANSFER_LINEAR 3
#define COMPONENT_TRANSFER_GAMMA 4

// Must be kept in sync with `Filter::as_int` in internal_types.rs
// Not all filters are defined here because some filter use different shaders.
#define FILTER_CONTRAST            0
#define FILTER_GRAYSCALE           1
#define FILTER_HUE_ROTATE          2
#define FILTER_INVERT              3
#define FILTER_SATURATE            4
#define FILTER_SEPIA               5
#define FILTER_BRIGHTNESS          6
#define FILTER_COLOR_MATRIX        7
#define FILTER_SRGB_TO_LINEAR      8
#define FILTER_LINEAR_TO_SRGB      9
#define FILTER_FLOOD               10
#define FILTER_COMPONENT_TRANSFER  11

#ifdef WR_VERTEX_SHADER
void SetupFilterParams(
    int op,
    float amount,
    int gpu_data_address,
    out vec4 color_offset,
    out mat4 color_mat,
    out highp int table_address
) {
    float lumR = 0.2126;
    float lumG = 0.7152;
    float lumB = 0.0722;
    float oneMinusLumR = 1.0 - lumR;
    float oneMinusLumG = 1.0 - lumG;
    float oneMinusLumB = 1.0 - lumB;
    float invAmount = 1.0 - amount;

    if (op == FILTER_GRAYSCALE) {
        color_mat = mat4(
            vec4(lumR + oneMinusLumR * invAmount, lumR - lumR * invAmount, lumR - lumR * invAmount, 0.0),
            vec4(lumG - lumG * invAmount, lumG + oneMinusLumG * invAmount, lumG - lumG * invAmount, 0.0),
            vec4(lumB - lumB * invAmount, lumB - lumB * invAmount, lumB + oneMinusLumB * invAmount, 0.0),
            vec4(0.0, 0.0, 0.0, 1.0)
        );
        color_offset = vec4(0.0);
    } else if (op ==  FILTER_HUE_ROTATE) {
        float c = cos(amount);
        float s = sin(amount);
        color_mat = mat4(
            vec4(lumR + oneMinusLumR * c - lumR * s, lumR - lumR * c + 0.143 * s, lumR - lumR * c - oneMinusLumR * s, 0.0),
            vec4(lumG - lumG * c - lumG * s, lumG + oneMinusLumG * c + 0.140 * s, lumG - lumG * c + lumG * s, 0.0),
            vec4(lumB - lumB * c + oneMinusLumB * s, lumB - lumB * c - 0.283 * s, lumB + oneMinusLumB * c + lumB * s, 0.0),
            vec4(0.0, 0.0, 0.0, 1.0)
        );
        color_offset = vec4(0.0);
    } else if (op ==   FILTER_SATURATE) {
        color_mat = mat4(
            vec4(invAmount * lumR + amount, invAmount * lumR, invAmount * lumR, 0.0),
            vec4(invAmount * lumG, invAmount * lumG + amount, invAmount * lumG, 0.0),
            vec4(invAmount * lumB, invAmount * lumB, invAmount * lumB + amount, 0.0),
            vec4(0.0, 0.0, 0.0, 1.0)
        );
        color_offset = vec4(0.0);
    } else if (op == FILTER_SEPIA) {
        color_mat = mat4(
            vec4(0.393 + 0.607 * invAmount, 0.349 - 0.349 * invAmount, 0.272 - 0.272 * invAmount, 0.0),
            vec4(0.769 - 0.769 * invAmount, 0.686 + 0.314 * invAmount, 0.534 - 0.534 * invAmount, 0.0),
            vec4(0.189 - 0.189 * invAmount, 0.168 - 0.168 * invAmount, 0.131 + 0.869 * invAmount, 0.0),
            vec4(0.0, 0.0, 0.0, 1.0)
        );
        color_offset = vec4(0.0);
    } else if (op == FILTER_COLOR_MATRIX) {
        vec4 mat_data[4] = fetch_from_gpu_cache_4(gpu_data_address);
        vec4 offset_data = fetch_from_gpu_cache_1(gpu_data_address + 4);
        color_mat = mat4(mat_data[0], mat_data[1], mat_data[2], mat_data[3]);
        color_offset = offset_data;
    } else if (op == FILTER_COMPONENT_TRANSFER) {
        table_address = gpu_data_address;
    } else if (op == FILTER_FLOOD) {
        color_offset = fetch_from_gpu_cache_1(gpu_data_address);
    }
}
#endif

#ifdef WR_FRAGMENT_SHADER
vec3 Contrast(vec3 Cs, float amount) {
    return clamp(Cs.rgb * amount - 0.5 * amount + 0.5, 0.0, 1.0);
}

vec3 Invert(vec3 Cs, float amount) {
    return mix(Cs.rgb, vec3(1.0) - Cs.rgb, amount);
}

vec3 Brightness(vec3 Cs, float amount) {
    // Apply the brightness factor.
    // Resulting color needs to be clamped to output range
    // since we are pre-multiplying alpha in the shader.
    return clamp(Cs.rgb * amount, vec3(0.0), vec3(1.0));
}

// Based on the Gecko's implementation in
// https://hg.mozilla.org/mozilla-central/file/91b4c3687d75/gfx/src/FilterSupport.cpp#l24
// These could be made faster by sampling a lookup table stored in a float texture
// with linear interpolation.

vec3 SrgbToLinear(vec3 color) {
    vec3 c1 = color / 12.92;
    vec3 c2 = pow(color / 1.055 + vec3(0.055 / 1.055), vec3(2.4));
    return if_then_else(lessThanEqual(color, vec3(0.04045)), c1, c2);
}

vec3 LinearToSrgb(vec3 color) {
    vec3 c1 = color * 12.92;
    vec3 c2 = vec3(1.055) * pow(color, vec3(1.0 / 2.4)) - vec3(0.055);
    return if_then_else(lessThanEqual(color, vec3(0.0031308)), c1, c2);
}

// This function has to be factored out due to the following issue:
// https://github.com/servo/webrender/wiki/Driver-issues#bug-1532245---switch-statement-inside-control-flow-inside-switch-statement-fails-to-compile-on-some-android-phones
// (and now the words "default: default:" so angle_shader_validation.rs passes)
vec4 ComponentTransfer(vec4 colora, vec4 vfuncs, highp int table_address) {
    // We push a different amount of data to the gpu cache depending on the
    // function type.
    // Identity => 0 blocks
    // Table/Discrete => 64 blocks (256 values)
    // Linear => 1 block (2 values)
    // Gamma => 1 block (3 values)
    // We loop through the color components and increment the offset (for the
    // next color component) into the gpu cache based on how many blocks that
    // function type put into the gpu cache.
    // Table/Discrete use a 256 entry look up table.
    // Linear/Gamma are a simple calculation.

    // Both offset and k must be marked as highp due to a Adreno 3xx bug likely
    // to do with converting between precisions (as they would otherwise be
    // promoted when adding to table_address).
    highp int offset = 0;
    highp int k;

    vec4 texel;

    // Dynamically indexing a vector is buggy on some platforms, so use a temporary array
    int[4] funcs = int[4](int(vfuncs.r), int(vfuncs.g), int(vfuncs.b), int(vfuncs.a));
    for (int i = 0; i < 4; i++) {
        switch (funcs[i]) {
            case COMPONENT_TRANSFER_IDENTITY:
                break;
            case COMPONENT_TRANSFER_TABLE:
            case COMPONENT_TRANSFER_DISCRETE: {
                // fetch value from lookup table
                k = int(floor(colora[i]*255.0 + 0.5));
                texel = fetch_from_gpu_cache_1(table_address + offset + k/4);
                colora[i] = clamp(texel[k % 4], 0.0, 1.0);
                // offset plus 256/4 blocks
                offset = offset + 64;
                break;
            }
            case COMPONENT_TRANSFER_LINEAR: {
                // fetch the two values for use in the linear equation
                texel = fetch_from_gpu_cache_1(table_address + offset);
                colora[i] = clamp(texel[0] * colora[i] + texel[1], 0.0, 1.0);
                // offset plus 1 block
                offset = offset + 1;
                break;
            }
            case COMPONENT_TRANSFER_GAMMA: {
                // fetch the three values for use in the gamma equation
                texel = fetch_from_gpu_cache_1(table_address + offset);
                colora[i] = clamp(texel[0] * pow(colora[i], texel[1]) + texel[2], 0.0, 1.0);
                // offset plus 1 block
                offset = offset + 1;
                break;
            }
            default:
                // shouldn't happen
                break;
        }
    }
    return colora;
}

void CalculateFilter(
    vec4 Cs,
    int op,
    float amount,
    highp int table_address,
    vec4 color_offset,
    mat4 color_mat,
    vec4 v_funcs,
    out vec3 color,
    out float alpha
) {
    // Un-premultiply the input.
    alpha = Cs.a;
    color = alpha != 0.0 ? Cs.rgb / alpha : Cs.rgb;

    switch (op) {
        case FILTER_CONTRAST:
            color = Contrast(color, amount);
            break;
        case FILTER_INVERT:
            color = Invert(color, amount);
            break;
        case FILTER_BRIGHTNESS:
            color = Brightness(color, amount);
            break;
        case FILTER_SRGB_TO_LINEAR:
            color = SrgbToLinear(color);
            break;
        case FILTER_LINEAR_TO_SRGB:
            color = LinearToSrgb(color);
            break;
        case FILTER_COMPONENT_TRANSFER: {
            // Get the unpremultiplied color with alpha.
            vec4 colora = vec4(color, alpha);
            colora = ComponentTransfer(colora, v_funcs, table_address);
            color = colora.rgb;
            alpha = colora.a;
            break;
        }
        case FILTER_FLOOD:
            color = color_offset.rgb;
            alpha = color_offset.a;
            break;
        default:
            // Color matrix type filters (sepia, hue-rotate, etc...)
            vec4 result = color_mat * vec4(color, alpha) + color_offset;
            result = clamp(result, vec4(0.0), vec4(1.0));
            color = result.rgb;
            alpha = result.a;
    }
}
#endif
brush/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/// # Brush vertex shaders memory layout
///
/// The overall memory layout is the same for all brush shaders.
///
/// The vertex shader receives a minimal amount of data from vertex attributes (packed into a single
/// ivec4 per instance) and the rest is fetched from various uniform samplers using offsets decoded
/// from the vertex attributes.
///
/// The diagram below shows the the various pieces of data fectched in the vertex shader:
///
///```ascii
///                                                                         (sPrimitiveHeadersI)
///                          (VBO)                                     +-----------------------+
/// +----------------------------+      +----------------------------> | Int header            |
/// | Instance vertex attributes |      |        (sPrimitiveHeadersF)  |                       |
/// |                            |      |     +---------------------+  |   z                   |
/// | x: prim_header_address    +-------+---> | Float header        |  |   specific_address  +-----+
/// | y: picture_task_address   +---------+   |                     |  |   transform_address +---+ |
/// |    clip_address           +-----+   |   |    local_rect       |  |   user_data           | | |
/// | z: flags                   |    |   |   |    local_clip_rect  |  +-----------------------+ | |
/// |    segment_index           |    |   |   +---------------------+                            | |
/// | w: resource_address       +--+  |   |                                                      | |
/// +----------------------------+ |  |   |                                 (sGpuCache)          | |
///                                |  |   |         (sGpuCache)          +------------+          | |
///                                |  |   |   +---------------+          | Transform  | <--------+ |
///                (sGpuCache)     |  |   +-> | Picture task  |          +------------+            |
///            +-------------+     |  |       |               |                                    |
///            |  Resource   | <---+  |       |         ...   |                                    |
///            |             |        |       +---------------+   +--------------------------------+
///            |             |        |                           |
///            +-------------+        |             (sGpuCache)   v                        (sGpuCache)
///                                   |       +---------------+  +--------------+---------------+-+-+
///                                   +-----> | Clip area     |  | Brush data   |  Segment data | | |
///                                           |               |  |              |               | | |
///                                           |         ...   |  |         ...  |          ...  | | | ...
///                                           +---------------+  +--------------+---------------+-+-+
///```
///
/// - Segment data address is obtained by combining the address stored in the int header and the
///   segment index decoded from the vertex attributes.
/// - Resource data is optional, some brush types (such as images) store some extra data there while
///   other brush types don't use it.
///

#if (defined(WR_FEATURE_ALPHA_PASS) || defined(WR_FEATURE_ANTIALIASING)) && !defined(SWGL_ANTIALIAS)
varying vec2 v_local_pos;
#endif

#ifdef WR_VERTEX_SHADER

void brush_vs(
    VertexInfo vi,
    int prim_address,
    RectWithEndpoint local_rect,
    RectWithEndpoint segment_rect,
    ivec4 prim_user_data,
    int specific_resource_address,
    mat4 transform,
    PictureTask pic_task,
    int brush_flags,
    vec4 segment_data
);

// Forward-declare the text vertex shader entry point which is currently
// different from other brushes.
void text_shader_main(
    Instance instance,
    PrimitiveHeader ph,
    Transform transform,
    PictureTask task,
    ClipArea clip_area
);

#define VECS_PER_SEGMENT                    2

#define BRUSH_FLAG_PERSPECTIVE_INTERPOLATION    1
#define BRUSH_FLAG_SEGMENT_RELATIVE             2
#define BRUSH_FLAG_SEGMENT_REPEAT_X             4
#define BRUSH_FLAG_SEGMENT_REPEAT_Y             8
#define BRUSH_FLAG_SEGMENT_REPEAT_X_ROUND      16
#define BRUSH_FLAG_SEGMENT_REPEAT_Y_ROUND      32
#define BRUSH_FLAG_SEGMENT_NINEPATCH_MIDDLE    64
#define BRUSH_FLAG_TEXEL_RECT                 128
#define BRUSH_FLAG_FORCE_AA                   256

#define INVALID_SEGMENT_INDEX                   0xffff

void brush_shader_main_vs(
    Instance instance,
    PrimitiveHeader ph,
    Transform transform,
    PictureTask pic_task,
    ClipArea clip_area
) {
    int edge_flags = (instance.flags >> 12) & 0xf;
    int brush_flags = instance.flags & 0xfff;

    // Fetch the segment of this brush primitive we are drawing.
    vec4 segment_data;
    RectWithEndpoint segment_rect;
    if (instance.segment_index == INVALID_SEGMENT_INDEX) {
        segment_rect = ph.local_rect;
        segment_data = vec4(0.0);
    } else {
        int segment_address = ph.specific_prim_address +
                              VECS_PER_SPECIFIC_BRUSH +
                              instance.segment_index * VECS_PER_SEGMENT;

        vec4[2] segment_info = fetch_from_gpu_cache_2(segment_address);
        segment_rect = RectWithEndpoint(segment_info[0].xy, segment_info[0].zw);
        segment_rect.p0 += ph.local_rect.p0;
        segment_rect.p1 += ph.local_rect.p0;
        segment_data = segment_info[1];
    }

    // Most of the time this is the segment rect, but when doing the edge AA
    // it is inflated.
    RectWithEndpoint adjusted_segment_rect = segment_rect;

    bool antialiased = !transform.is_axis_aligned || ((brush_flags & BRUSH_FLAG_FORCE_AA) != 0);

    // Write the normal vertex information out.
    if (antialiased) {
        adjusted_segment_rect = clip_and_init_antialiasing(
            segment_rect,
            ph.local_rect,
            ph.local_clip_rect,
            edge_flags,
            ph.z,
            transform,
            pic_task
        );

        // The clip was taken into account in clip_and_init_antialiasing, remove
        // it so that it doesn't interfere with the aa.
        ph.local_clip_rect.p0 = vec2(-1.0e16);
        ph.local_clip_rect.p1 = vec2(1.0e16);
    } else {
        // The common case for most CSS content.

        // TODO(gw): transform bounds may be referenced by
        //           the fragment shader when running in
        //           the alpha pass, even on non-transformed
        //           items. For now, just ensure it has no
        //           effect. We can tidy this up as we move
        //           more items to be brush shaders.
#if defined(WR_FEATURE_ALPHA_PASS) && !defined(SWGL_ANTIALIAS)
        init_transform_vs(vec4(vec2(-1.0e16), vec2(1.0e16)));
#endif
    }

    // Select the corner of the local rect that we are processing.
    vec2 local_pos = mix(adjusted_segment_rect.p0, adjusted_segment_rect.p1, aPosition.xy);

    VertexInfo vi = write_vertex(
        local_pos,
        ph.local_clip_rect,
        ph.z,
        transform,
        pic_task
    );

    // For brush instances in the alpha pass, always write
    // out clip information.
    // TODO(gw): It's possible that we might want alpha
    //           shaders that don't clip in the future,
    //           but it's reasonable to assume that one
    //           implies the other, for now.
    // SW-WR may decay some requests for alpha-pass shaders to
    // the opaque version if only the clip-mask is required. In
    // that case the opaque vertex shader must still write out
    // the clip information, which is cheap to do for SWGL.
#if defined(WR_FEATURE_ALPHA_PASS) || defined(SWGL_CLIP_MASK)
    write_clip(
        vi.world_pos,
        clip_area,
        pic_task
    );
#endif

    // Run the specific brush VS code to write interpolators.
    brush_vs(
        vi,
        ph.specific_prim_address,
        ph.local_rect,
        segment_rect,
        ph.user_data,
        instance.resource_address,
        transform.m,
        pic_task,
        brush_flags,
        segment_data
    );

#if (defined(WR_FEATURE_ALPHA_PASS) || defined(WR_FEATURE_ANTIALIASING)) && !defined(SWGL_ANTIALIAS)
    v_local_pos = vi.local_pos;
#endif
}

#ifndef WR_VERTEX_SHADER_MAIN_FUNCTION
// If the entry-point was not overridden before including the brush shader,
// use the default one.
#define WR_VERTEX_SHADER_MAIN_FUNCTION brush_shader_main_vs
#endif

void main(void) {

    Instance instance = decode_instance_attributes();
    PrimitiveHeader ph = fetch_prim_header(instance.prim_header_address);
    Transform transform = fetch_transform(ph.transform_id);
    PictureTask task = fetch_picture_task(instance.picture_task_address);
    ClipArea clip_area = fetch_clip_area(instance.clip_address);

    WR_VERTEX_SHADER_MAIN_FUNCTION(instance, ph, transform, task, clip_area);
}

#endif // WR_VERTEX_SHADER

#ifdef WR_FRAGMENT_SHADER

float antialias_brush() {
#if (defined(WR_FEATURE_ALPHA_PASS) || defined(WR_FEATURE_ANTIALIASING)) && !defined(SWGL_ANTIALIAS)
    return init_transform_fs(v_local_pos);
#else
    return 1.0;
#endif
}

Fragment brush_fs();

void main(void) {
#ifdef WR_FEATURE_DEBUG_OVERDRAW
    oFragColor = WR_DEBUG_OVERDRAW_COLOR;
#else

    Fragment frag = brush_fs();

#ifdef WR_FEATURE_ALPHA_PASS
    // Apply the clip mask
    float clip_alpha = do_clip();

    frag.color *= clip_alpha;

    #ifdef WR_FEATURE_DUAL_SOURCE_BLENDING
        oFragBlend = frag.blend * clip_alpha;
    #endif
#endif

    write_output(frag.color);
#endif
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define VECS_PER_SPECIFIC_BRUSH 3
#define WR_FEATURE_TEXTURE_2D

#include shared,prim_shared,brush,blend

// Interpolated UV coordinates to sample.
varying vec2 v_uv;

// Normalized bounds of the source image in the texture, adjusted to avoid
// sampling artifacts.
flat varying vec4 v_uv_sample_bounds;

// x: Flag to allow perspective interpolation of UV.
// y: Filter-dependent "amount" parameter.
// Packed in to a vector to work around bug 1630356.
flat varying vec2 v_perspective_amount;
#define v_perspective v_perspective_amount.x
#define v_amount v_perspective_amount.y

// x: Blend op, y: Lookup table GPU cache address.
// Packed in to a vector to work around bug 1630356.
// Must be explicitly marked as highp, as the default integer precision in
// fragment shaders is mediump which may only be 16 bits in ESSL 3, and GPU
// cache address can exceed that maximum representable value.
flat varying highp ivec2 v_op_table_address_vec;
#define v_op v_op_table_address_vec.x
#define v_table_address v_op_table_address_vec.y

flat varying mat4 v_color_mat;
// The function to use for each component of a component transfer filter. Using a int[4]
// or ivec4 (with each element or component containing the function for each component) has
// ran in to bugs 1695912 and 1731758, so instead use a vec4 and cast the values to/from floats.
flat varying vec4 v_funcs;
flat varying vec4 v_color_offset;

#ifdef WR_VERTEX_SHADER
void brush_vs(
    VertexInfo vi,
    int prim_address,
    RectWithEndpoint local_rect,
    RectWithEndpoint segment_rect,
    ivec4 prim_user_data,
    int specific_resource_address,
    mat4 transform,
    PictureTask pic_task,
    int brush_flags,
    vec4 unused
) {
    ImageSource res = fetch_image_source(prim_user_data.x);
    vec2 uv0 = res.uv_rect.p0;
    vec2 uv1 = res.uv_rect.p1;

    vec2 inv_texture_size = vec2(1.0) / vec2(TEX_SIZE(sColor0).xy);
    vec2 f = (vi.local_pos - local_rect.p0) / rect_size(local_rect);
    f = get_image_quad_uv(prim_user_data.x, f);
    vec2 uv = mix(uv0, uv1, f);
    float perspective_interpolate = (brush_flags & BRUSH_FLAG_PERSPECTIVE_INTERPOLATION) != 0 ? 1.0 : 0.0;

    v_uv = uv * inv_texture_size * mix(vi.world_pos.w, 1.0, perspective_interpolate);
    v_perspective = perspective_interpolate;

    v_uv_sample_bounds = vec4(uv0 + vec2(0.5), uv1 - vec2(0.5)) * inv_texture_size.xyxy;

    float amount = float(prim_user_data.z) / 65536.0;

    v_op = prim_user_data.y & 0xffff;
    v_amount = amount;

    v_funcs.r = float((prim_user_data.y >> 28) & 0xf);
    v_funcs.g = float((prim_user_data.y >> 24) & 0xf);
    v_funcs.b = float((prim_user_data.y >> 20) & 0xf);
    v_funcs.a = float((prim_user_data.y >> 16) & 0xf);

    SetupFilterParams(
        v_op,
        amount,
        prim_user_data.z,
        v_color_offset,
        v_color_mat,
        v_table_address
    );
}
#endif

#ifdef WR_FRAGMENT_SHADER
Fragment brush_fs() {
    float perspective_divisor = mix(gl_FragCoord.w, 1.0, v_perspective);
    vec2 uv = v_uv * perspective_divisor;
    // Clamp the uvs to avoid sampling artifacts.
    uv = clamp(uv, v_uv_sample_bounds.xy, v_uv_sample_bounds.zw);

    vec4 Cs = texture(sColor0, uv);

    float alpha;
    vec3 color;
    CalculateFilter(
        Cs,
        v_op,
        v_amount,
        v_table_address,
        v_color_offset,
        v_color_mat,
        v_funcs,
        color,
        alpha
    );

    #ifdef WR_FEATURE_ALPHA_PASS
        alpha *= antialias_brush();
    #endif

    // Pre-multiply the alpha into the output value.
    return Fragment(alpha * vec4(color, 1.0));
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define VECS_PER_SPECIFIC_BRUSH 3

#include shared,prim_shared,brush

// Interpolated UV coordinates to sample.
varying vec2 v_uv;

#ifdef WR_FEATURE_ALPHA_PASS
flat varying vec4 v_color;
flat varying vec2 v_mask_swizzle;
flat varying vec2 v_tile_repeat;
#endif

// Normalized bounds of the source image in the texture.
flat varying vec4 v_uv_bounds;
// Normalized bounds of the source image in the texture, adjusted to avoid
// sampling artifacts.
flat varying vec4 v_uv_sample_bounds;

// Flag to allow perspective interpolation of UV.
// Packed in to vector to work around bug 1630356.
flat varying vec2 v_perspective;

#ifdef WR_VERTEX_SHADER

// Must match the AlphaType enum.
#define BLEND_MODE_ALPHA            0
#define BLEND_MODE_PREMUL_ALPHA     1

struct ImageBrushData {
    vec4 color;
    vec4 background_color;
    vec2 stretch_size;
};

ImageBrushData fetch_image_data(int address) {
    vec4[3] raw_data = fetch_from_gpu_cache_3(address);
    ImageBrushData data = ImageBrushData(
        raw_data[0],
        raw_data[1],
        raw_data[2].xy
    );
    return data;
}

void brush_vs(
    VertexInfo vi,
    int prim_address,
    RectWithEndpoint prim_rect,
    RectWithEndpoint segment_rect,
    ivec4 prim_user_data,
    int specific_resource_address,
    mat4 transform,
    PictureTask pic_task,
    int brush_flags,
    vec4 segment_data
) {
    ImageBrushData image_data = fetch_image_data(prim_address);

    // If this is in WR_FEATURE_TEXTURE_RECT mode, the rect and size use
    // non-normalized texture coordinates.
#ifdef WR_FEATURE_TEXTURE_RECT
    vec2 texture_size = vec2(1, 1);
#else
    vec2 texture_size = vec2(TEX_SIZE(sColor0));
#endif

    ImageSource res = fetch_image_source(specific_resource_address);
    vec2 uv0 = res.uv_rect.p0;
    vec2 uv1 = res.uv_rect.p1;

    RectWithEndpoint local_rect = prim_rect;
    vec2 stretch_size = image_data.stretch_size;
    if (stretch_size.x < 0.0) {
        stretch_size = rect_size(local_rect);
    }

    // If this segment should interpolate relative to the
    // segment, modify the parameters for that.
    if ((brush_flags & BRUSH_FLAG_SEGMENT_RELATIVE) != 0) {
        local_rect = segment_rect;
        stretch_size = rect_size(local_rect);

        if ((brush_flags & BRUSH_FLAG_TEXEL_RECT) != 0) {
            // If the extra data is a texel rect, modify the UVs.
            vec2 uv_size = res.uv_rect.p1 - res.uv_rect.p0;
            uv0 = res.uv_rect.p0 + segment_data.xy * uv_size;
            uv1 = res.uv_rect.p0 + segment_data.zw * uv_size;
        }

        #ifdef WR_FEATURE_REPETITION
            // TODO(bug 1609893): Move this logic to the CPU as well as other sources of
            // branchiness in this shader.
            if ((brush_flags & BRUSH_FLAG_TEXEL_RECT) != 0) {
                // Value of the stretch size with repetition. We have to compute it for
                // both axis even if we only repeat on one axis because the value for
                // each axis depends on what the repeated value would have been for the
                // other axis.
                vec2 repeated_stretch_size = stretch_size;
                // Size of the uv rect of the segment we are considering when computing
                // the repetitions. For the fill area it is a tad more complicated as we
                // have to use the uv size of the top-middle segment to drive horizontal
                // repetitions, and the size of the left-middle segment to drive vertical
                // repetitions. So we track the reference sizes for both axis separately
                // even though in the common case (the border segments) they are the same.
                vec2 horizontal_uv_size = uv1 - uv0;
                vec2 vertical_uv_size = uv1 - uv0;
                // We use top and left sizes by default and fall back to bottom and right
                // when a size is empty.
                if ((brush_flags & BRUSH_FLAG_SEGMENT_NINEPATCH_MIDDLE) != 0) {
                    repeated_stretch_size = segment_rect.p0 - prim_rect.p0;

                    float epsilon = 0.001;

                    // Adjust the the referecne uv size to compute vertical repetitions for
                    // the fill area.
                    vertical_uv_size.x = uv0.x - res.uv_rect.p0.x;
                    if (vertical_uv_size.x < epsilon || repeated_stretch_size.x < epsilon) {
                        vertical_uv_size.x = res.uv_rect.p1.x - uv1.x;
                        repeated_stretch_size.x = prim_rect.p1.x - segment_rect.p1.x;
                    }

                    // Adjust the the referecne uv size to compute horizontal repetitions
                    // for the fill area.
                    horizontal_uv_size.y = uv0.y - res.uv_rect.p0.y;
                    if (horizontal_uv_size.y < epsilon || repeated_stretch_size.y < epsilon) {
                        horizontal_uv_size.y = res.uv_rect.p1.y - uv1.y;
                        repeated_stretch_size.y = prim_rect.p1.y - segment_rect.p1.y;
                    }
                }

                if ((brush_flags & BRUSH_FLAG_SEGMENT_REPEAT_X) != 0) {
                    float uv_ratio = horizontal_uv_size.x / horizontal_uv_size.y;
                    stretch_size.x = repeated_stretch_size.y * uv_ratio;
                }
                if ((brush_flags & BRUSH_FLAG_SEGMENT_REPEAT_Y) != 0) {
                    float uv_ratio = vertical_uv_size.y / vertical_uv_size.x;
                    stretch_size.y = repeated_stretch_size.x * uv_ratio;
                }

            } else {
                if ((brush_flags & BRUSH_FLAG_SEGMENT_REPEAT_X) != 0) {
                    stretch_size.x = segment_data.z - segment_data.x;
                }
                if ((brush_flags & BRUSH_FLAG_SEGMENT_REPEAT_Y) != 0) {
                    stretch_size.y = segment_data.w - segment_data.y;
                }
            }
            if ((brush_flags & BRUSH_FLAG_SEGMENT_REPEAT_X_ROUND) != 0) {
                float segment_rect_width = segment_rect.p1.x - segment_rect.p0.x;
                float nx = max(1.0, round(segment_rect_width / stretch_size.x));
                stretch_size.x = segment_rect_width / nx;
            }
            if ((brush_flags & BRUSH_FLAG_SEGMENT_REPEAT_Y_ROUND) != 0) {
                float segment_rect_height = segment_rect.p1.y - segment_rect.p0.y;
                float ny = max(1.0, round(segment_rect_height / stretch_size.y));
                stretch_size.y = segment_rect_height / ny;
            }
        #endif
    }

    float perspective_interpolate = (brush_flags & BRUSH_FLAG_PERSPECTIVE_INTERPOLATION) != 0 ? 1.0 : 0.0;
    v_perspective.x = perspective_interpolate;

    // Handle case where the UV coords are inverted (e.g. from an
    // external image).
    vec2 min_uv = min(uv0, uv1);
    vec2 max_uv = max(uv0, uv1);

    v_uv_sample_bounds = vec4(
        min_uv + vec2(0.5),
        max_uv - vec2(0.5)
    ) / texture_size.xyxy;

    vec2 f = (vi.local_pos - local_rect.p0) / rect_size(local_rect);

#ifdef WR_FEATURE_ALPHA_PASS
    int color_mode = prim_user_data.x & 0xffff;
    int blend_mode = prim_user_data.x >> 16;

    if (color_mode == COLOR_MODE_FROM_PASS) {
        color_mode = uMode;
    }

#endif

    // Derive the texture coordinates for this image, based on
    // whether the source image is a local-space or screen-space
    // image.
    int raster_space = prim_user_data.y;
    if (raster_space == RASTER_SCREEN) {
        // Since the screen space UVs specify an arbitrary quad, do
        // a bilinear interpolation to get the correct UV for this
        // local position.
        f = get_image_quad_uv(specific_resource_address, f);
    }

    // Offset and scale v_uv here to avoid doing it in the fragment shader.
    vec2 repeat = rect_size(local_rect) / stretch_size;
    v_uv = mix(uv0, uv1, f) - min_uv;
    v_uv /= texture_size;
    v_uv *= repeat.xy;
    if (perspective_interpolate == 0.0) {
        v_uv *= vi.world_pos.w;
    }

#ifdef WR_FEATURE_TEXTURE_RECT
    v_uv_bounds = vec4(0.0, 0.0, vec2(textureSize(sColor0)));
#else
    v_uv_bounds = vec4(min_uv, max_uv) / texture_size.xyxy;
#endif

#ifdef WR_FEATURE_REPETITION
    // Normalize UV to 0..1 scale only if using repetition. Otherwise, leave
    // UVs unnormalized since we won't compute a modulus without repetition
    // enabled.
    v_uv /= (v_uv_bounds.zw - v_uv_bounds.xy);
#endif

#ifdef WR_FEATURE_ALPHA_PASS
    v_tile_repeat = repeat.xy;

    float opacity = float(prim_user_data.z) / 65535.0;
    switch (blend_mode) {
        case BLEND_MODE_ALPHA:
            image_data.color.a *= opacity;
            break;
        case BLEND_MODE_PREMUL_ALPHA:
        default:
            image_data.color *= opacity;
            break;
    }

    switch (color_mode) {
        case COLOR_MODE_ALPHA:
        case COLOR_MODE_BITMAP_SHADOW:
            #ifdef SWGL_BLEND
                swgl_blendDropShadow(image_data.color);
                v_mask_swizzle = vec2(1.0, 0.0);
                v_color = vec4(1.0);
            #else
                v_mask_swizzle = vec2(0.0, 1.0);
                v_color = image_data.color;
            #endif
            break;
        case COLOR_MODE_SUBPX_BG_PASS2:
        case COLOR_MODE_IMAGE:
            v_mask_swizzle = vec2(1.0, 0.0);
            v_color = image_data.color;
            break;
        case COLOR_MODE_SUBPX_CONST_COLOR:
        case COLOR_MODE_SUBPX_BG_PASS0:
        case COLOR_MODE_COLOR_BITMAP:
            v_mask_swizzle = vec2(1.0, 0.0);
            v_color = vec4(image_data.color.a);
            break;
        case COLOR_MODE_SUBPX_BG_PASS1:
            v_mask_swizzle = vec2(-1.0, 1.0);
            v_color = vec4(image_data.color.a) * image_data.background_color;
            break;
        case COLOR_MODE_SUBPX_DUAL_SOURCE:
            v_mask_swizzle = vec2(image_data.color.a, 0.0);
            v_color = image_data.color;
            break;
        case COLOR_MODE_MULTIPLY_DUAL_SOURCE:
            v_mask_swizzle = vec2(-image_data.color.a, image_data.color.a);
            v_color = image_data.color;
            break;
        default:
            v_mask_swizzle = vec2(0.0);
            v_color = vec4(1.0);
    }
#endif
}
#endif

#ifdef WR_FRAGMENT_SHADER

vec2 compute_repeated_uvs(float perspective_divisor) {
#ifdef WR_FEATURE_REPETITION
    vec2 uv_size = v_uv_bounds.zw - v_uv_bounds.xy;

    #ifdef WR_FEATURE_ALPHA_PASS
    // This prevents the uv on the top and left parts of the primitive that was inflated
    // for anti-aliasing purposes from going beyound the range covered by the regular
    // (non-inflated) primitive.
    vec2 local_uv = max(v_uv * perspective_divisor, vec2(0.0));

    // Handle horizontal and vertical repetitions.
    vec2 repeated_uv = fract(local_uv) * uv_size + v_uv_bounds.xy;

    // This takes care of the bottom and right inflated parts.
    // We do it after the modulo because the latter wraps around the values exactly on
    // the right and bottom edges, which we do not want.
    if (local_uv.x >= v_tile_repeat.x) {
        repeated_uv.x = v_uv_bounds.z;
    }
    if (local_uv.y >= v_tile_repeat.y) {
        repeated_uv.y = v_uv_bounds.w;
    }
    #else
    vec2 repeated_uv = fract(v_uv * perspective_divisor) * uv_size + v_uv_bounds.xy;
    #endif

    return repeated_uv;
#else
    return v_uv * perspective_divisor + v_uv_bounds.xy;
#endif
}

Fragment brush_fs() {
    float perspective_divisor = mix(gl_FragCoord.w, 1.0, v_perspective.x);
    vec2 repeated_uv = compute_repeated_uvs(perspective_divisor);

    // Clamp the uvs to avoid sampling artifacts.
    vec2 uv = clamp(repeated_uv, v_uv_sample_bounds.xy, v_uv_sample_bounds.zw);

    vec4 texel = TEX_SAMPLE(sColor0, uv);

    Fragment frag;

#ifdef WR_FEATURE_ALPHA_PASS
    #ifdef WR_FEATURE_ANTIALIASING
        float alpha = antialias_brush();
    #else
        float alpha = 1.0;
    #endif
    #ifndef WR_FEATURE_DUAL_SOURCE_BLENDING
        texel.rgb = texel.rgb * v_mask_swizzle.x + texel.aaa * v_mask_swizzle.y;
    #endif

    vec4 alpha_mask = texel * alpha;
    frag.color = v_color * alpha_mask;

    #ifdef WR_FEATURE_DUAL_SOURCE_BLENDING
        frag.blend = alpha_mask * v_mask_swizzle.x + alpha_mask.aaaa * v_mask_swizzle.y;
    #endif
#else
    frag.color = texel;
#endif

    return frag;
}

#if defined(SWGL_DRAW_SPAN) && (!defined(WR_FEATURE_ALPHA_PASS) || !defined(WR_FEATURE_DUAL_SOURCE_BLENDING))
void swgl_drawSpanRGBA8() {
    if (!swgl_isTextureRGBA8(sColor0)) {
        return;
    }

    #ifdef WR_FEATURE_ALPHA_PASS
        if (v_mask_swizzle != vec2(1.0, 0.0)) {
            return;
        }
    #endif

    float perspective_divisor = mix(swgl_forceScalar(gl_FragCoord.w), 1.0, v_perspective.x);

    #ifdef WR_FEATURE_REPETITION
        // Get the UVs before any repetition, scaling, or offsetting has occurred...
        vec2 uv = v_uv * perspective_divisor;
    #else
        vec2 uv = compute_repeated_uvs(perspective_divisor);
    #endif

    #ifdef WR_FEATURE_ALPHA_PASS
    if (v_color != vec4(1.0)) {
        #ifdef WR_FEATURE_REPETITION
            swgl_commitTextureRepeatColorRGBA8(sColor0, uv, v_tile_repeat, v_uv_bounds, v_uv_sample_bounds, v_color);
        #else
            swgl_commitTextureColorRGBA8(sColor0, uv, v_uv_sample_bounds, v_color);
        #endif
        return;
    }
    // No color scaling required, so just fall through to a normal textured span...
    #endif

    #ifdef WR_FEATURE_REPETITION
        #ifdef WR_FEATURE_ALPHA_PASS
            swgl_commitTextureRepeatRGBA8(sColor0, uv, v_tile_repeat, v_uv_bounds, v_uv_sample_bounds);
        #else
            swgl_commitTextureRepeatRGBA8(sColor0, uv, vec2(0.0), v_uv_bounds, v_uv_sample_bounds);
        #endif
    #else
        swgl_commitTextureRGBA8(sColor0, uv, v_uv_sample_bounds);
    #endif
}
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define VECS_PER_SPECIFIC_BRUSH 2

#include shared,prim_shared,brush,gradient_shared

// Start offset. Packed in to vector to work around bug 1630356.
flat varying vec2 v_start_offset;

flat varying vec2 v_scale_dir;

#ifdef WR_VERTEX_SHADER

struct Gradient {
    vec4 start_end_point;
    int extend_mode;
    vec2 stretch_size;
};

Gradient fetch_gradient(int address) {
    vec4 data[2] = fetch_from_gpu_cache_2(address);
    return Gradient(
        data[0],
        int(data[1].x),
        data[1].yz
    );
}

void brush_vs(
    VertexInfo vi,
    int prim_address,
    RectWithEndpoint local_rect,
    RectWithEndpoint segment_rect,
    ivec4 prim_user_data,
    int specific_resource_address,
    mat4 transform,
    PictureTask pic_task,
    int brush_flags,
    vec4 texel_rect
) {
    Gradient gradient = fetch_gradient(prim_address);

    write_gradient_vertex(
        vi,
        local_rect,
        segment_rect,
        prim_user_data,
        brush_flags,
        texel_rect,
        gradient.extend_mode,
        gradient.stretch_size
    );

    vec2 start_point = gradient.start_end_point.xy;
    vec2 end_point = gradient.start_end_point.zw;
    vec2 dir = end_point - start_point;

    // Normalize UV and offsets to 0..1 scale.
    v_scale_dir = dir / dot(dir, dir);
    v_start_offset.x = dot(start_point, v_scale_dir);
    v_scale_dir *= v_repeated_size;
}
#endif

#ifdef WR_FRAGMENT_SHADER
float get_gradient_offset(vec2 pos) {
    // Project position onto a direction vector to compute offset.
    return dot(pos, v_scale_dir) - v_start_offset.x;
}

Fragment brush_fs() {
    vec4 color = sample_gradient(get_gradient_offset(compute_repeated_pos()));

#ifdef WR_FEATURE_ALPHA_PASS
    color *= antialias_brush();
#endif

    return Fragment(color);
}

#ifdef SWGL_DRAW_SPAN
void swgl_drawSpanRGBA8() {
  int address = swgl_validateGradient(sGpuCache, get_gpu_cache_uv(v_gradient_address.x), int(GRADIENT_ENTRIES + 2.0));
    if (address < 0) {
        return;
    }
    #ifndef WR_FEATURE_ALPHA_PASS
        swgl_commitLinearGradientRGBA8(sGpuCache, address, GRADIENT_ENTRIES, v_gradient_repeat.x != 0.0,
                                       get_gradient_offset(v_pos));
    #else
        while (swgl_SpanLength > 0) {
            float offset = get_gradient_offset(compute_repeated_pos());
            if (v_gradient_repeat.x != 0.0) offset = fract(offset);
            float entry = clamp_gradient_entry(offset);
            swgl_commitGradientRGBA8(sGpuCache, address, entry);
            v_pos += swgl_interpStep(v_pos);
        }
    #endif
}
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define VECS_PER_SPECIFIC_BRUSH 3
#define WR_FEATURE_TEXTURE_2D

#include shared,prim_shared,brush

// UV and bounds for the source image
varying vec2 v_src_uv;
flat varying vec4 v_src_uv_sample_bounds;

// UV and bounds for the backdrop image
varying vec2 v_backdrop_uv;
flat varying vec4 v_backdrop_uv_sample_bounds;

// Flag to allow perspective interpolation of UV.
// Packed in to vector to work around bug 1630356.
flat varying vec2 v_perspective;
// mix-blend op. Packed in to vector to work around bug 1630356.
flat varying ivec2 v_op;

#ifdef WR_VERTEX_SHADER

void get_uv(
    int res_address,
    vec2 f,
    ivec2 texture_size,
    float perspective_f,
    out vec2 out_uv,
    out vec4 out_uv_sample_bounds
) {
    ImageSource res = fetch_image_source(res_address);
    vec2 uv0 = res.uv_rect.p0;
    vec2 uv1 = res.uv_rect.p1;

    vec2 inv_texture_size = vec2(1.0) / vec2(texture_size);
    f = get_image_quad_uv(res_address, f);
    vec2 uv = mix(uv0, uv1, f);

    out_uv = uv * inv_texture_size * perspective_f;
    out_uv_sample_bounds = vec4(uv0 + vec2(0.5), uv1 - vec2(0.5)) * inv_texture_size.xyxy;
}

void brush_vs(
    VertexInfo vi,
    int prim_address,
    RectWithEndpoint local_rect,
    RectWithEndpoint segment_rect,
    ivec4 prim_user_data,
    int specific_resource_address,
    mat4 transform,
    PictureTask pic_task,
    int brush_flags,
    vec4 unused
) {
    vec2 f = (vi.local_pos - local_rect.p0) / rect_size(local_rect);
    float perspective_interpolate = (brush_flags & BRUSH_FLAG_PERSPECTIVE_INTERPOLATION) != 0 ? 1.0 : 0.0;
    float perspective_f = mix(vi.world_pos.w, 1.0, perspective_interpolate);
    v_perspective.x = perspective_interpolate;
    v_op.x = prim_user_data.x;

    get_uv(
        prim_user_data.y,
        f,
        TEX_SIZE(sColor0).xy,
        1.0,
        v_backdrop_uv,
        v_backdrop_uv_sample_bounds
    );

    get_uv(
        prim_user_data.z,
        f,
        TEX_SIZE(sColor1).xy,
        perspective_f,
        v_src_uv,
        v_src_uv_sample_bounds
    );
}
#endif

#ifdef WR_FRAGMENT_SHADER
vec3 Multiply(vec3 Cb, vec3 Cs) {
    return Cb * Cs;
}

vec3 Screen(vec3 Cb, vec3 Cs) {
    return Cb + Cs - (Cb * Cs);
}

vec3 HardLight(vec3 Cb, vec3 Cs) {
    vec3 m = Multiply(Cb, 2.0 * Cs);
    vec3 s = Screen(Cb, 2.0 * Cs - 1.0);
    vec3 edge = vec3(0.5, 0.5, 0.5);
    return mix(m, s, step(edge, Cs));
}

// TODO: Worth doing with mix/step? Check GLSL output.
float ColorDodge(float Cb, float Cs) {
    if (Cb == 0.0)
        return 0.0;
    else if (Cs == 1.0)
        return 1.0;
    else
        return min(1.0, Cb / (1.0 - Cs));
}

// TODO: Worth doing with mix/step? Check GLSL output.
float ColorBurn(float Cb, float Cs) {
    if (Cb == 1.0)
        return 1.0;
    else if (Cs == 0.0)
        return 0.0;
    else
        return 1.0 - min(1.0, (1.0 - Cb) / Cs);
}

float SoftLight(float Cb, float Cs) {
    if (Cs <= 0.5) {
        return Cb - (1.0 - 2.0 * Cs) * Cb * (1.0 - Cb);
    } else {
        float D;

        if (Cb <= 0.25)
            D = ((16.0 * Cb - 12.0) * Cb + 4.0) * Cb;
        else
            D = sqrt(Cb);

        return Cb + (2.0 * Cs - 1.0) * (D - Cb);
    }
}

vec3 Difference(vec3 Cb, vec3 Cs) {
    return abs(Cb - Cs);
}

// These functions below are taken from the spec.
// There's probably a much quicker way to implement
// them in GLSL...
float Sat(vec3 c) {
    return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
}

float Lum(vec3 c) {
    vec3 f = vec3(0.3, 0.59, 0.11);
    return dot(c, f);
}

vec3 ClipColor(vec3 C) {
    float L = Lum(C);
    float n = min(C.r, min(C.g, C.b));
    float x = max(C.r, max(C.g, C.b));

    if (n < 0.0)
        C = L + (((C - L) * L) / (L - n));

    if (x > 1.0)
        C = L + (((C - L) * (1.0 - L)) / (x - L));

    return C;
}

vec3 SetLum(vec3 C, float l) {
    float d = l - Lum(C);
    return ClipColor(C + d);
}

void SetSatInner(inout float Cmin, inout float Cmid, inout float Cmax, float s) {
    if (Cmax > Cmin) {
        Cmid = (((Cmid - Cmin) * s) / (Cmax - Cmin));
        Cmax = s;
    } else {
        Cmid = 0.0;
        Cmax = 0.0;
    }
    Cmin = 0.0;
}

vec3 SetSat(vec3 C, float s) {
    if (C.r <= C.g) {
        if (C.g <= C.b) {
            SetSatInner(C.r, C.g, C.b, s);
        } else {
            if (C.r <= C.b) {
                SetSatInner(C.r, C.b, C.g, s);
            } else {
                SetSatInner(C.b, C.r, C.g, s);
            }
        }
    } else {
        if (C.r <= C.b) {
            SetSatInner(C.g, C.r, C.b, s);
        } else {
            if (C.g <= C.b) {
                SetSatInner(C.g, C.b, C.r, s);
            } else {
                SetSatInner(C.b, C.g, C.r, s);
            }
        }
    }
    return C;
}

vec3 Hue(vec3 Cb, vec3 Cs) {
    return SetLum(SetSat(Cs, Sat(Cb)), Lum(Cb));
}

vec3 Saturation(vec3 Cb, vec3 Cs) {
    return SetLum(SetSat(Cb, Sat(Cs)), Lum(Cb));
}

vec3 Color(vec3 Cb, vec3 Cs) {
    return SetLum(Cs, Lum(Cb));
}

vec3 Luminosity(vec3 Cb, vec3 Cs) {
    return SetLum(Cb, Lum(Cs));
}

const int MixBlendMode_Multiply    = 1;
const int MixBlendMode_Screen      = 2;
const int MixBlendMode_Overlay     = 3;
const int MixBlendMode_Darken      = 4;
const int MixBlendMode_Lighten     = 5;
const int MixBlendMode_ColorDodge  = 6;
const int MixBlendMode_ColorBurn   = 7;
const int MixBlendMode_HardLight   = 8;
const int MixBlendMode_SoftLight   = 9;
const int MixBlendMode_Difference  = 10;
const int MixBlendMode_Exclusion   = 11;
const int MixBlendMode_Hue         = 12;
const int MixBlendMode_Saturation  = 13;
const int MixBlendMode_Color       = 14;
const int MixBlendMode_Luminosity  = 15;
const int MixBlendMode_PlusLighter = 16;

Fragment brush_fs() {
    float perspective_divisor = mix(gl_FragCoord.w, 1.0, v_perspective.x);

    vec2 src_uv = v_src_uv * perspective_divisor;
    src_uv = clamp(src_uv, v_src_uv_sample_bounds.xy, v_src_uv_sample_bounds.zw);

    vec2 backdrop_uv = clamp(v_backdrop_uv, v_backdrop_uv_sample_bounds.xy, v_backdrop_uv_sample_bounds.zw);

    vec4 Cb = texture(sColor0, backdrop_uv);
    vec4 Cs = texture(sColor1, src_uv);

    // The mix-blend-mode functions assume no premultiplied alpha
    if (Cb.a != 0.0) {
        Cb.rgb /= Cb.a;
    }

    if (Cs.a != 0.0) {
        Cs.rgb /= Cs.a;
    }

    // Return yellow if none of the branches match (shouldn't happen).
    vec4 result = vec4(1.0, 1.0, 0.0, 1.0);

    // On Android v_op has been packed in to a vector to avoid a driver bug
    // on Adreno 3xx. However, this runs in to another Adreno 3xx driver bug
    // where the switch doesn't match any cases. Unpacking the value from the
    // vec in to a local variable prior to the switch works around this, but
    // gets optimized away by glslopt. Adding a bitwise AND prevents that.
    // See bug 1726755.
    // default: default: to appease angle_shader_validation
    switch (v_op.x & 0xFF) {
        case MixBlendMode_Multiply:
            result.rgb = Multiply(Cb.rgb, Cs.rgb);
            break;
        case MixBlendMode_Overlay:
            // Overlay is inverse of Hardlight
            result.rgb = HardLight(Cs.rgb, Cb.rgb);
            break;
        case MixBlendMode_Darken:
            result.rgb = min(Cs.rgb, Cb.rgb);
            break;
        case MixBlendMode_Lighten:
            result.rgb = max(Cs.rgb, Cb.rgb);
            break;
        case MixBlendMode_ColorDodge:
            result.r = ColorDodge(Cb.r, Cs.r);
            result.g = ColorDodge(Cb.g, Cs.g);
            result.b = ColorDodge(Cb.b, Cs.b);
            break;
        case MixBlendMode_ColorBurn:
            result.r = ColorBurn(Cb.r, Cs.r);
            result.g = ColorBurn(Cb.g, Cs.g);
            result.b = ColorBurn(Cb.b, Cs.b);
            break;
        case MixBlendMode_HardLight:
            result.rgb = HardLight(Cb.rgb, Cs.rgb);
            break;
        case MixBlendMode_SoftLight:
            result.r = SoftLight(Cb.r, Cs.r);
            result.g = SoftLight(Cb.g, Cs.g);
            result.b = SoftLight(Cb.b, Cs.b);
            break;
        case MixBlendMode_Difference:
            result.rgb = Difference(Cb.rgb, Cs.rgb);
            break;
        case MixBlendMode_Hue:
            result.rgb = Hue(Cb.rgb, Cs.rgb);
            break;
        case MixBlendMode_Saturation:
            result.rgb = Saturation(Cb.rgb, Cs.rgb);
            break;
        case MixBlendMode_Color:
            result.rgb = Color(Cb.rgb, Cs.rgb);
            break;
        case MixBlendMode_Luminosity:
            result.rgb = Luminosity(Cb.rgb, Cs.rgb);
            break;
        case MixBlendMode_Screen:
        case MixBlendMode_Exclusion:
        case MixBlendMode_PlusLighter:
            // This should be unreachable, since we implement
            // MixBlendMode::Screen, MixBlendMode::Exclusion and
            // MixBlendMode::PlusLighter using glBlendFuncSeparate.
            break;
        default: break;
    }

    result.rgb = (1.0 - Cb.a) * Cs.rgb + Cb.a * result.rgb;
    result.a = Cs.a;
    result.rgb *= result.a;

    return Fragment(result);
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define VECS_PER_SPECIFIC_BRUSH 3
#define WR_FEATURE_TEXTURE_2D

#include shared,prim_shared,brush

// Interpolated UV coordinates to sample.
varying vec2 v_uv;

// Normalized bounds of the source image in the texture, adjusted to avoid
// sampling artifacts.
flat varying vec4 v_uv_sample_bounds;

flat varying vec2 v_opacity_perspective_vec;
#define v_opacity v_opacity_perspective_vec.x
// Flag to allow perspective interpolation of UV.
#define v_perspective v_opacity_perspective_vec.y

#ifdef WR_VERTEX_SHADER
void brush_vs(
    VertexInfo vi,
    int prim_address,
    RectWithEndpoint local_rect,
    RectWithEndpoint segment_rect,
    ivec4 prim_user_data,
    int specific_resource_address,
    mat4 transform,
    PictureTask pic_task,
    int brush_flags,
    vec4 unused
) {
    ImageSource res = fetch_image_source(prim_user_data.x);
    vec2 uv0 = res.uv_rect.p0;
    vec2 uv1 = res.uv_rect.p1;

    vec2 texture_size = vec2(TEX_SIZE(sColor0).xy);
    vec2 f = (vi.local_pos - local_rect.p0) / rect_size(local_rect);
    f = get_image_quad_uv(prim_user_data.x, f);
    vec2 uv = mix(uv0, uv1, f);
    float perspective_interpolate = (brush_flags & BRUSH_FLAG_PERSPECTIVE_INTERPOLATION) != 0 ? 1.0 : 0.0;

    v_uv = uv / texture_size * mix(vi.world_pos.w, 1.0, perspective_interpolate);
    v_perspective = perspective_interpolate;

    v_uv_sample_bounds = vec4(uv0 + vec2(0.5), uv1 - vec2(0.5)) / texture_size.xyxy;

    v_opacity = clamp(float(prim_user_data.y) / 65536.0, 0.0, 1.0);
}
#endif

#ifdef WR_FRAGMENT_SHADER
Fragment brush_fs() {
    float perspective_divisor = mix(gl_FragCoord.w, 1.0, v_perspective);
    vec2 uv = v_uv * perspective_divisor;
    // Clamp the uvs to avoid sampling artifacts.
    uv = clamp(uv, v_uv_sample_bounds.xy, v_uv_sample_bounds.zw);

    // No need to un-premultiply since we'll only apply a factor to the alpha.
    vec4 color = texture(sColor0, uv);

    float alpha = v_opacity;

    #ifdef WR_FEATURE_ALPHA_PASS
        alpha *= antialias_brush();
    #endif

    // Pre-multiply the contribution of the opacity factor.
    return Fragment(alpha * color);
}

#if defined(SWGL_DRAW_SPAN) && !defined(WR_FEATURE_DUAL_SOURCE_BLENDING)
void swgl_drawSpanRGBA8() {
    float perspective_divisor = mix(swgl_forceScalar(gl_FragCoord.w), 1.0, v_perspective);
    vec2 uv = v_uv * perspective_divisor;

    swgl_commitTextureLinearColorRGBA8(sColor0, uv, v_uv_sample_bounds, v_opacity);
}
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define VECS_PER_SPECIFIC_BRUSH 1

#include shared,prim_shared,brush

flat varying vec4 v_color;

#ifdef WR_VERTEX_SHADER

struct SolidBrush {
    vec4 color;
};

SolidBrush fetch_solid_primitive(int address) {
    vec4 data = fetch_from_gpu_cache_1(address);
    return SolidBrush(data);
}

void brush_vs(
    VertexInfo vi,
    int prim_address,
    RectWithEndpoint local_rect,
    RectWithEndpoint segment_rect,
    ivec4 prim_user_data,
    int specific_resource_address,
    mat4 transform,
    PictureTask pic_task,
    int brush_flags,
    vec4 unused
) {
    SolidBrush prim = fetch_solid_primitive(prim_address);

    float opacity = float(prim_user_data.x) / 65535.0;
    v_color = prim.color * opacity;
}
#endif

#ifdef WR_FRAGMENT_SHADER
Fragment brush_fs() {
    vec4 color = v_color;
#ifdef WR_FEATURE_ALPHA_PASS
    color *= antialias_brush();
#endif
    return Fragment(color);
}

#if defined(SWGL_DRAW_SPAN) && (!defined(WR_FEATURE_ALPHA_PASS) || !defined(WR_FEATURE_DUAL_SOURCE_BLENDING))
void swgl_drawSpanRGBA8() {
    swgl_commitSolidRGBA8(v_color);
}

void swgl_drawSpanR8() {
    swgl_commitSolidR8(v_color.x);
}
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define VECS_PER_SPECIFIC_BRUSH 1

#include shared,prim_shared,brush,yuv

varying vec2 vUv_Y;
flat varying vec4 vUvBounds_Y;

varying vec2 vUv_U;
flat varying vec4 vUvBounds_U;

varying vec2 vUv_V;
flat varying vec4 vUvBounds_V;

YUV_PRECISION flat varying vec3 vYcbcrBias;
YUV_PRECISION flat varying mat3 vRgbFromDebiasedYcbcr;

// YUV format. Packed in to vector to work around bug 1630356.
flat varying ivec2 vFormat;

#ifdef SWGL_DRAW_SPAN
flat varying int vRescaleFactor;
#endif

#ifdef WR_VERTEX_SHADER

YuvPrimitive fetch_yuv_primitive(int address) {
    vec4 data = fetch_from_gpu_cache_1(address);
    // From YuvImageData.write_prim_gpu_blocks:
    int channel_bit_depth = int(data.x);
    int color_space = int(data.y);
    int yuv_format = int(data.z);
    return YuvPrimitive(channel_bit_depth, color_space, yuv_format);
}

void brush_vs(
    VertexInfo vi,
    int prim_address,
    RectWithEndpoint local_rect,
    RectWithEndpoint segment_rect,
    ivec4 prim_user_data,
    int specific_resource_address,
    mat4 transform,
    PictureTask pic_task,
    int brush_flags,
    vec4 unused
) {
    vec2 f = (vi.local_pos - local_rect.p0) / rect_size(local_rect);

    YuvPrimitive prim = fetch_yuv_primitive(prim_address);

#ifdef SWGL_DRAW_SPAN
    // swgl_commitTextureLinearYUV needs to know the color space specifier and
    // also needs to know how many bits of scaling are required to normalize
    // HDR textures. Note that MSB HDR formats don't need renormalization.
    vRescaleFactor = 0;
    if (prim.channel_bit_depth > 8 && prim.yuv_format != YUV_FORMAT_P010) {
        vRescaleFactor = 16 - prim.channel_bit_depth;
    }
#endif

    YuvColorMatrixInfo mat_info = get_rgb_from_ycbcr_info(prim);
    vYcbcrBias = mat_info.ycbcr_bias;
    vRgbFromDebiasedYcbcr = mat_info.rgb_from_debiased_ycbrc;

    vFormat.x = prim.yuv_format;

    // The additional test for 99 works around a gen6 shader compiler bug: 1708937
    if (vFormat.x == YUV_FORMAT_PLANAR || vFormat.x == 99) {
        ImageSource res_y = fetch_image_source(prim_user_data.x);
        ImageSource res_u = fetch_image_source(prim_user_data.y);
        ImageSource res_v = fetch_image_source(prim_user_data.z);
        write_uv_rect(res_y.uv_rect.p0, res_y.uv_rect.p1, f, TEX_SIZE_YUV(sColor0), vUv_Y, vUvBounds_Y);
        write_uv_rect(res_u.uv_rect.p0, res_u.uv_rect.p1, f, TEX_SIZE_YUV(sColor1), vUv_U, vUvBounds_U);
        write_uv_rect(res_v.uv_rect.p0, res_v.uv_rect.p1, f, TEX_SIZE_YUV(sColor2), vUv_V, vUvBounds_V);
    } else if (vFormat.x == YUV_FORMAT_NV12 || vFormat.x == YUV_FORMAT_P010) {
        ImageSource res_y = fetch_image_source(prim_user_data.x);
        ImageSource res_u = fetch_image_source(prim_user_data.y);
        write_uv_rect(res_y.uv_rect.p0, res_y.uv_rect.p1, f, TEX_SIZE_YUV(sColor0), vUv_Y, vUvBounds_Y);
        write_uv_rect(res_u.uv_rect.p0, res_u.uv_rect.p1, f, TEX_SIZE_YUV(sColor1), vUv_U, vUvBounds_U);
    } else if (vFormat.x == YUV_FORMAT_INTERLEAVED) {
        ImageSource res_y = fetch_image_source(prim_user_data.x);
        write_uv_rect(res_y.uv_rect.p0, res_y.uv_rect.p1, f, TEX_SIZE_YUV(sColor0), vUv_Y, vUvBounds_Y);
    }
}
#endif

#ifdef WR_FRAGMENT_SHADER

Fragment brush_fs() {
    vec4 color = sample_yuv(
        vFormat.x,
        vYcbcrBias,
        vRgbFromDebiasedYcbcr,
        vUv_Y,
        vUv_U,
        vUv_V,
        vUvBounds_Y,
        vUvBounds_U,
        vUvBounds_V
    );

#ifdef WR_FEATURE_ALPHA_PASS
    color *= antialias_brush();
#endif

    //color.r = float(100+vFormat) / 255.0;
    //color.g = vYcbcrBias.x;
    //color.b = vYcbcrBias.y;
    return Fragment(color);
}

#ifdef SWGL_DRAW_SPAN
void swgl_drawSpanRGBA8() {
    if (vFormat.x == YUV_FORMAT_PLANAR) {
        swgl_commitTextureLinearYUV(sColor0, vUv_Y, vUvBounds_Y,
                                    sColor1, vUv_U, vUvBounds_U,
                                    sColor2, vUv_V, vUvBounds_V,
                                    vYcbcrBias,
                                    vRgbFromDebiasedYcbcr,
                                    vRescaleFactor);
    } else if (vFormat.x == YUV_FORMAT_NV12 || vFormat.x == YUV_FORMAT_P010) {
        swgl_commitTextureLinearYUV(sColor0, vUv_Y, vUvBounds_Y,
                                    sColor1, vUv_U, vUvBounds_U,
                                    vYcbcrBias,
                                    vRgbFromDebiasedYcbcr,
                                    vRescaleFactor);
    } else if (vFormat.x == YUV_FORMAT_INTERLEAVED) {
        swgl_commitTextureLinearYUV(sColor0, vUv_Y, vUvBounds_Y,
                                    vYcbcrBias,
                                    vRgbFromDebiasedYcbcr,
                                    vRescaleFactor);
    }
}
#endif

#endif
clip_shared/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include rect,render_task,gpu_cache,transform

#ifdef WR_VERTEX_SHADER

PER_INSTANCE in vec4 aClipDeviceArea;
PER_INSTANCE in vec4 aClipOrigins;
PER_INSTANCE in float aDevicePixelScale;
PER_INSTANCE in ivec2 aTransformIds;

struct ClipMaskInstanceCommon {
    RectWithEndpoint sub_rect;
    vec2 task_origin;
    vec2 screen_origin;
    float device_pixel_scale;
    int clip_transform_id;
    int prim_transform_id;
};

ClipMaskInstanceCommon fetch_clip_item_common() {
    ClipMaskInstanceCommon cmi;

    cmi.sub_rect = RectWithEndpoint(aClipDeviceArea.xy, aClipDeviceArea.zw);
    cmi.task_origin = aClipOrigins.xy;
    cmi.screen_origin = aClipOrigins.zw;
    cmi.device_pixel_scale = aDevicePixelScale;
    cmi.clip_transform_id = aTransformIds.x;
    cmi.prim_transform_id = aTransformIds.y;

    return cmi;
}

struct ClipVertexInfo {
    vec4 local_pos;
    RectWithEndpoint clipped_local_rect;
};

// The transformed vertex function that always covers the whole clip area,
// which is the intersection of all clip instances of a given primitive
ClipVertexInfo write_clip_tile_vertex(RectWithEndpoint local_clip_rect,
                                      Transform prim_transform,
                                      Transform clip_transform,
                                      RectWithEndpoint sub_rect,
                                      vec2 task_origin,
                                      vec2 screen_origin,
                                      float device_pixel_scale) {
    vec2 device_pos = screen_origin + mix(sub_rect.p0, sub_rect.p1, aPosition.xy);
    vec2 world_pos = device_pos / device_pixel_scale;

    vec4 pos = prim_transform.m * vec4(world_pos, 0.0, 1.0);
    pos.xyz /= pos.w;

    vec4 p = get_node_pos(pos.xy, clip_transform);
    vec4 local_pos = p * pos.w;

    //TODO: Interpolate in clip space, where "local_pos.w" contains
    // the W of the homogeneous transform *from* clip space into the world.
    //    float interpolate_w = 1.0 / local_pos.w;
    // This is problematic today, because the W<=0 hemisphere is going to be
    // clipped, while we currently want this shader to fill out the whole rect.
    // We can therefore simplify this when the clip construction is rewritten
    // to only affect the areas touched by a clip.
    vec4 vertex_pos = vec4(
        task_origin + mix(sub_rect.p0, sub_rect.p1, aPosition.xy),
        0.0,
        1.0
    );

    gl_Position = uTransform * vertex_pos;

    init_transform_vs(vec4(local_clip_rect.p0, local_clip_rect.p1));

    ClipVertexInfo vi = ClipVertexInfo(local_pos, local_clip_rect);
    return vi;
}

#endif //WR_VERTEX_SHADER
86295c7240a0539/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// Composite a picture cache tile into the framebuffer.

// This shader must remain compatible with ESSL 1, at least for the
// WR_FEATURE_TEXTURE_EXTERNAL_ESSL1 feature, so that it can be used to render
// video on GLES devices without GL_OES_EGL_image_external_essl3 support.
// This means we cannot use textureSize(), int inputs/outputs, etc.

#include shared

#ifdef WR_FEATURE_YUV
#include yuv
#endif

#ifdef WR_FEATURE_YUV
YUV_PRECISION flat varying vec3 vYcbcrBias;
YUV_PRECISION flat varying mat3 vRgbFromDebiasedYcbcr;
// YUV format. Packed in to vector to avoid bug 1630356.
flat varying ivec2 vYuvFormat;

#ifdef SWGL_DRAW_SPAN
flat varying int vRescaleFactor;
#endif
varying vec2 vUV_y;
varying vec2 vUV_u;
varying vec2 vUV_v;
flat varying vec4 vUVBounds_y;
flat varying vec4 vUVBounds_u;
flat varying vec4 vUVBounds_v;
#else
varying vec2 vUv;
#ifndef WR_FEATURE_FAST_PATH
flat varying vec4 vColor;
flat varying vec4 vUVBounds;
#endif
#ifdef WR_FEATURE_TEXTURE_EXTERNAL_ESSL1
uniform vec2 uTextureSize;
#endif
#endif

#ifdef WR_VERTEX_SHADER
// CPU side data is in CompositeInstance (gpu_types.rs) and is
// converted to GPU data using desc::COMPOSITE (renderer.rs) by
// filling vaos.composite_vao with VertexArrayKind::Composite.
PER_INSTANCE attribute vec4 aLocalRect;
PER_INSTANCE attribute vec4 aDeviceClipRect;
PER_INSTANCE attribute vec4 aColor;
PER_INSTANCE attribute vec4 aParams;
PER_INSTANCE attribute vec4 aTransform;

#ifdef WR_FEATURE_YUV
// YUV treats these as a UV clip rect (clamp)
PER_INSTANCE attribute vec4 aUvRect0;
PER_INSTANCE attribute vec4 aUvRect1;
PER_INSTANCE attribute vec4 aUvRect2;
#else
PER_INSTANCE attribute vec4 aUvRect0;
#endif

vec2 apply_transform(vec2 p, vec4 transform) {
    return p * transform.xy + transform.zw;
}

#ifdef WR_FEATURE_YUV
YuvPrimitive fetch_yuv_primitive() {
    // From ExternalSurfaceDependency::Yuv:
    int color_space = int(aParams.y);
    int yuv_format = int(aParams.z);
    int channel_bit_depth = int(aParams.w);
    return YuvPrimitive(channel_bit_depth, color_space, yuv_format);
}
#endif

void main(void) {
	// Get world position
    vec2 world_p0 = apply_transform(aLocalRect.xy, aTransform);
    vec2 world_p1 = apply_transform(aLocalRect.zw, aTransform);
    vec2 world_pos = mix(world_p0, world_p1, aPosition.xy);

    // Clip the position to the world space clip rect
    vec2 clipped_world_pos = clamp(world_pos, aDeviceClipRect.xy, aDeviceClipRect.zw);

    // Derive the normalized UV from the clipped vertex position
    vec2 uv = (clipped_world_pos - world_p0) / (world_p1 - world_p0);

#ifdef WR_FEATURE_YUV
    YuvPrimitive prim = fetch_yuv_primitive();

#ifdef SWGL_DRAW_SPAN
    // swgl_commitTextureLinearYUV needs to know the color space specifier and
    // also needs to know how many bits of scaling are required to normalize
    // HDR textures. Note that MSB HDR formats don't need renormalization.
    vRescaleFactor = 0;
    if (prim.channel_bit_depth > 8 && prim.yuv_format != YUV_FORMAT_P010) {
        vRescaleFactor = 16 - prim.channel_bit_depth;
    }
#endif

    YuvColorMatrixInfo mat_info = get_rgb_from_ycbcr_info(prim);
    vYcbcrBias = mat_info.ycbcr_bias;
    vRgbFromDebiasedYcbcr = mat_info.rgb_from_debiased_ycbrc;

    vYuvFormat.x = prim.yuv_format;

    write_uv_rect(
        aUvRect0.xy,
        aUvRect0.zw,
        uv,
        TEX_SIZE_YUV(sColor0),
        vUV_y,
        vUVBounds_y
    );
    write_uv_rect(
        aUvRect1.xy,
        aUvRect1.zw,
        uv,
        TEX_SIZE_YUV(sColor1),
        vUV_u,
        vUVBounds_u
    );
    write_uv_rect(
        aUvRect2.xy,
        aUvRect2.zw,
        uv,
        TEX_SIZE_YUV(sColor2),
        vUV_v,
        vUVBounds_v
    );
#else
    uv = mix(aUvRect0.xy, aUvRect0.zw, uv);
    // The uvs may be inverted, so use the min and max for the bounds
    vec4 uvBounds = vec4(min(aUvRect0.xy, aUvRect0.zw), max(aUvRect0.xy, aUvRect0.zw));
    int rescale_uv = int(aParams.y);
    if (rescale_uv == 1)
    {
        // using an atlas, so UVs are in pixels, and need to be
        // normalized and clamped.
#if defined(WR_FEATURE_TEXTURE_RECT)
        vec2 texture_size = vec2(1.0, 1.0);
#elif defined(WR_FEATURE_TEXTURE_EXTERNAL_ESSL1)
        vec2 texture_size = uTextureSize;
#else
        vec2 texture_size = vec2(TEX_SIZE(sColor0));
#endif
        uvBounds += vec4(0.5, 0.5, -0.5, -0.5);
    #ifndef WR_FEATURE_TEXTURE_RECT
        uv /= texture_size;
        uvBounds /= texture_size.xyxy;
    #endif
    }

    vUv = uv;
#ifndef WR_FEATURE_FAST_PATH
    vUVBounds = uvBounds;
    // Pass through color
    vColor = aColor;
#endif
#endif

    gl_Position = uTransform * vec4(clipped_world_pos, aParams.x /* z_id */, 1.0);
}
#endif

#ifdef WR_FRAGMENT_SHADER
void main(void) {
#ifdef WR_FEATURE_YUV
    vec4 color = sample_yuv(
        vYuvFormat.x,
        vYcbcrBias,
        vRgbFromDebiasedYcbcr,
        vUV_y,
        vUV_u,
        vUV_v,
        vUVBounds_y,
        vUVBounds_u,
        vUVBounds_v
    );
#else
    // The color is just the texture sample modulated by a supplied color.
    // In the fast path we avoid clamping the UV coordinates and modulating by the color.
#ifdef WR_FEATURE_FAST_PATH
    vec2 uv = vUv;
#else
    vec2 uv = clamp(vUv, vUVBounds.xy, vUVBounds.zw);
#endif
    vec4 texel = TEX_SAMPLE(sColor0, uv);
#ifdef WR_FEATURE_FAST_PATH
    vec4 color = texel;
#else
    vec4 color = vColor * texel;
#endif
#endif
    write_output(color);
}

#ifdef SWGL_DRAW_SPAN
void swgl_drawSpanRGBA8() {
#ifdef WR_FEATURE_YUV
    if (vYuvFormat.x == YUV_FORMAT_PLANAR) {
        swgl_commitTextureLinearYUV(sColor0, vUV_y, vUVBounds_y,
                                    sColor1, vUV_u, vUVBounds_u,
                                    sColor2, vUV_v, vUVBounds_v,
                                    vYcbcrBias,
                                    vRgbFromDebiasedYcbcr,
                                    vRescaleFactor);
    } else if (vYuvFormat.x == YUV_FORMAT_NV12 || vYuvFormat.x == YUV_FORMAT_P010) {
        swgl_commitTextureLinearYUV(sColor0, vUV_y, vUVBounds_y,
                                    sColor1, vUV_u, vUVBounds_u,
                                    vYcbcrBias,
                                    vRgbFromDebiasedYcbcr,
                                    vRescaleFactor);
    } else if (vYuvFormat.x == YUV_FORMAT_INTERLEAVED) {
        swgl_commitTextureLinearYUV(sColor0, vUV_y, vUVBounds_y,
                                    vYcbcrBias,
                                    vRgbFromDebiasedYcbcr,
                                    vRescaleFactor);
    }
#else
#ifdef WR_FEATURE_FAST_PATH
    vec4 color = vec4(1.0);
#ifdef WR_FEATURE_TEXTURE_RECT
    vec4 uvBounds = vec4(vec2(0.0), vec2(textureSize(sColor0)));
#else
    vec4 uvBounds = vec4(0.0, 0.0, 1.0, 1.0);
#endif
#else
    vec4 color = vColor;
    vec4 uvBounds = vUVBounds;
#endif
    if (color != vec4(1.0)) {
        swgl_commitTextureColorRGBA8(sColor0, vUv, uvBounds, color);
    } else {
        swgl_commitTextureRGBA8(sColor0, vUv, uvBounds);
    }
#endif
}
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define WR_FEATURE_TEXTURE_2D

#include shared,prim_shared

varying vec2 vUv;
flat varying vec4 vUvRect;
flat varying vec2 vOffsetScale;
// The number of pixels on each end that we apply the blur filter over.
// Packed in to vector to work around bug 1630356.
flat varying ivec2 vSupport;
flat varying vec2 vGaussCoefficients;

#ifdef WR_VERTEX_SHADER
// Applies a separable gaussian blur in one direction, as specified
// by the dir field in the blur command.

#define DIR_HORIZONTAL  0
#define DIR_VERTICAL    1

PER_INSTANCE in int aBlurRenderTaskAddress;
PER_INSTANCE in int aBlurSourceTaskAddress;
PER_INSTANCE in int aBlurDirection;

struct BlurTask {
    RectWithEndpoint task_rect;
    float blur_radius;
    vec2 blur_region;
};

BlurTask fetch_blur_task(int address) {
    RenderTaskData task_data = fetch_render_task_data(address);

    BlurTask task = BlurTask(
        task_data.task_rect,
        task_data.user_data.x,
        task_data.user_data.yz
    );

    return task;
}

void calculate_gauss_coefficients(float sigma) {
    // Incremental Gaussian Coefficent Calculation (See GPU Gems 3 pp. 877 - 889)
    vGaussCoefficients = vec2(1.0 / (sqrt(2.0 * 3.14159265) * sigma),
                              exp(-0.5 / (sigma * sigma)));

    // Pre-calculate the coefficient total in the vertex shader so that
    // we can avoid having to do it per-fragment and also avoid division
    // by zero in the degenerate case.
    vec3 gauss_coefficient = vec3(vGaussCoefficients,
                                  vGaussCoefficients.y * vGaussCoefficients.y);
    float gauss_coefficient_total = gauss_coefficient.x;
    for (int i = 1; i <= vSupport.x; i += 2) {
        gauss_coefficient.xy *= gauss_coefficient.yz;
        float gauss_coefficient_subtotal = gauss_coefficient.x;
        gauss_coefficient.xy *= gauss_coefficient.yz;
        gauss_coefficient_subtotal += gauss_coefficient.x;
        gauss_coefficient_total += 2.0 * gauss_coefficient_subtotal;
    }

    // Scale initial coefficient by total to avoid passing the total separately
    // to the fragment shader.
    vGaussCoefficients.x /= gauss_coefficient_total;
}

void main(void) {
    BlurTask blur_task = fetch_blur_task(aBlurRenderTaskAddress);
    RectWithEndpoint src_rect = fetch_render_task_rect(aBlurSourceTaskAddress);

    RectWithEndpoint target_rect = blur_task.task_rect;

    vec2 texture_size = vec2(TEX_SIZE(sColor0).xy);

    // Ensure that the support is an even number of pixels to simplify the
    // fragment shader logic.
    //
    // TODO(pcwalton): Actually make use of this fact and use the texture
    // hardware for linear filtering.
    vSupport.x = int(ceil(1.5 * blur_task.blur_radius)) * 2;

    if (vSupport.x > 0) {
        calculate_gauss_coefficients(blur_task.blur_radius);
    } else {
        // The gauss function gets NaNs when blur radius is zero.
        vGaussCoefficients = vec2(1.0, 1.0);
    }

    switch (aBlurDirection) {
        case DIR_HORIZONTAL:
            vOffsetScale = vec2(1.0 / texture_size.x, 0.0);
            break;
        case DIR_VERTICAL:
            vOffsetScale = vec2(0.0, 1.0 / texture_size.y);
            break;
        default:
            vOffsetScale = vec2(0.0);
    }

    vUvRect = vec4(src_rect.p0 + vec2(0.5),
                   src_rect.p0 + blur_task.blur_region - vec2(0.5));
    vUvRect /= texture_size.xyxy;

    vec2 pos = mix(target_rect.p0, target_rect.p1, aPosition.xy);

    vec2 uv0 = src_rect.p0 / texture_size;
    vec2 uv1 = src_rect.p1 / texture_size;
    vUv = mix(uv0, uv1, aPosition.xy);

    gl_Position = uTransform * vec4(pos, 0.0, 1.0);
}
#endif

#ifdef WR_FRAGMENT_SHADER

#if defined WR_FEATURE_COLOR_TARGET
#define SAMPLE_TYPE vec4
#define SAMPLE_TEXTURE(uv)  texture(sColor0, uv)
#else
#define SAMPLE_TYPE float
#define SAMPLE_TEXTURE(uv)  texture(sColor0, uv).r
#endif

// TODO(gw): Write a fast path blur that handles smaller blur radii
//           with a offset / weight uniform table and a constant
//           loop iteration count!

void main(void) {
    SAMPLE_TYPE original_color = SAMPLE_TEXTURE(vUv);

    // Incremental Gaussian Coefficent Calculation (See GPU Gems 3 pp. 877 - 889)
    vec3 gauss_coefficient = vec3(vGaussCoefficients,
                                  vGaussCoefficients.y * vGaussCoefficients.y);

    SAMPLE_TYPE avg_color = original_color * gauss_coefficient.x;

    // Evaluate two adjacent texels at a time. We can do this because, if c0
    // and c1 are colors of adjacent texels and k0 and k1 are arbitrary
    // factors, this formula:
    //
    //     k0 * c0 + k1 * c1          (Equation 1)
    //
    // is equivalent to:
    //
    //                                 k1
    //     (k0 + k1) * lerp(c0, c1, -------)
    //                              k0 + k1
    //
    // A texture lookup of adjacent texels evaluates this formula:
    //
    //     lerp(c0, c1, t)
    //
    // for some t. So we can let `t = k1/(k0 + k1)` and effectively evaluate
    // Equation 1 with a single texture lookup.
    //
    // Clamp loop condition variable to a statically known value to workaround
    // driver bug on Adreno 3xx. vSupport should not exceed 300 anyway, due to
    // the max blur radius being 100. See bug 1720841 for details.
    int support = min(vSupport.x, 300);
    for (int i = 1; i <= support; i += 2) {
        gauss_coefficient.xy *= gauss_coefficient.yz;

        float gauss_coefficient_subtotal = gauss_coefficient.x;
        gauss_coefficient.xy *= gauss_coefficient.yz;
        gauss_coefficient_subtotal += gauss_coefficient.x;
        float gauss_ratio = gauss_coefficient.x / gauss_coefficient_subtotal;

        vec2 offset = vOffsetScale * (float(i) + gauss_ratio);

        vec2 st0 = max(vUv - offset, vUvRect.xy);
        vec2 st1 = min(vUv + offset, vUvRect.zw);
        avg_color += (SAMPLE_TEXTURE(st0) + SAMPLE_TEXTURE(st1)) *
                     gauss_coefficient_subtotal;
    }

    oFragColor = vec4(avg_color);
}

#ifdef SWGL_DRAW_SPAN
    #ifdef WR_FEATURE_COLOR_TARGET
void swgl_drawSpanRGBA8() {
    swgl_commitGaussianBlurRGBA8(sColor0, vUv, vUvRect, vOffsetScale.x != 0.0,
                                 vSupport.x, vGaussCoefficients);
}
    #else
void swgl_drawSpanR8() {
    swgl_commitGaussianBlurR8(sColor0, vUv, vUvRect, vOffsetScale.x != 0.0,
                              vSupport.x, vGaussCoefficients);
}
    #endif
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared,rect,ellipse

// For edges, the colors are the same. For corners, these
// are the colors of each edge making up the corner.
flat varying vec4 vColor00;
flat varying vec4 vColor01;
flat varying vec4 vColor10;
flat varying vec4 vColor11;

// A point + tangent defining the line where the edge
// transition occurs. Used for corners only.
flat varying vec4 vColorLine;

// x: segment, y: clip mode
// We cast these to/from floats rather than using an ivec due to a driver bug
// on Adreno 3xx. See bug 1730458.
flat varying mediump vec2 vSegmentClipMode;
// x, y: styles, z, w: edge axes
// We cast these to/from floats rather than using an ivec (and bitshifting)
// due to a driver bug on Adreno 3xx. See bug 1730458.
flat varying mediump vec4 vStyleEdgeAxis;

// xy = Local space position of the clip center.
// zw = Scale the rect origin by this to get the outer
// corner from the segment rectangle.
flat varying vec4 vClipCenter_Sign;

// An outer and inner elliptical radii for border
// corner clipping.
flat varying vec4 vClipRadii;

// Reference point for determine edge clip lines.
flat varying vec4 vEdgeReference;

// Stores widths/2 and widths/3 to save doing this in FS.
flat varying vec4 vPartialWidths;

// Clipping parameters for dot or dash.
flat varying vec4 vClipParams1;
flat varying vec4 vClipParams2;

// Local space position
varying vec2 vPos;

#define SEGMENT_TOP_LEFT        0
#define SEGMENT_TOP_RIGHT       1
#define SEGMENT_BOTTOM_RIGHT    2
#define SEGMENT_BOTTOM_LEFT     3
#define SEGMENT_LEFT            4
#define SEGMENT_TOP             5
#define SEGMENT_RIGHT           6
#define SEGMENT_BOTTOM          7

// Border styles as defined in webrender_api/types.rs
#define BORDER_STYLE_NONE         0
#define BORDER_STYLE_SOLID        1
#define BORDER_STYLE_DOUBLE       2
#define BORDER_STYLE_DOTTED       3
#define BORDER_STYLE_DASHED       4
#define BORDER_STYLE_HIDDEN       5
#define BORDER_STYLE_GROOVE       6
#define BORDER_STYLE_RIDGE        7
#define BORDER_STYLE_INSET        8
#define BORDER_STYLE_OUTSET       9

#define CLIP_NONE        0
#define CLIP_DASH_CORNER 1
#define CLIP_DASH_EDGE   2
#define CLIP_DOT         3

#ifdef WR_VERTEX_SHADER

PER_INSTANCE in vec2 aTaskOrigin;
PER_INSTANCE in vec4 aRect;
PER_INSTANCE in vec4 aColor0;
PER_INSTANCE in vec4 aColor1;
PER_INSTANCE in int aFlags;
PER_INSTANCE in vec2 aWidths;
PER_INSTANCE in vec2 aRadii;
PER_INSTANCE in vec4 aClipParams1;
PER_INSTANCE in vec4 aClipParams2;

vec2 get_outer_corner_scale(int segment) {
    vec2 p;

    switch (segment) {
        case SEGMENT_TOP_LEFT:
            p = vec2(0.0, 0.0);
            break;
        case SEGMENT_TOP_RIGHT:
            p = vec2(1.0, 0.0);
            break;
        case SEGMENT_BOTTOM_RIGHT:
            p = vec2(1.0, 1.0);
            break;
        case SEGMENT_BOTTOM_LEFT:
            p = vec2(0.0, 1.0);
            break;
        default:
            // The result is only used for non-default segment cases
            p = vec2(0.0);
            break;
    }

    return p;
}

// NOTE(emilio): If you change this algorithm, do the same change
// in border.rs
vec4 mod_color(vec4 color, bool is_black, bool lighter) {
    const float light_black = 0.7;
    const float dark_black = 0.3;

    const float dark_scale = 0.66666666;
    const float light_scale = 1.0;

    if (is_black) {
        if (lighter) {
            return vec4(vec3(light_black), color.a);
        }
        return vec4(vec3(dark_black), color.a);
    }

    if (lighter) {
        return vec4(color.rgb * light_scale, color.a);
    }
    return vec4(color.rgb * dark_scale, color.a);
}

vec4[2] get_colors_for_side(vec4 color, int style) {
    vec4 result[2];

    bool is_black = color.rgb == vec3(0.0, 0.0, 0.0);

    switch (style) {
        case BORDER_STYLE_GROOVE:
            result[0] = mod_color(color, is_black, true);
            result[1] = mod_color(color, is_black, false);
            break;
        case BORDER_STYLE_RIDGE:
            result[0] = mod_color(color, is_black, false);
            result[1] = mod_color(color, is_black, true);
            break;
        default:
            result[0] = color;
            result[1] = color;
            break;
    }

    return result;
}

void main(void) {
    int segment = aFlags & 0xff;
    int style0 = (aFlags >> 8) & 0xff;
    int style1 = (aFlags >> 16) & 0xff;
    int clip_mode = (aFlags >> 24) & 0x0f;

    vec2 size = aRect.zw - aRect.xy;
    vec2 outer_scale = get_outer_corner_scale(segment);
    vec2 outer = outer_scale * size;
    vec2 clip_sign = 1.0 - 2.0 * outer_scale;

    // Set some flags used by the FS to determine the
    // orientation of the two edges in this corner.
    ivec2 edge_axis = ivec2(0, 0);
    // Derive the positions for the edge clips, which must be handled
    // differently between corners and edges.
    vec2 edge_reference = vec2(0.0);
    switch (segment) {
        case SEGMENT_TOP_LEFT:
            edge_axis = ivec2(0, 1);
            edge_reference = outer;
            break;
        case SEGMENT_TOP_RIGHT:
            edge_axis = ivec2(1, 0);
            edge_reference = vec2(outer.x - aWidths.x, outer.y);
            break;
        case SEGMENT_BOTTOM_RIGHT:
            edge_axis = ivec2(0, 1);
            edge_reference = outer - aWidths;
            break;
        case SEGMENT_BOTTOM_LEFT:
            edge_axis = ivec2(1, 0);
            edge_reference = vec2(outer.x, outer.y - aWidths.y);
            break;
        case SEGMENT_TOP:
        case SEGMENT_BOTTOM:
            edge_axis = ivec2(1, 1);
            break;
        case SEGMENT_LEFT:
        case SEGMENT_RIGHT:
        default:
            break;
    }

    vSegmentClipMode = vec2(float(segment), float(clip_mode));
    vStyleEdgeAxis = vec4(float(style0), float(style1), float(edge_axis.x), float(edge_axis.y));

    vPartialWidths = vec4(aWidths / 3.0, aWidths / 2.0);
    vPos = size * aPosition.xy;

    vec4[2] color0 = get_colors_for_side(aColor0, style0);
    vColor00 = color0[0];
    vColor01 = color0[1];
    vec4[2] color1 = get_colors_for_side(aColor1, style1);
    vColor10 = color1[0];
    vColor11 = color1[1];
    vClipCenter_Sign = vec4(outer + clip_sign * aRadii, clip_sign);
    vClipRadii = vec4(aRadii, max(aRadii - aWidths, 0.0));
    vColorLine = vec4(outer, aWidths.y * -clip_sign.y, aWidths.x * clip_sign.x);
    vEdgeReference = vec4(edge_reference, edge_reference + aWidths);
    vClipParams1 = aClipParams1;
    vClipParams2 = aClipParams2;

    // For the case of dot and dash clips, optimize the number of pixels that
    // are hit to just include the dot itself.
    if (clip_mode == CLIP_DOT) {
        float radius = aClipParams1.z;

        // Expand by a small amount to allow room for AA around
        // the dot if it's big enough.
        if (radius > 0.5)
            radius += 2.0;

        vPos = vClipParams1.xy + radius * (2.0 * aPosition.xy - 1.0);
        vPos = clamp(vPos, vec2(0.0), size);
    } else if (clip_mode == CLIP_DASH_CORNER) {
        vec2 center = (aClipParams1.xy + aClipParams2.xy) * 0.5;
        // This is a gross approximation which works out because dashes don't have
        // a strong curvature and we will overshoot by inflating the geometry by
        // this amount on each side (sqrt(2) * length(dash) would be enough and we
        // compute 2 * approx_length(dash)).
        float dash_length = length(aClipParams1.xy - aClipParams2.xy);
        float width = max(aWidths.x, aWidths.y);
        // expand by a small amout for AA just like we do for dots.
        vec2 r = vec2(max(dash_length, width)) + 2.0;
        vPos = clamp(vPos, center - r, center + r);
    }

    gl_Position = uTransform * vec4(aTaskOrigin + aRect.xy + vPos, 0.0, 1.0);
}
#endif

#ifdef WR_FRAGMENT_SHADER
vec4 evaluate_color_for_style_in_corner(
    vec2 clip_relative_pos,
    int style,
    vec4 color0,
    vec4 color1,
    vec4 clip_radii,
    float mix_factor,
    int segment,
    float aa_range
) {
    switch (style) {
        case BORDER_STYLE_DOUBLE: {
            // Get the distances from 0.33 of the radii, and
            // also 0.67 of the radii. Use these to form a
            // SDF subtraction which will clip out the inside
            // third of the rounded edge.
            float d_radii_a = distance_to_ellipse(
                clip_relative_pos,
                clip_radii.xy - vPartialWidths.xy
            );
            float d_radii_b = distance_to_ellipse(
                clip_relative_pos,
                clip_radii.xy - 2.0 * vPartialWidths.xy
            );
            float d = min(-d_radii_a, d_radii_b);
            color0 *= distance_aa(aa_range, d);
            break;
        }
        case BORDER_STYLE_GROOVE:
        case BORDER_STYLE_RIDGE: {
            float d = distance_to_ellipse(
                clip_relative_pos,
                clip_radii.xy - vPartialWidths.zw
            );
            float alpha = distance_aa(aa_range, d);
            float swizzled_factor;
            switch (segment) {
                case SEGMENT_TOP_LEFT: swizzled_factor = 0.0; break;
                case SEGMENT_TOP_RIGHT: swizzled_factor = mix_factor; break;
                case SEGMENT_BOTTOM_RIGHT: swizzled_factor = 1.0; break;
                case SEGMENT_BOTTOM_LEFT: swizzled_factor = 1.0 - mix_factor; break;
                default: swizzled_factor = 0.0; break;
            };
            vec4 c0 = mix(color1, color0, swizzled_factor);
            vec4 c1 = mix(color0, color1, swizzled_factor);
            color0 = mix(c0, c1, alpha);
            break;
        }
        default:
            break;
    }

    return color0;
}

vec4 evaluate_color_for_style_in_edge(
    vec2 pos_vec,
    int style,
    vec4 color0,
    vec4 color1,
    float aa_range,
    int edge_axis_id
) {
    vec2 edge_axis = edge_axis_id != 0 ? vec2(0.0, 1.0) : vec2(1.0, 0.0);
    float pos = dot(pos_vec, edge_axis);
    switch (style) {
        case BORDER_STYLE_DOUBLE: {
            float d = -1.0;
            float partial_width = dot(vPartialWidths.xy, edge_axis);
            if (partial_width >= 1.0) {
                vec2 ref = vec2(
                    dot(vEdgeReference.xy, edge_axis) + partial_width,
                    dot(vEdgeReference.zw, edge_axis) - partial_width
                );
                d = min(pos - ref.x, ref.y - pos);
            }
            color0 *= distance_aa(aa_range, d);
            break;
        }
        case BORDER_STYLE_GROOVE:
        case BORDER_STYLE_RIDGE: {
            float ref = dot(vEdgeReference.xy + vPartialWidths.zw, edge_axis);
            float d = pos - ref;
            float alpha = distance_aa(aa_range, d);
            color0 = mix(color0, color1, alpha);
            break;
        }
        default:
            break;
    }

    return color0;
}

void main(void) {
    float aa_range = compute_aa_range(vPos);
    vec4 color0, color1;

    int segment = int(vSegmentClipMode.x);
    int clip_mode = int(vSegmentClipMode.y);
    ivec2 style = ivec2(int(vStyleEdgeAxis.x), int(vStyleEdgeAxis.y));
    ivec2 edge_axis = ivec2(int(vStyleEdgeAxis.z), int(vStyleEdgeAxis.w));

    float mix_factor = 0.0;
    if (edge_axis.x != edge_axis.y) {
        float d_line = distance_to_line(vColorLine.xy, vColorLine.zw, vPos);
        mix_factor = distance_aa(aa_range, -d_line);
    }

    // Check if inside corner clip-region
    vec2 clip_relative_pos = vPos - vClipCenter_Sign.xy;
    bool in_clip_region = all(lessThan(vClipCenter_Sign.zw * clip_relative_pos, vec2(0.0)));
    float d = -1.0;

    switch (clip_mode) {
        case CLIP_DOT: {
            // Set clip distance based or dot position and radius.
            d = distance(vClipParams1.xy, vPos) - vClipParams1.z;
            break;
        }
        case CLIP_DASH_EDGE: {
            bool is_vertical = vClipParams1.x == 0.;
            float half_dash = is_vertical ? vClipParams1.y : vClipParams1.x;
            // We want to draw something like:
            // +---+---+---+---+
            // |xxx|   |   |xxx|
            // +---+---+---+---+
            float pos = is_vertical ? vPos.y : vPos.x;
            bool in_dash = pos < half_dash || pos > 3.0 * half_dash;
            if (!in_dash) {
                d = 1.;
            }
            break;
        }
        case CLIP_DASH_CORNER: {
            // Get SDF for the two line/tangent clip lines,
            // do SDF subtract to get clip distance.
            float d0 = distance_to_line(vClipParams1.xy,
                                        vClipParams1.zw,
                                        vPos);
            float d1 = distance_to_line(vClipParams2.xy,
                                        vClipParams2.zw,
                                        vPos);
            d = max(d0, -d1);
            break;
        }
        case CLIP_NONE:
        default:
            break;
    }

    if (in_clip_region) {
        float d_radii_a = distance_to_ellipse(clip_relative_pos, vClipRadii.xy);
        float d_radii_b = distance_to_ellipse(clip_relative_pos, vClipRadii.zw);
        float d_radii = max(d_radii_a, -d_radii_b);
        d = max(d, d_radii);

        color0 = evaluate_color_for_style_in_corner(
            clip_relative_pos,
            style.x,
            vColor00,
            vColor01,
            vClipRadii,
            mix_factor,
            segment,
            aa_range
        );
        color1 = evaluate_color_for_style_in_corner(
            clip_relative_pos,
            style.y,
            vColor10,
            vColor11,
            vClipRadii,
            mix_factor,
            segment,
            aa_range
        );
    } else {
        color0 = evaluate_color_for_style_in_edge(
            vPos,
            style.x,
            vColor00,
            vColor01,
            aa_range,
            edge_axis.x
        );
        color1 = evaluate_color_for_style_in_edge(
            vPos,
            style.y,
            vColor10,
            vColor11,
            aa_range,
            edge_axis.y
        );
    }

    float alpha = distance_aa(aa_range, d);
    vec4 color = mix(color0, color1, mix_factor);
    oFragColor = color * alpha;
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared,rect,ellipse

#define DONT_MIX 0
#define MIX_AA 1
#define MIX_NO_AA 2

// For edges, the colors are the same. For corners, these
// are the colors of each edge making up the corner.
flat varying vec4 vColor0;
flat varying vec4 vColor1;

// A point + tangent defining the line where the edge
// transition occurs. Used for corners only.
flat varying vec4 vColorLine;

// A boolean indicating that we should be mixing between edge colors.
// Packed in to a vector to work around bug 1630356.
flat varying ivec2 vMixColors;

// xy = Local space position of the clip center.
// zw = Scale the rect origin by this to get the outer
// corner from the segment rectangle.
flat varying vec4 vClipCenter_Sign;

// An outer and inner elliptical radii for border
// corner clipping.
flat varying vec4 vClipRadii;

// Position, scale, and radii of horizontally and vertically adjacent corner clips.
flat varying vec4 vHorizontalClipCenter_Sign;
flat varying vec2 vHorizontalClipRadii;
flat varying vec4 vVerticalClipCenter_Sign;
flat varying vec2 vVerticalClipRadii;

// Local space position
varying vec2 vPos;

#define SEGMENT_TOP_LEFT        0
#define SEGMENT_TOP_RIGHT       1
#define SEGMENT_BOTTOM_RIGHT    2
#define SEGMENT_BOTTOM_LEFT     3

#ifdef WR_VERTEX_SHADER

PER_INSTANCE in vec2 aTaskOrigin;
PER_INSTANCE in vec4 aRect;
PER_INSTANCE in vec4 aColor0;
PER_INSTANCE in vec4 aColor1;
PER_INSTANCE in int aFlags;
PER_INSTANCE in vec2 aWidths;
PER_INSTANCE in vec2 aRadii;
PER_INSTANCE in vec4 aClipParams1;
PER_INSTANCE in vec4 aClipParams2;

vec2 get_outer_corner_scale(int segment) {
    vec2 p;

    switch (segment) {
        case SEGMENT_TOP_LEFT:
            p = vec2(0.0, 0.0);
            break;
        case SEGMENT_TOP_RIGHT:
            p = vec2(1.0, 0.0);
            break;
        case SEGMENT_BOTTOM_RIGHT:
            p = vec2(1.0, 1.0);
            break;
        case SEGMENT_BOTTOM_LEFT:
            p = vec2(0.0, 1.0);
            break;
        default:
            // The result is only used for non-default segment cases
            p = vec2(0.0);
            break;
    }

    return p;
}

void main(void) {
    int segment = aFlags & 0xff;
    bool do_aa = ((aFlags >> 24) & 0xf0) != 0;

    vec2 outer_scale = get_outer_corner_scale(segment);
    vec2 size = aRect.zw - aRect.xy;
    vec2 outer = outer_scale * size;
    vec2 clip_sign = 1.0 - 2.0 * outer_scale;

    int mix_colors;
    switch (segment) {
        case SEGMENT_TOP_LEFT:
        case SEGMENT_TOP_RIGHT:
        case SEGMENT_BOTTOM_RIGHT:
        case SEGMENT_BOTTOM_LEFT: {
            mix_colors = do_aa ? MIX_AA : MIX_NO_AA;
            break;
        }
        default:
            mix_colors = DONT_MIX;
            break;
    }

    vMixColors.x = mix_colors;
    vPos = size * aPosition.xy;

    vColor0 = aColor0;
    vColor1 = aColor1;
    vClipCenter_Sign = vec4(outer + clip_sign * aRadii, clip_sign);
    vClipRadii = vec4(aRadii, max(aRadii - aWidths, 0.0));
    vColorLine = vec4(outer, aWidths.y * -clip_sign.y, aWidths.x * clip_sign.x);

    vec2 horizontal_clip_sign = vec2(-clip_sign.x, clip_sign.y);
    vHorizontalClipCenter_Sign = vec4(aClipParams1.xy +
                                      horizontal_clip_sign * aClipParams1.zw,
                                      horizontal_clip_sign);
    vHorizontalClipRadii = aClipParams1.zw;

    vec2 vertical_clip_sign = vec2(clip_sign.x, -clip_sign.y);
    vVerticalClipCenter_Sign = vec4(aClipParams2.xy +
                                    vertical_clip_sign * aClipParams2.zw,
                                    vertical_clip_sign);
    vVerticalClipRadii = aClipParams2.zw;

    gl_Position = uTransform * vec4(aTaskOrigin + aRect.xy + vPos, 0.0, 1.0);
}
#endif

#ifdef WR_FRAGMENT_SHADER
void main(void) {
    float aa_range = compute_aa_range(vPos);
    bool do_aa = vMixColors.x != MIX_NO_AA;

    float mix_factor = 0.0;
    if (vMixColors.x != DONT_MIX) {
        float d_line = distance_to_line(vColorLine.xy, vColorLine.zw, vPos);
        if (do_aa) {
            mix_factor = distance_aa(aa_range, -d_line);
        } else {
            mix_factor = d_line + EPSILON >= 0. ? 1.0 : 0.0;
        }
    }

    // Check if inside main corner clip-region
    vec2 clip_relative_pos = vPos - vClipCenter_Sign.xy;
    bool in_clip_region = all(lessThan(vClipCenter_Sign.zw * clip_relative_pos, vec2(0.0)));

    float d = -1.0;
    if (in_clip_region) {
        float d_radii_a = distance_to_ellipse(clip_relative_pos, vClipRadii.xy);
        float d_radii_b = distance_to_ellipse(clip_relative_pos, vClipRadii.zw);
        d = max(d_radii_a, -d_radii_b);
    }

    // And again for horizontally-adjacent corner
    clip_relative_pos = vPos - vHorizontalClipCenter_Sign.xy;
    in_clip_region = all(lessThan(vHorizontalClipCenter_Sign.zw * clip_relative_pos, vec2(0.0)));
    if (in_clip_region) {
        float d_radii = distance_to_ellipse(clip_relative_pos, vHorizontalClipRadii.xy);
        d = max(d_radii, d);
    }

    // And finally for vertically-adjacent corner
    clip_relative_pos = vPos - vVerticalClipCenter_Sign.xy;
    in_clip_region = all(lessThan(vVerticalClipCenter_Sign.zw * clip_relative_pos, vec2(0.0)));
    if (in_clip_region) {
        float d_radii = distance_to_ellipse(clip_relative_pos, vVerticalClipRadii.xy);
        d = max(d_radii, d);
    }

    float alpha = do_aa ? distance_aa(aa_range, d) : 1.0;
    vec4 color = mix(vColor0, vColor1, mix_factor);
    oFragColor = color * alpha;
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared,clip_shared

varying vec4 vLocalPos;
varying vec2 vUv;
flat varying vec4 vUvBounds;
flat varying vec4 vEdge;
flat varying vec4 vUvBounds_NoClamp;
// Clip mode. Packed in to a vector to avoid bug 1630356.
flat varying vec2 vClipMode;

#define MODE_STRETCH        0
#define MODE_SIMPLE         1

#ifdef WR_VERTEX_SHADER

PER_INSTANCE in ivec2 aClipDataResourceAddress;
PER_INSTANCE in vec2 aClipSrcRectSize;
PER_INSTANCE in int aClipMode;
PER_INSTANCE in ivec2 aStretchMode;
PER_INSTANCE in vec4 aClipDestRect;

struct ClipMaskInstanceBoxShadow {
    ClipMaskInstanceCommon base;
    ivec2 resource_address;
};

ClipMaskInstanceBoxShadow fetch_clip_item() {
    ClipMaskInstanceBoxShadow cmi;

    cmi.base = fetch_clip_item_common();
    cmi.resource_address = aClipDataResourceAddress;

    return cmi;
}

struct BoxShadowData {
    vec2 src_rect_size;
    int clip_mode;
    int stretch_mode_x;
    int stretch_mode_y;
    RectWithEndpoint dest_rect;
};

BoxShadowData fetch_data() {
    BoxShadowData bs_data = BoxShadowData(
        aClipSrcRectSize,
        aClipMode,
        aStretchMode.x,
        aStretchMode.y,
        RectWithEndpoint(aClipDestRect.xy, aClipDestRect.zw)
    );
    return bs_data;
}

void main(void) {
    ClipMaskInstanceBoxShadow cmi = fetch_clip_item();
    Transform clip_transform = fetch_transform(cmi.base.clip_transform_id);
    Transform prim_transform = fetch_transform(cmi.base.prim_transform_id);
    BoxShadowData bs_data = fetch_data();
    ImageSource res = fetch_image_source_direct(cmi.resource_address);

    RectWithEndpoint dest_rect = bs_data.dest_rect;

    ClipVertexInfo vi = write_clip_tile_vertex(
        dest_rect,
        prim_transform,
        clip_transform,
        cmi.base.sub_rect,
        cmi.base.task_origin,
        cmi.base.screen_origin,
        cmi.base.device_pixel_scale
    );
    vClipMode.x = float(bs_data.clip_mode);

    vec2 texture_size = vec2(TEX_SIZE(sColor0));
    vec2 local_pos = vi.local_pos.xy / vi.local_pos.w;
    vLocalPos = vi.local_pos;
    vec2 dest_rect_size = rect_size(dest_rect);

    switch (bs_data.stretch_mode_x) {
        case MODE_STRETCH: {
            vEdge.x = 0.5;
            vEdge.z = (dest_rect_size.x / bs_data.src_rect_size.x) - 0.5;
            vUv.x = (local_pos.x - dest_rect.p0.x) / bs_data.src_rect_size.x;
            break;
        }
        case MODE_SIMPLE:
        default: {
            vEdge.xz = vec2(1.0);
            vUv.x = (local_pos.x - dest_rect.p0.x) / dest_rect_size.x;
            break;
        }
    }

    switch (bs_data.stretch_mode_y) {
        case MODE_STRETCH: {
            vEdge.y = 0.5;
            vEdge.w = (dest_rect_size.y / bs_data.src_rect_size.y) - 0.5;
            vUv.y = (local_pos.y - dest_rect.p0.y) / bs_data.src_rect_size.y;
            break;
        }
        case MODE_SIMPLE:
        default: {
            vEdge.yw = vec2(1.0);
            vUv.y = (local_pos.y - dest_rect.p0.y) / dest_rect_size.y;
            break;
        }
    }

    vUv *= vi.local_pos.w;
    vec2 uv0 = res.uv_rect.p0;
    vec2 uv1 = res.uv_rect.p1;
    vUvBounds = vec4(uv0 + vec2(0.5), uv1 - vec2(0.5)) / texture_size.xyxy;
    vUvBounds_NoClamp = vec4(uv0, uv1) / texture_size.xyxy;
}
#endif

#ifdef WR_FRAGMENT_SHADER
void main(void) {
    vec2 uv_linear = vUv / vLocalPos.w;
    vec2 uv = clamp(uv_linear, vec2(0.0), vEdge.xy);
    uv += max(vec2(0.0), uv_linear - vEdge.zw);
    uv = mix(vUvBounds_NoClamp.xy, vUvBounds_NoClamp.zw, uv);
    uv = clamp(uv, vUvBounds.xy, vUvBounds.zw);

    float in_shadow_rect = init_transform_rough_fs(vLocalPos.xy / vLocalPos.w);

    float texel = TEX_SAMPLE(sColor0, uv).r;

    float alpha = mix(texel, 1.0 - texel, vClipMode.x);
    float result = vLocalPos.w > 0.0 ? mix(vClipMode.x, alpha, in_shadow_rect) : 0.0;

    oFragColor = vec4(result);
}

#ifdef SWGL_DRAW_SPAN
// As with cs_clip_rectangle, this shader spends a lot of time doing clipping and
// combining for every fragment, even if outside of the primitive to initialize
// the clip tile, or inside the inner bounds of the primitive, where the shadow
// is unnecessary. To alleviate this, the span shader attempts to first intersect
// the the local clip bounds, outside of which we can just use a solid fill
// to initialize those clip tile fragments. Once inside the primitive bounds,
// we further intersect with the inner region where no shadow is necessary either
// so that we can commit entire spans of texture within this nine-patch region
// instead of having to do the work of mapping per fragment.
void swgl_drawSpanR8() {
    // If the span is completely outside the Z-range and clipped out, just
    // output clear so we don't need to consider invalid W in the rest of the
    // shader.
    float w = swgl_forceScalar(vLocalPos.w);
    if (w <= 0.0) {
        swgl_commitSolidR8(0.0);
        return;
    }

    // To start, we evaluate the box shadow in both UV and local space relative
    // to the local-space position. This will be interpolated across the span to
    // track whether we intersect the nine-patch.
    w = 1.0 / w;
    vec2 uv_linear = vUv * w;
    vec2 uv_linear0 = swgl_forceScalar(uv_linear);
    vec2 uv_linear_step = swgl_interpStep(vUv).xy * w;
    vec2 local_pos = vLocalPos.xy * w;
    vec2 local_pos0 = swgl_forceScalar(local_pos);
    vec2 local_step = swgl_interpStep(vLocalPos).xy * w;

    // We need to compute the local-space distance to the bounding box and then
    // figure out how many processing steps that maps to. If we are stepping in
    // a negative direction on an axis, we need to swap the sides of the box
    // which we consider as the start or end. If there is no local-space step
    // on an axis (i.e. constant Y), we need to take care to force the steps to
    // either the start or end of the span depending on if we are inside or
    // outside of the bounding box.
    vec4 clip_dist =
        mix(vTransformBounds, vTransformBounds.zwxy, lessThan(local_step, vec2(0.0)).xyxy)
            - local_pos0.xyxy;
    clip_dist =
        mix(1.0e6 * step(0.0, clip_dist),
            clip_dist * recip(local_step).xyxy,
            notEqual(local_step, vec2(0.0)).xyxy);

    // Find the start and end of the shadowed region on this span.
    float shadow_start = max(clip_dist.x, clip_dist.y);
    float shadow_end = min(clip_dist.z, clip_dist.w);

    // Flip the offsets from the start of the span so we can compare against the
    // remaining span length which automatically deducts as we commit fragments.
    ivec2 shadow_steps = ivec2(clamp(
        swgl_SpanLength - swgl_StepSize * vec2(floor(shadow_start), ceil(shadow_end)),
        0.0, swgl_SpanLength));
    int shadow_start_len = shadow_steps.x;
    int shadow_end_len = shadow_steps.y;

    // Likewise, once inside the primitive bounds, we also need to track which
    // sector of the nine-patch we are in which requires intersecting against
    // the inner box instead of the outer box.
    vec4 opaque_dist =
        mix(vEdge, vEdge.zwxy, lessThan(uv_linear_step, vec2(0.0)).xyxy)
            - uv_linear0.xyxy;
    opaque_dist =
        mix(1.0e6 * step(0.0, opaque_dist),
            opaque_dist * recip(uv_linear_step).xyxy,
            notEqual(uv_linear_step, vec2(0.0)).xyxy);

    // Unlike for the shadow clipping bounds, here we need to rather find the floor of all
    // the offsets so that we don't accidentally process any chunks in the transitional areas
    // between sectors of the nine-patch.
    ivec4 opaque_steps = ivec4(clamp(
        swgl_SpanLength -
            swgl_StepSize *
                vec4(floor(opaque_dist.x), floor(opaque_dist.y), floor(opaque_dist.z), floor(opaque_dist.w)),
        shadow_end_len, swgl_SpanLength));

    // Fill any initial sections of the span that are clipped out based on clip mode.
    if (swgl_SpanLength > shadow_start_len) {
        int num_before = swgl_SpanLength - shadow_start_len;
        swgl_commitPartialSolidR8(num_before, vClipMode.x);
        float steps_before = float(num_before / swgl_StepSize);
        uv_linear += steps_before * uv_linear_step;
        local_pos += steps_before * local_step;
    }

    // This loop tries to repeatedly process entire spans of the nine-patch that map
    // to a contiguous spans of texture in the source box shadow. First, we process
    // a chunk with per-fragment clipping and mapping in case we're starting on a
    // transitional region between sectors of the nine-patch which may need to map
    // to different spans of texture per-fragment. After, we find the largest span
    // within the current sector before we hit the next transitional region, and
    // attempt to commit an entire span of texture therein.
    while (swgl_SpanLength > 0) {
        // Here we might be in a transitional chunk, so do everything per-fragment.
        {
            vec2 uv = clamp(uv_linear, vec2(0.0), vEdge.xy);
            uv += max(vec2(0.0), uv_linear - vEdge.zw);
            uv = mix(vUvBounds_NoClamp.xy, vUvBounds_NoClamp.zw, uv);
            uv = clamp(uv, vUvBounds.xy, vUvBounds.zw);

            float in_shadow_rect = init_transform_rough_fs(local_pos);

            float texel = TEX_SAMPLE(sColor0, uv).r;

            float alpha = mix(texel, 1.0 - texel, vClipMode.x);
            float result = mix(vClipMode.x, alpha, in_shadow_rect);
            swgl_commitColorR8(result);

            uv_linear += uv_linear_step;
            local_pos += local_step;
        }
        // If we now hit the end of the clip bounds, just bail out since there is
        // no more shadow to map.
        if (swgl_SpanLength <= shadow_end_len) {
            break;
        }
        // By here we've determined to be still inside the nine-patch. We need to
        // compare against the inner rectangle thresholds to see which sector of
        // the nine-patch to use and thus how to map the box shadow texture. Stop
        // at least one step before the end of the shadow region to properly clip
        // on the boundary.
        int num_inside = swgl_SpanLength - swgl_StepSize - shadow_end_len;
        vec4 uv_bounds = vUvBounds;
        if (swgl_SpanLength >= opaque_steps.y) {
            // We're in the top Y band of the nine-patch.
            num_inside = min(num_inside, swgl_SpanLength - opaque_steps.y);
        } else if (swgl_SpanLength >= opaque_steps.w) {
            // We're in the middle Y band of the nine-patch. Set the UV clamp bounds
            // to the vertical center texel of the box shadow.
            num_inside = min(num_inside, swgl_SpanLength - opaque_steps.w);
            uv_bounds.yw = vec2(clamp(mix(vUvBounds_NoClamp.y, vUvBounds_NoClamp.w, vEdge.y),
                                      vUvBounds.y, vUvBounds.w));
        }
        if (swgl_SpanLength >= opaque_steps.x) {
            // We're in the left X column of the nine-patch.
            num_inside = min(num_inside, swgl_SpanLength - opaque_steps.x);
        } else if (swgl_SpanLength >= opaque_steps.z) {
            // We're in the middle X band of the nine-patch. Set the UV clamp bounds
            // to the horizontal center texel of the box shadow.
            num_inside = min(num_inside, swgl_SpanLength - opaque_steps.z);
            uv_bounds.xz = vec2(clamp(mix(vUvBounds_NoClamp.x, vUvBounds_NoClamp.z, vEdge.x),
                                      vUvBounds.x, vUvBounds.z));
        }
        if (num_inside > 0) {
            // We have a non-zero span of fragments within the sector. Map to the UV
            // start offset of the sector and the UV offset within the sector.
            vec2 uv = clamp(uv_linear, vec2(0.0), vEdge.xy);
            uv += max(vec2(0.0), uv_linear - vEdge.zw);
            uv = mix(vUvBounds_NoClamp.xy, vUvBounds_NoClamp.zw, uv);
            // If we're in the center sector of the nine-patch, then we only need to
            // sample from a single texel of the box shadow. Just sample that single
            // texel once and output it for the entire span. Otherwise, we just need
            // to commit an actual span of texture from the box shadow. Depending on
            // if we are in clip-out mode, we may need to invert the source texture.
            if (uv_bounds.xy == uv_bounds.zw) {
                uv = clamp(uv, uv_bounds.xy, uv_bounds.zw);
                float texel = TEX_SAMPLE(sColor0, uv).r;
                float alpha = mix(texel, 1.0 - texel, vClipMode.x);
                swgl_commitPartialSolidR8(num_inside, alpha);
            } else if (vClipMode.x != 0.0) {
                swgl_commitPartialTextureLinearInvertR8(num_inside, sColor0, uv, uv_bounds);
            } else {
                swgl_commitPartialTextureLinearR8(num_inside, sColor0, uv, uv_bounds);
            }
            float steps_inside = float(num_inside / swgl_StepSize);
            uv_linear += steps_inside * uv_linear_step;
            local_pos += steps_inside * local_step;
        }
        // By here we're probably in a transitional chunk of the nine-patch that
        // requires per-fragment processing, so loop around again to the handler
        // for that case.
    }

    // Fill any remaining sections of the span that are clipped out.
    if (swgl_SpanLength > 0) {
        swgl_commitPartialSolidR8(swgl_SpanLength, vClipMode.x);
    }
}
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared,clip_shared

varying vec2 vLocalPos;
varying vec2 vClipMaskImageUv;

flat varying vec4 vClipMaskUvInnerRect;

#ifdef WR_VERTEX_SHADER

PER_INSTANCE in vec4 aClipTileRect;
PER_INSTANCE in ivec2 aClipDataResourceAddress;
PER_INSTANCE in vec4 aClipLocalRect;

struct ClipMaskInstanceImage {
    ClipMaskInstanceCommon base;
    RectWithEndpoint tile_rect;
    ivec2 resource_address;
    RectWithEndpoint local_rect;
};

ClipMaskInstanceImage fetch_clip_item() {
    ClipMaskInstanceImage cmi;

    cmi.base = fetch_clip_item_common();

    cmi.tile_rect = RectWithEndpoint(aClipTileRect.xy, aClipTileRect.zw);
    cmi.resource_address = aClipDataResourceAddress;
    cmi.local_rect = RectWithEndpoint(aClipLocalRect.xy, aClipLocalRect.zw);

    return cmi;
}

struct ClipImageVertexInfo {
    vec2 local_pos;
    vec4 world_pos;
};

// This differs from write_clip_tile_vertex in that we forward transform the
// primitive's local-space tile rect into the target space. We use scissoring
// to ensure that the primitive does not draw outside the target bounds.
ClipImageVertexInfo write_clip_image_vertex(RectWithEndpoint tile_rect,
                                            RectWithEndpoint local_clip_rect,
                                            Transform prim_transform,
                                            Transform clip_transform,
                                            RectWithEndpoint sub_rect,
                                            vec2 task_origin,
                                            vec2 screen_origin,
                                            float device_pixel_scale) {
    vec2 local_pos = rect_clamp(local_clip_rect, mix(tile_rect.p0, tile_rect.p1, aPosition.xy));
    vec4 world_pos = prim_transform.m * vec4(local_pos, 0.0, 1.0);
    vec4 final_pos = vec4(
        world_pos.xy * device_pixel_scale + (task_origin - screen_origin) * world_pos.w,
        0.0,
        world_pos.w
    );
    gl_Position = uTransform * final_pos;

    init_transform_vs(
        clip_transform.is_axis_aligned
            ? vec4(vec2(-1.0e16), vec2(1.0e16))
            : vec4(local_clip_rect.p0, local_clip_rect.p1));

    ClipImageVertexInfo vi = ClipImageVertexInfo(local_pos, world_pos);
    return vi;
}

void main(void) {
    ClipMaskInstanceImage cmi = fetch_clip_item();
    Transform clip_transform = fetch_transform(cmi.base.clip_transform_id);
    Transform prim_transform = fetch_transform(cmi.base.prim_transform_id);
    ImageSource res = fetch_image_source_direct(cmi.resource_address);

    ClipImageVertexInfo vi = write_clip_image_vertex(
        cmi.tile_rect,
        cmi.local_rect,
        prim_transform,
        clip_transform,
        cmi.base.sub_rect,
        cmi.base.task_origin,
        cmi.base.screen_origin,
        cmi.base.device_pixel_scale
    );
    vLocalPos = vi.local_pos;
    vec2 uv = (vi.local_pos - cmi.tile_rect.p0) / rect_size(cmi.tile_rect);

    vec2 texture_size = vec2(TEX_SIZE(sColor0));
    vec4 uv_rect = vec4(res.uv_rect.p0, res.uv_rect.p1);
    vClipMaskImageUv = mix(uv_rect.xy, uv_rect.zw, uv) / texture_size;

    // applying a half-texel offset to the UV boundaries to prevent linear samples from the outside
    vClipMaskUvInnerRect = (uv_rect + vec4(0.5, 0.5, -0.5, -0.5)) / texture_size.xyxy;
}
#endif

#ifdef WR_FRAGMENT_SHADER
void main(void) {
    float alpha = init_transform_rough_fs(vLocalPos);
    vec2 source_uv = clamp(vClipMaskImageUv, vClipMaskUvInnerRect.xy, vClipMaskUvInnerRect.zw);
    float clip_alpha = texture(sColor0, source_uv).r; //careful: texture has type A8
    oFragColor = vec4(mix(1.0, clip_alpha, alpha), 0.0, 0.0, 1.0);
}

#ifdef SWGL_DRAW_SPAN
void swgl_drawSpanR8() {
    if (has_valid_transform_bounds()) {
        return;
    }

    swgl_commitTextureLinearR8(sColor0, vClipMaskImageUv, vClipMaskUvInnerRect);
}
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared,clip_shared,ellipse

varying vec4 vLocalPos;
#ifdef WR_FEATURE_FAST_PATH
flat varying vec3 vClipParams;      // xy = box size, z = radius
#else
flat varying vec4 vClipCenter_Radius_TL;
flat varying vec4 vClipCenter_Radius_TR;
flat varying vec4 vClipCenter_Radius_BL;
flat varying vec4 vClipCenter_Radius_BR;
    #ifdef SWGL_DRAW_SPAN
        flat varying vec4 vClipCorner_TL;
        flat varying vec4 vClipCorner_TR;
        flat varying vec4 vClipCorner_BL;
        flat varying vec4 vClipCorner_BR;
    #endif
#endif
// Clip mode. Packed in to a vector to work around bug 1630356.
flat varying vec2 vClipMode;

#ifdef WR_VERTEX_SHADER

PER_INSTANCE in vec2 aClipLocalPos;
PER_INSTANCE in vec4 aClipLocalRect;
PER_INSTANCE in float aClipMode;
PER_INSTANCE in vec4 aClipRect_TL;
PER_INSTANCE in vec4 aClipRadii_TL;
PER_INSTANCE in vec4 aClipRect_TR;
PER_INSTANCE in vec4 aClipRadii_TR;
PER_INSTANCE in vec4 aClipRect_BL;
PER_INSTANCE in vec4 aClipRadii_BL;
PER_INSTANCE in vec4 aClipRect_BR;
PER_INSTANCE in vec4 aClipRadii_BR;

struct ClipMaskInstanceRect {
    ClipMaskInstanceCommon base;
    vec2 local_pos;
};

ClipMaskInstanceRect fetch_clip_item() {
    ClipMaskInstanceRect cmi;

    cmi.base = fetch_clip_item_common();
    cmi.local_pos = aClipLocalPos;

    return cmi;
}

struct ClipRect {
    RectWithEndpoint rect;
    float mode;
};

struct ClipCorner {
    RectWithEndpoint rect;
    vec4 outer_inner_radius;
};

struct ClipData {
    ClipRect rect;
    ClipCorner top_left;
    ClipCorner top_right;
    ClipCorner bottom_left;
    ClipCorner bottom_right;
};

ClipData fetch_clip() {
    ClipData clip;

    clip.rect = ClipRect(RectWithEndpoint(aClipLocalRect.xy, aClipLocalRect.zw), aClipMode);
    clip.top_left = ClipCorner(RectWithEndpoint(aClipRect_TL.xy, aClipRect_TL.zw), aClipRadii_TL);
    clip.top_right = ClipCorner(RectWithEndpoint(aClipRect_TR.xy, aClipRect_TR.zw), aClipRadii_TR);
    clip.bottom_left = ClipCorner(RectWithEndpoint(aClipRect_BL.xy, aClipRect_BL.zw), aClipRadii_BL);
    clip.bottom_right = ClipCorner(RectWithEndpoint(aClipRect_BR.xy, aClipRect_BR.zw), aClipRadii_BR);

    return clip;
}

void main(void) {
    ClipMaskInstanceRect cmi = fetch_clip_item();
    Transform clip_transform = fetch_transform(cmi.base.clip_transform_id);
    Transform prim_transform = fetch_transform(cmi.base.prim_transform_id);
    ClipData clip = fetch_clip();

    RectWithEndpoint local_rect = clip.rect.rect;
    vec2 diff = cmi.local_pos - local_rect.p0;
    local_rect.p0 = cmi.local_pos;
    local_rect.p1 += diff;

    ClipVertexInfo vi = write_clip_tile_vertex(
        local_rect,
        prim_transform,
        clip_transform,
        cmi.base.sub_rect,
        cmi.base.task_origin,
        cmi.base.screen_origin,
        cmi.base.device_pixel_scale
    );

    vClipMode.x = clip.rect.mode;
    vLocalPos = vi.local_pos;

#ifdef WR_FEATURE_FAST_PATH
    // If the radii are all uniform, we can use a much simpler 2d
    // signed distance function to get a rounded rect clip.
    vec2 half_size = 0.5 * rect_size(local_rect);
    float radius = clip.top_left.outer_inner_radius.x;
    vLocalPos.xy -= (half_size + cmi.local_pos) * vi.local_pos.w;
    vClipParams = vec3(half_size - vec2(radius), radius);
#else
    RectWithEndpoint clip_rect = local_rect;

    vec2 r_tl = clip.top_left.outer_inner_radius.xy;
    vec2 r_tr = clip.top_right.outer_inner_radius.xy;
    vec2 r_br = clip.bottom_right.outer_inner_radius.xy;
    vec2 r_bl = clip.bottom_left.outer_inner_radius.xy;

    vClipCenter_Radius_TL = vec4(clip_rect.p0 + r_tl,
                                 inverse_radii_squared(r_tl));

    vClipCenter_Radius_TR = vec4(clip_rect.p1.x - r_tr.x,
                                 clip_rect.p0.y + r_tr.y,
                                 inverse_radii_squared(r_tr));

    vClipCenter_Radius_BR = vec4(clip_rect.p1 - r_br,
                                 inverse_radii_squared(r_br));

    vClipCenter_Radius_BL = vec4(clip_rect.p0.x + r_bl.x,
                                 clip_rect.p1.y - r_bl.y,
                                 inverse_radii_squared(r_bl));

    #ifdef SWGL_DRAW_SPAN
        // For the half-space span shader, we need to know the half-spaces of
        // the corners separate from the center and radius. We compute a point
        // that falls on the diagonal (which is just an inner vertex pushed out
        // along one axis, but not on both). We also compute the direction of
        // the half-space, which is a perpendicular vertex (-y,x) of the vector
        // of the diagonal. We leave the scales of the vectors unchanged.
        vClipCorner_TL = vec4(clip_rect.p0.x,
                              clip_rect.p0.y + r_tl.y,
                              -r_tl.yx);
        vClipCorner_TR = vec4(clip_rect.p1.x - r_tr.x,
                              clip_rect.p0.y,
                              vec2(r_tr.y, -r_tr.x));
        vClipCorner_BR = vec4(clip_rect.p1.x,
                              clip_rect.p1.y - r_br.y,
                              r_br.yx);
        vClipCorner_BL = vec4(clip_rect.p0.x + r_bl.x,
                              clip_rect.p1.y,
                              vec2(-r_bl.y, r_bl.x));
    #endif
#endif
}
#endif

#ifdef WR_FRAGMENT_SHADER

#ifdef WR_FEATURE_FAST_PATH
// See http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
float sd_box(in vec2 pos, in vec2 box_size) {
    vec2 d = abs(pos) - box_size;
    return length(max(d, vec2(0.0))) + min(max(d.x,d.y), 0.0);
}

float sd_rounded_box(in vec2 pos, in vec2 box_size, in float radius) {
    return sd_box(pos, box_size) - radius;
}
#endif

void main(void) {
    vec2 local_pos = vLocalPos.xy / vLocalPos.w;
    float aa_range = compute_aa_range(local_pos);

#ifdef WR_FEATURE_FAST_PATH
    float dist = sd_rounded_box(local_pos, vClipParams.xy, vClipParams.z);
#else
    float dist = distance_to_rounded_rect(
        local_pos,
        vClipCenter_Radius_TL,
        vClipCenter_Radius_TR,
        vClipCenter_Radius_BR,
        vClipCenter_Radius_BL,
        vTransformBounds
    );
#endif

    // Compute AA for the given dist and range.
    float alpha = distance_aa(aa_range, dist);

    // Select alpha or inverse alpha depending on clip in/out.
    float final_alpha = mix(alpha, 1.0 - alpha, vClipMode.x);

    float final_final_alpha = vLocalPos.w > 0.0 ? final_alpha : 0.0;
    oFragColor = vec4(final_final_alpha, 0.0, 0.0, 1.0);
}

#ifdef SWGL_DRAW_SPAN
// Currently the cs_clip_rectangle shader is slow because it always evaluates
// the corner ellipse segments and the rectangle AA for every fragment the
// shader is run on. To alleviate this for now with SWGL, this essentially
// implements a rounded-rectangle span rasterizer inside the span shader. The
// motivation is that we can separate out the parts of the span which are fully
// opaque and fully transparent, outputting runs of fixed color in those areas,
// while only evaluating the ellipse segments and AA in the smaller outlying
// parts of the span that actually need it.
// The shader conceptually represents a rounded rectangle as an inner octagon
// (8 half-spaces) bounding the opaque region and an outer octagon bounding the
// curve and AA parts. Everything outside is transparent. The line of the span
// is intersected with half-spaces, looking for interior spans that minimally
// intersect the half-spaces (start max, end min). In the ideal case we hit a
// start corner ellipse segment and an end corner ellipse segment, rendering
// the two curves on the ends with an opaque run in between, outputting clear
// for any transparent runs before and after the start and end curves.
// This is slightly complicated by the fact that the results here must agree
// with the main results of the fragment shader, in case SWGL has to fall back
// to the main fragment shader for any reason. So, we make an effort to handle
// both ways of operating - the uniform radius fast-path and the varying radius
// slow-path.
void swgl_drawSpanR8() {
    // If the span is completely outside the Z-range and clipped out, just
    // output clear so we don't need to consider invalid W in the rest of the
    // shader.
    float w = swgl_forceScalar(vLocalPos.w);
    if (w <= 0.0) {
        swgl_commitSolidR8(0.0);
        return;
    }

    // To start, we evaluate the rounded-rectangle in local space relative to
    // the local-space position. This will be interpolated across the span to
    // track whether we intersect any half-spaces.
    w = 1.0 / w;
    vec2 local_pos = vLocalPos.xy * w;
    vec2 local_pos0 = swgl_forceScalar(local_pos);
    vec2 local_step = swgl_interpStep(vLocalPos).xy * w;
    float step_scale = max(dot(local_step, local_step), 1.0e-6);

    // Get the local-space AA range. This range represents 1/fwidth(local_pos),
    // essentially the scale of how much local-space maps to an AA pixel. We
    // need to know the inverse, how much local-space we traverse per AA pixel
    // pixel step. We then scale this to represent the amount of span steps
    // traversed per AA pixel step.
    float aa_range = compute_aa_range(local_pos);
    float aa_margin = inversesqrt(aa_range * aa_range * step_scale);

    // We need to know the bounds of the aligned rectangle portion of the rrect
    // in local-space. If we're using the fast-path, this is specified as the
    // inner bounding-box half-width of the rrect and the uniform outer radius
    // of the corners in vClipParams, which we map to the outer bounding-box.
    // For the general case, we have already stored the outer bounding box in
    // vTransformBounds.
    #ifdef WR_FEATURE_FAST_PATH
        vec4 clip_rect = vec4(-vClipParams.xy - vClipParams.z, vClipParams.xy + vClipParams.z);
    #else
        vec4 clip_rect = vTransformBounds;
    #endif

    // We need to compute the local-space distance to the bounding box and then
    // figure out how many processing steps that maps to. If we are stepping in
    // a negative direction on an axis, we need to swap the sides of the box
    // which we consider as the start or end. If there is no local-space step
    // on an axis (i.e. constant Y), we need to take care to force the steps to
    // either the start or end of the span depending on if we are inside or
    // outside of the bounding box.
    vec4 clip_dist =
        mix(clip_rect, clip_rect.zwxy, lessThan(local_step, vec2(0.0)).xyxy)
            - local_pos0.xyxy;
    clip_dist =
        mix(1.0e6 * step(0.0, clip_dist),
            clip_dist * recip(local_step).xyxy,
            notEqual(local_step, vec2(0.0)).xyxy);

    // Initially, the opaque region is bounded by the further start intersect
    // with the bounding box and the nearest end intersect with the bounding
    // box.
    float opaque_start = max(clip_dist.x, clip_dist.y);
    float opaque_end = min(clip_dist.z, clip_dist.w);
    float aa_start = opaque_start;
    float aa_end = opaque_end;

    // Here we actually intersect with the half-space of the corner. We get the
    // plane distance of the local-space position from the diagonal bounding
    // ellipse segment from the opaque region. The half-space is defined by the
    // direction vector of the plane and an offset point that falls on the
    // dividing line (which is a vertex on the corner box, which is actually on
    // the outer radius of the bounding box, but not a corner vertex). This
    // distance is positive if on the curve side and negative if on the inner
    // opaque region. If we are on the curve side, we need to verify we are
    // traveling in direction towards the opaque region so that we will
    // eventually intersect the diagonal so we can calculate when the start
    // corner segment will end, otherwise we are going away from the rrect.
    // If we are inside the opaque interior, we need to verify we are traveling
    // in direction towards the curve, so that we can calculate when the end
    // corner segment will start. Further, if we intersect, we calculate the
    // offset of the outer octagon where AA starts from the inner octagon of
    // where the opaque region starts using the apex vector (which is transpose
    // of the half-space's direction).
    //
    // We need to intersect the corner ellipse segments. Significantly, we need
    // to know where the apex of the ellipse segment is and how far to push the
    // outer diagonal of the octagon from the inner diagonal. The position of
    // the inner diagonal simply runs diagonal across the corner box and has a
    // constant offset from vertex on the inner bounding box. The apex also has
    // a constant offset along the opposite diagonal relative to the diagonal
    // intersect which is 1/sqrt(2) - 0.5 assuming unit length for the diagonal.
    // We then need to project the vector to the apex onto the local-space step
    // scale, but we do this with reference to the normal vector of the diagonal
    // using dot(normal, apex) / dot(normal, local_step), where the apex vector
    // is (0.7071 - 0.5) * abs(normal).yx * sign(normal).
    vec4 start_plane = vec4(1.0e6);
    vec4 end_plane = vec4(1.0e6);

    #define CLIP_CORNER(offset, normal, info) do {                            \
        float dist = dot(local_pos0 - (offset), (normal));                    \
        float scale = -dot(local_step, (normal));                             \
        if (scale >= 0.0) {                                                   \
            if (dist > opaque_start * scale) {                                \
                SET_CORNER(start_corner, info);                               \
                start_plane = vec4(offset, normal);                           \
                float inv_scale = recip(max(scale, 1.0e-6));                  \
                opaque_start = dist * inv_scale;                              \
                float apex = (0.7071 - 0.5) * 2.0 * abs(normal.x * normal.y); \
                aa_start = opaque_start - apex * inv_scale;                   \
            }                                                                 \
        } else if (dist > opaque_end * scale) {                               \
            SET_CORNER(end_corner, info);                                     \
            end_plane = vec4(offset, normal);                                 \
            float inv_scale = recip(min(scale, -1.0e-6));                     \
            opaque_end = dist * inv_scale;                                    \
            float apex = (0.7071 - 0.5) * 2.0 * abs(normal.x * normal.y);     \
            aa_end = opaque_end - apex * inv_scale;                           \
        }                                                                     \
    } while (false)

    #ifdef WR_FEATURE_FAST_PATH
        // For the fast-path, we only have the half-width of the inner bounding
        // box. We need to map this to points that fall on the diagonal of the
        // half-space for each corner. To do this we just need to push out the
        // vertex in the right direction on a single axis, leaving the other
        // unchanged.
        vec2 corner_tl = -vClipParams.xy - vec2(vClipParams.z, 0.0);
        vec2 corner_tr = vec2(vClipParams.x, -vClipParams.y - vClipParams.z);
        vec2 corner_br = vClipParams.xy + vec2(vClipParams.z, 0.0);
        vec2 corner_bl = vec2(-vClipParams.x, vClipParams.y + vClipParams.z);
        // The direction vector of the corner half-space has constant length,
        // but just needs an appropriate direction set.
        vec2 n_tl = -vClipParams.zz;
        vec2 n_tr = vec2(vClipParams.z, -vClipParams.z);
        vec2 n_br = vClipParams.zz;
        vec2 n_bl = vec2(-vClipParams.z, vClipParams.z);

        #define SET_CORNER(corner, info)

        // Clip against the corner half-spaces.
        CLIP_CORNER(corner_tl, n_tl, );
        CLIP_CORNER(corner_tr, n_tr, );
        CLIP_CORNER(corner_br, n_br, );
        CLIP_CORNER(corner_bl, n_bl, );

        // Later we need to calculate distance AA for both corners and the
        // outer bounding rect. For the fast-path, this is all done inside
        // sd_rounded_box.
        #define AA_RECT(local_pos) \
            sd_rounded_box(local_pos, vClipParams.xy, vClipParams.z)
    #else
        // For the general case, we need to remember which of the actual start
        // and end corners we intersect, so that we can evaluate the curve AA
        // against only those corners rather than having to try against all 4
        // corners for both sides of the span. Initialize these values so that
        // if no corner is intersected, they will just zero the AA.
        vec4 start_corner = vec4(vec2(1.0e6), vec2(1.0));
        vec4 end_corner = vec4(vec2(1.0e6), vec2(1.0));

        #define SET_CORNER(corner, info) corner = info

        // Clip against the corner half-spaces. We have already computed the
        // corner half-spaces in the vertex shader.
        CLIP_CORNER(vClipCorner_TL.xy, vClipCorner_TL.zw, vClipCenter_Radius_TL);
        CLIP_CORNER(vClipCorner_TR.xy, vClipCorner_TR.zw, vClipCenter_Radius_TR);
        CLIP_CORNER(vClipCorner_BR.xy, vClipCorner_BR.zw, vClipCenter_Radius_BR);
        CLIP_CORNER(vClipCorner_BL.xy, vClipCorner_BL.zw, vClipCenter_Radius_BL);

        // Later we need to calculate distance AA for both corners and the
        // outer bounding rect. For the general case, we need to explicitly
        // evaluate either the ellipse segment distance or the rect distance.
        #define AA_RECT(local_pos) \
            signed_distance_rect(local_pos, vTransformBounds.xy, vTransformBounds.zw)
        #define AA_CORNER(local_pos, corner) \
            distance_to_ellipse_approx(local_pos - corner.xy, corner.zw, 1.0)
    #endif

    // Pad the AA region by a margin, as the intersections take place assuming
    // pixel centers, but AA actually starts half a pixel away from the center.
    // If the AA region narrows to nothing, be careful not to inflate so much
    // that we start processing AA for fragments that don't need it.
    aa_margin = max(aa_margin - max(aa_start - aa_end, 0.0), 0.0);
    aa_start -= aa_margin;
    aa_end += aa_margin;

    // Compute the thresholds at which we need to transition between various
    // segments of the span, from fully transparent outside to the start of
    // the outer octagon where AA starts, from there to where the inner opaque
    // octagon starts, from there to where the opaque inner octagon ends and
    // AA starts again, to finally where the outer octagon/AA ends and we're
    // back to fully transparent. These thresholds are just flipped offsets
    // from the start of the span so we can compare against the remaining
    // span length which automatically deducts as we commit fragments.
    ivec4 steps = ivec4(clamp(
        swgl_SpanLength -
            swgl_StepSize *
                vec4(floor(aa_start), ceil(opaque_start), floor(opaque_end), ceil(aa_end)),
        0.0, swgl_SpanLength));
    int aa_start_len = steps.x;
    int opaque_start_len = steps.y;
    int opaque_end_len = steps.z;
    int aa_end_len = steps.w;

    // Output fully clear while we're outside the AA region.
    if (swgl_SpanLength > aa_start_len) {
        int num_aa = swgl_SpanLength - aa_start_len;
        swgl_commitPartialSolidR8(num_aa, vClipMode.x);
        local_pos += float(num_aa / swgl_StepSize) * local_step;
    }
    #ifdef AA_CORNER
    if (start_plane.x < 1.0e5) {
        // We're now in the outer octagon which requires AA. Evaluate the corner
        // distance of the start corner here and output AA for it. Before we hit
        // the actual opaque inner octagon, we have a transitional step where the
        // diagonal might intersect mid-way through the step. We have consider
        // either the corner or rect distance depending on which side we're on.
        while (swgl_SpanLength > opaque_start_len) {
            float alpha = distance_aa(aa_range,
                dot(local_pos - start_plane.xy, start_plane.zw) > 0.0
                    ? AA_CORNER(local_pos, start_corner)
                    : AA_RECT(local_pos));
            swgl_commitColorR8(mix(alpha, 1.0 - alpha, vClipMode.x));
            local_pos += local_step;
        }
    }
    #endif
    // If there's no start corner, just do rect AA until opaque.
    while (swgl_SpanLength > opaque_start_len) {
        float alpha = distance_aa(aa_range, AA_RECT(local_pos));
        swgl_commitColorR8(mix(alpha, 1.0 - alpha, vClipMode.x));
        local_pos += local_step;
    }
    // Now we're finally in the opaque inner octagon part of the span. Just
    // output a solid run.
    if (swgl_SpanLength > opaque_end_len) {
        int num_opaque = swgl_SpanLength - opaque_end_len;
        swgl_commitPartialSolidR8(num_opaque, 1.0 - vClipMode.x);
        local_pos += float(num_opaque / swgl_StepSize) * local_step;
    }
    #ifdef AA_CORNER
    if (end_plane.x < 1.0e5) {
        // Finally we're in the AA region on the other side, inside the outer
        // octagon again. Just evaluate the distance to the end corner and
        // compute AA for it. We're leaving the opaque inner octagon, but like
        // before, we have to be careful we're not dealing with a step partially
        // intersected by the end corner's diagonal. Check which side we are on
        // and use either the corner or rect distance as appropriate.
        while (swgl_SpanLength > aa_end_len) {
            float alpha = distance_aa(aa_range,
                dot(local_pos - end_plane.xy, end_plane.zw) > 0.0
                    ? AA_CORNER(local_pos, end_corner)
                    : AA_RECT(local_pos));
            swgl_commitColorR8(mix(alpha, 1.0 - alpha, vClipMode.x));
            local_pos += local_step;
        }
    }
    #endif
    // If there's no end corner, just do rect AA until clear.
    while (swgl_SpanLength > aa_end_len) {
        float alpha = distance_aa(aa_range, AA_RECT(local_pos));
        swgl_commitColorR8(mix(alpha, 1.0 - alpha, vClipMode.x));
        local_pos += local_step;
    }
    // We're now outside the outer AA octagon on the other side. Just output
    // fully clear.
    if (swgl_SpanLength > 0) {
        swgl_commitPartialSolidR8(swgl_SpanLength, vClipMode.x);
    }
}
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared,rect,render_task,gpu_cache,gradient

#define PI                  3.141592653589793

varying vec2 v_pos;

flat varying vec2 v_center;

// x: start offset, y: offset scale, z: angle
// Packed in to a vector to work around bug 1630356.
flat varying vec3 v_start_offset_offset_scale_angle_vec;
#define v_start_offset v_start_offset_offset_scale_angle_vec.x
#define v_offset_scale v_start_offset_offset_scale_angle_vec.y
#define v_angle v_start_offset_offset_scale_angle_vec.z

#ifdef WR_VERTEX_SHADER

#define EXTEND_MODE_REPEAT 1

PER_INSTANCE in vec4 aTaskRect;
PER_INSTANCE in vec2 aCenter;
PER_INSTANCE in vec2 aScale;
PER_INSTANCE in float aStartOffset;
PER_INSTANCE in float aEndOffset;
PER_INSTANCE in float aAngle;
PER_INSTANCE in int aExtendMode;
PER_INSTANCE in int aGradientStopsAddress;

void main(void) {
    // Store 1/d where d = end_offset - start_offset
    // If d = 0, we can't get its reciprocal. Instead, just use a zero scale.
    float d = aEndOffset - aStartOffset;
    v_offset_scale = d != 0.0 ? 1.0 / d : 0.0;

    vec2 pos = mix(aTaskRect.xy, aTaskRect.zw, aPosition.xy);
    gl_Position = uTransform * vec4(pos, 0.0, 1.0);

    v_angle = PI / 2.0 - aAngle;
    v_start_offset = aStartOffset * v_offset_scale;

    // v_pos and v_center are in a coordinate space relative to the task rect
    // (so they are independent of the task origin).
    v_center = aCenter * v_offset_scale;
    v_pos = (aTaskRect.zw - aTaskRect.xy) * aPosition.xy * v_offset_scale * aScale;

    v_gradient_repeat.x = float(aExtendMode == EXTEND_MODE_REPEAT);
    v_gradient_address.x = aGradientStopsAddress;
}
#endif


#ifdef WR_FRAGMENT_SHADER

void main(void) {
    // Use inverse trig to find the angle offset from the relative position.
    vec2 current_dir = v_pos - v_center;
    float current_angle = atan(current_dir.y, current_dir.x) + v_angle;
    float offset = fract(current_angle / (2.0 * PI)) * v_offset_scale - v_start_offset;

    oFragColor = sample_gradient(offset);
}

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared

varying float vPos;
flat varying vec4 vColor0;
flat varying vec4 vColor1;

#ifdef WR_VERTEX_SHADER

PER_INSTANCE in vec4 aTaskRect;
PER_INSTANCE in vec4 aColor0;
PER_INSTANCE in vec4 aColor1;
PER_INSTANCE in float aAxisSelect;

void main(void) {
    vPos = mix(0.0, 1.0, mix(aPosition.x, aPosition.y, aAxisSelect));

    vColor0 = aColor0;
    vColor1 = aColor1;

    gl_Position = uTransform * vec4(mix(aTaskRect.xy, aTaskRect.zw, aPosition.xy), 0.0, 1.0);
}
#endif

#ifdef WR_FRAGMENT_SHADER
void main(void) {
    oFragColor = mix(vColor0, vColor1, vPos);
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared

#define LINE_STYLE_SOLID        0
#define LINE_STYLE_DOTTED       1
#define LINE_STYLE_DASHED       2
#define LINE_STYLE_WAVY         3

// Fragment position in the coordinate system used for positioning decorations.
// To keep the code independent of whether the line is horizontal or vertical,
// vLocalPos.x is always parallel, and .y always perpendicular, to the line
// being decorated.
varying vec2 vLocalPos;

// Line style. Packed in to a vector to work around bug 1630356.
flat varying ivec2 vStyle;

flat varying vec4 vParams;

#ifdef WR_VERTEX_SHADER

// The size of the mask tile we're rendering, in pixels.
PER_INSTANCE in vec4 aTaskRect;

// The size of the mask tile. aLocalSize.x is always horizontal and .y vertical,
// regardless of the line's orientation. The size is chosen by
// prim_store::line_dec::get_line_decoration_sizes.
PER_INSTANCE in vec2 aLocalSize;

// A LINE_STYLE_* value, indicating what sort of line to draw.
PER_INSTANCE in int aStyle;

// 0.0 for a horizontal line, 1.0 for a vertical line.
PER_INSTANCE in float aAxisSelect;

// The thickness of the wavy line itself, not the amplitude of the waves (i.e.,
// the thickness of the final decorated line).
PER_INSTANCE in float aWavyLineThickness;

void main(void) {
    vec2 size = mix(aLocalSize, aLocalSize.yx, aAxisSelect);
    vStyle.x = aStyle;

    switch (vStyle.x) {
        case LINE_STYLE_SOLID: {
            break;
        }
        case LINE_STYLE_DASHED: {
            vParams = vec4(size.x,          // period
                           0.5 * size.x,    // dash length
                           0.0,
                           0.0);
            break;
        }
        case LINE_STYLE_DOTTED: {
            float diameter = size.y;
            float period = diameter * 2.0;
            float center_line = 0.5 * size.y;
            vParams = vec4(period,
                           diameter / 2.0, // radius
                           center_line,
                           0.0);
            break;
        }
        case LINE_STYLE_WAVY: {
            // This logic copied from gecko to get the same results
            float line_thickness = max(aWavyLineThickness, 1.0);
            // Difference in height between peaks and troughs
            // (and since slopes are 45 degrees, the length of each slope)
            float slope_length = size.y - line_thickness;
            // Length of flat runs
            float flat_length = max((line_thickness - 1.0) * 2.0, 1.0);

            vParams = vec4(line_thickness / 2.0,
                           slope_length,
                           flat_length,
                           size.y);
            break;
        }
        default:
            vParams = vec4(0.0);
    }

    vLocalPos = mix(aPosition.xy, aPosition.yx, aAxisSelect) * size;

    gl_Position = uTransform * vec4(mix(aTaskRect.xy, aTaskRect.zw, aPosition.xy), 0.0, 1.0);
}
#endif

#ifdef WR_FRAGMENT_SHADER

#define MAGIC_WAVY_LINE_AA_SNAP         0.5

void main(void) {
    // Find the appropriate distance to apply the step over.
    vec2 pos = vLocalPos;
    float aa_range = compute_aa_range(pos);
    float alpha = 1.0;

    switch (vStyle.x) {
        case LINE_STYLE_SOLID: {
            break;
        }
        case LINE_STYLE_DASHED: {
            // Calculate dash alpha (on/off) based on dash length
            alpha = step(floor(pos.x + 0.5), vParams.y);
            break;
        }
        case LINE_STYLE_DOTTED: {
            // Get the dot alpha
            vec2 dot_relative_pos = pos - vParams.yz;
            float dot_distance = length(dot_relative_pos) - vParams.y;
            alpha = distance_aa(aa_range, dot_distance);
            break;
        }
        case LINE_STYLE_WAVY: {
            float half_line_thickness = vParams.x;
            float slope_length = vParams.y;
            float flat_length = vParams.z;
            float vertical_bounds = vParams.w;
            // Our pattern is just two slopes and two flats
            float half_period = slope_length + flat_length;

            float mid_height = vertical_bounds / 2.0;
            float peak_offset = mid_height - half_line_thickness;
            // Flip the wave every half period
            float flip = -2.0 * (step(mod(pos.x, 2.0 * half_period), half_period) - 0.5);
            // float flip = -1.0;
            peak_offset *= flip;
            float peak_height = mid_height + peak_offset;

            // Convert pos to a local position within one half period
            pos.x = mod(pos.x, half_period);

            // Compute signed distance to the 3 lines that make up an arc
            float dist1 = distance_to_line(vec2(0.0, peak_height),
                                           vec2(1.0, -flip),
                                           pos);
            float dist2 = distance_to_line(vec2(0.0, peak_height),
                                           vec2(0, -flip),
                                           pos);
            float dist3 = distance_to_line(vec2(flat_length, peak_height),
                                           vec2(-1.0, -flip),
                                           pos);
            float dist = abs(max(max(dist1, dist2), dist3));

            // Apply AA based on the thickness of the wave
            alpha = distance_aa(aa_range, dist - half_line_thickness);

            // Disable AA for thin lines
            if (half_line_thickness <= 1.0) {
                alpha = 1.0 - step(alpha, MAGIC_WAVY_LINE_AA_SNAP);
            }

            break;
        }
        default: break;
    }

    oFragColor = vec4(alpha);
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared,rect,render_task,gpu_cache,gradient

varying vec2 v_pos;

flat varying vec2 v_scale_dir;

// Start offset. Packed in to a vector to work around bug 1630356.
flat varying vec2 v_start_offset;

#ifdef WR_VERTEX_SHADER

#define EXTEND_MODE_REPEAT 1

PER_INSTANCE in vec4 aTaskRect;
PER_INSTANCE in vec2 aStartPoint;
PER_INSTANCE in vec2 aEndPoint;
PER_INSTANCE in vec2 aScale;
PER_INSTANCE in int aExtendMode;
PER_INSTANCE in int aGradientStopsAddress;

void main(void) {
    vec2 pos = mix(aTaskRect.xy, aTaskRect.zw, aPosition.xy);
    gl_Position = uTransform * vec4(pos, 0.0, 1.0);

    v_pos = aPosition.xy * aScale;

    vec2 dir = aEndPoint - aStartPoint;

    // Normalize UV and offsets to 0..1 scale.
    v_scale_dir = dir / dot(dir, dir);
    v_start_offset.x = dot(aStartPoint, v_scale_dir);

    v_scale_dir *= (aTaskRect.zw - aTaskRect.xy);

    v_gradient_repeat.x = float(aExtendMode == EXTEND_MODE_REPEAT);
    v_gradient_address.x = aGradientStopsAddress;
}
#endif


#ifdef WR_FRAGMENT_SHADER

void main(void) {
    // Project position onto a direction vector to compute offset.
    float offset = dot(v_pos, v_scale_dir) - v_start_offset.x;

    oFragColor = sample_gradient(offset);
}


#ifdef SWGL_DRAW_SPAN
void swgl_drawSpanRGBA8() {
    int address = swgl_validateGradient(sGpuCache, get_gpu_cache_uv(v_gradient_address.x), int(GRADIENT_ENTRIES + 2.0));
    if (address < 0) {
        return;
    }

    float offset = dot(v_pos, v_scale_dir) - v_start_offset.x;
    swgl_commitLinearGradientRGBA8(sGpuCache, address, GRADIENT_ENTRIES, v_gradient_repeat.x != 0.0,
                                   offset);
}
#endif


#endif
542367c87db5169/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared,rect,render_task,gpu_cache,gradient

varying vec2 v_pos;

// Start radius. Packed in to a vector to work around bug 1630356.
flat varying vec2 v_start_radius;

#ifdef WR_VERTEX_SHADER

#define EXTEND_MODE_REPEAT 1

PER_INSTANCE in vec4 aTaskRect;
PER_INSTANCE in vec2 aCenter;
PER_INSTANCE in vec2 aScale;
PER_INSTANCE in float aStartRadius;
PER_INSTANCE in float aEndRadius;
PER_INSTANCE in float aXYRatio;
PER_INSTANCE in int aExtendMode;
PER_INSTANCE in int aGradientStopsAddress;

void main(void) {
    // Store 1/rd where rd = end_radius - start_radius
    // If rd = 0, we can't get its reciprocal. Instead, just use a zero scale.
    float rd = aEndRadius - aStartRadius;
    float radius_scale = rd != 0.0 ? 1.0 / rd : 0.0;

    vec2 pos = mix(aTaskRect.xy, aTaskRect.zw, aPosition.xy);
    gl_Position = uTransform * vec4(pos, 0.0, 1.0);

    v_start_radius.x = aStartRadius * radius_scale;

    // Transform all coordinates by the y scale so the
    // fragment shader can work with circles

    // v_pos is in a coordinate space relative to the task rect
    // (so it is independent of the task origin).
    v_pos = ((aTaskRect.zw - aTaskRect.xy) * aPosition.xy * aScale - aCenter) * radius_scale;
    v_pos.y *= aXYRatio;

    v_gradient_repeat.x = float(aExtendMode == EXTEND_MODE_REPEAT);
    v_gradient_address.x = aGradientStopsAddress;
}
#endif


#ifdef WR_FRAGMENT_SHADER

void main(void) {
    // Solve for t in length(pd) = v_start_radius + t * rd
    float offset = length(v_pos) - v_start_radius.x;

    oFragColor = sample_gradient(offset);
}

#ifdef SWGL_DRAW_SPAN
void swgl_drawSpanRGBA8() {
    int address = swgl_validateGradient(sGpuCache, get_gpu_cache_uv(v_gradient_address.x),
                                        int(GRADIENT_ENTRIES + 2.0));
    if (address < 0) {
        return;
    }
    swgl_commitRadialGradientRGBA8(sGpuCache, address, GRADIENT_ENTRIES, v_gradient_repeat.x != 0.0,
                                   v_pos, v_start_radius.x);
}
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// This shader must remain compatible with ESSL 1, at least for the
// WR_FEATURE_TEXTURE_EXTERNAL_ESSL1 feature, so that it can be used to render
// video on GLES devices without GL_OES_EGL_image_external_essl3 support.
// This means we cannot use textureSize(), int inputs/outputs, etc.

#include shared

varying vec2 vUv;
flat varying vec4 vUvRect;
#ifdef WR_FEATURE_TEXTURE_EXTERNAL_ESSL1
uniform vec2 uTextureSize;
#endif

#ifdef WR_VERTEX_SHADER

PER_INSTANCE attribute vec4 aScaleTargetRect;
PER_INSTANCE attribute vec4 aScaleSourceRect;

void main(void) {
    vec2 src_offset = aScaleSourceRect.xy;
    vec2 src_size = aScaleSourceRect.zw - aScaleSourceRect.xy;

    // If this is in WR_FEATURE_TEXTURE_RECT mode, the rect and size use
    // non-normalized texture coordinates.
#ifdef WR_FEATURE_TEXTURE_RECT
    vec2 texture_size = vec2(1, 1);
#elif defined(WR_FEATURE_TEXTURE_EXTERNAL_ESSL1)
    vec2 texture_size = uTextureSize;
#else
    vec2 texture_size = vec2(TEX_SIZE(sColor0));
#endif

    vUvRect = vec4(src_offset + vec2(0.5),
                   src_offset + src_size - vec2(0.5)) / texture_size.xyxy;

    vec2 pos = mix(aScaleTargetRect.xy, aScaleTargetRect.zw, aPosition.xy);
    vUv = (src_offset + src_size * aPosition.xy) / texture_size;

    gl_Position = uTransform * vec4(pos, 0.0, 1.0);
}

#endif

#ifdef WR_FRAGMENT_SHADER

void main(void) {
    vec2 st = clamp(vUv, vUvRect.xy, vUvRect.zw);
    oFragColor = TEX_SAMPLE(sColor0, st);
}

#ifdef SWGL_DRAW_SPAN
void swgl_drawSpanRGBA8() {
    swgl_commitTextureLinearRGBA8(sColor0, vUv, vUvRect);
}
#endif

#endif
211b392d8944e7/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define WR_FEATURE_TEXTURE_2D

#include shared,prim_shared

varying vec2 vInput1Uv;
varying vec2 vInput2Uv;
flat varying vec4 vInput1UvRect;
flat varying vec4 vInput2UvRect;
flat varying ivec4 vData;
flat varying vec4 vFilterData0;
flat varying vec4 vFilterData1;

// x: Filter input count, y: Filter kind.
// Packed in to a vector to work around bug 1630356.
flat varying ivec2 vFilterInputCountFilterKindVec;
#define vFilterInputCount vFilterInputCountFilterKindVec.x
#define vFilterKind vFilterInputCountFilterKindVec.y
// Packed in to a vector to work around bug 1630356.
flat varying vec2 vFloat0;

flat varying mat4 vColorMat;
flat varying ivec4 vFuncs;

#define FILTER_BLEND                0
#define FILTER_FLOOD                1
#define FILTER_LINEAR_TO_SRGB       2
#define FILTER_SRGB_TO_LINEAR       3
#define FILTER_OPACITY              4
#define FILTER_COLOR_MATRIX         5
#define FILTER_DROP_SHADOW          6
#define FILTER_OFFSET               7
#define FILTER_COMPONENT_TRANSFER   8
#define FILTER_IDENTITY             9
#define FILTER_COMPOSITE            10

#define COMPOSITE_OVER       0
#define COMPOSITE_IN         1
#define COMPOSITE_OUT        2
#define COMPOSITE_ATOP       3
#define COMPOSITE_XOR        4
#define COMPOSITE_LIGHTER    5
#define COMPOSITE_ARITHMETIC 6

#ifdef WR_VERTEX_SHADER

PER_INSTANCE in int aFilterRenderTaskAddress;
PER_INSTANCE in int aFilterInput1TaskAddress;
PER_INSTANCE in int aFilterInput2TaskAddress;
PER_INSTANCE in int aFilterKind;
PER_INSTANCE in int aFilterInputCount;
PER_INSTANCE in int aFilterGenericInt;
PER_INSTANCE in ivec2 aFilterExtraDataAddress;

struct FilterTask {
    RectWithEndpoint task_rect;
    vec3 user_data;
};

FilterTask fetch_filter_task(int address) {
    RenderTaskData task_data = fetch_render_task_data(address);

    FilterTask task = FilterTask(
        task_data.task_rect,
        task_data.user_data.xyz
    );

    return task;
}

vec4 compute_uv_rect(RectWithEndpoint task_rect, vec2 texture_size) {
    vec4 uvRect = vec4(task_rect.p0 + vec2(0.5),
                       task_rect.p1 - vec2(0.5));
    uvRect /= texture_size.xyxy;
    return uvRect;
}

vec2 compute_uv(RectWithEndpoint task_rect, vec2 texture_size) {
    vec2 uv0 = task_rect.p0 / texture_size;
    vec2 uv1 = floor(task_rect.p1) / texture_size;
    return mix(uv0, uv1, aPosition.xy);
}

void main(void) {
    FilterTask filter_task = fetch_filter_task(aFilterRenderTaskAddress);
    RectWithEndpoint target_rect = filter_task.task_rect;

    vec2 pos = mix(target_rect.p0, target_rect.p1, aPosition.xy);

    RectWithEndpoint input_1_task;
    if (aFilterInputCount > 0) {
        vec2 texture_size = vec2(TEX_SIZE(sColor0).xy);
        input_1_task = fetch_render_task_rect(aFilterInput1TaskAddress);
        vInput1UvRect = compute_uv_rect(input_1_task, texture_size);
        vInput1Uv = compute_uv(input_1_task, texture_size);
    }

    RectWithEndpoint input_2_task;
    if (aFilterInputCount > 1) {
        vec2 texture_size = vec2(TEX_SIZE(sColor1).xy);
        input_2_task = fetch_render_task_rect(aFilterInput2TaskAddress);
        vInput2UvRect = compute_uv_rect(input_2_task, texture_size);
        vInput2Uv = compute_uv(input_2_task, texture_size);
    }

    vFilterInputCount = aFilterInputCount;
    vFilterKind = aFilterKind;

    // This assignment is only used for component transfer filters but this
    // assignment has to be done here and not in the component transfer case
    // below because it doesn't get executed on Windows because of a suspected
    // miscompile of this shader on Windows. See
    // https://github.com/servo/webrender/wiki/Driver-issues#bug-1505871---assignment-to-varying-flat-arrays-inside-switch-statement-of-vertex-shader-suspected-miscompile-on-windows
    // default: just to satisfy angle_shader_validation.rs which needs one
    // default: for every switch, even in comments.
    vFuncs.r = (aFilterGenericInt >> 12) & 0xf; // R
    vFuncs.g = (aFilterGenericInt >> 8)  & 0xf; // G
    vFuncs.b = (aFilterGenericInt >> 4)  & 0xf; // B
    vFuncs.a = (aFilterGenericInt)       & 0xf; // A

    switch (aFilterKind) {
        case FILTER_BLEND:
            vData = ivec4(aFilterGenericInt, 0, 0, 0);
            break;
        case FILTER_FLOOD:
            vFilterData0 = fetch_from_gpu_cache_1_direct(aFilterExtraDataAddress);
            break;
        case FILTER_OPACITY:
            vFloat0.x = filter_task.user_data.x;
            break;
        case FILTER_COLOR_MATRIX:
            vec4 mat_data[4] = fetch_from_gpu_cache_4_direct(aFilterExtraDataAddress);
            vColorMat = mat4(mat_data[0], mat_data[1], mat_data[2], mat_data[3]);
            vFilterData0 = fetch_from_gpu_cache_1_direct(aFilterExtraDataAddress + ivec2(4, 0));
            break;
        case FILTER_DROP_SHADOW:
            vFilterData0 = fetch_from_gpu_cache_1_direct(aFilterExtraDataAddress);
            break;
        case FILTER_OFFSET:
            vec2 texture_size = vec2(TEX_SIZE(sColor0).xy);
            vFilterData0 = vec4(-filter_task.user_data.xy / texture_size, vec2(0.0));

            RectWithEndpoint task_rect = input_1_task;
            vec4 clipRect = vec4(task_rect.p0, task_rect.p1);
            clipRect /= texture_size.xyxy;
            vFilterData1 = clipRect;
            break;
        case FILTER_COMPONENT_TRANSFER:
            vData = ivec4(aFilterExtraDataAddress, 0, 0);
            break;
        case FILTER_COMPOSITE:
            vData = ivec4(aFilterGenericInt, 0, 0, 0);
            if (aFilterGenericInt == COMPOSITE_ARITHMETIC) {
              vFilterData0 = fetch_from_gpu_cache_1_direct(aFilterExtraDataAddress);
            }
            break;
        default:
            break;
    }

    gl_Position = uTransform * vec4(pos, 0.0, 1.0);
}
#endif

#ifdef WR_FRAGMENT_SHADER

#define COMPONENT_TRANSFER_IDENTITY 0
#define COMPONENT_TRANSFER_TABLE 1
#define COMPONENT_TRANSFER_DISCRETE 2
#define COMPONENT_TRANSFER_LINEAR 3
#define COMPONENT_TRANSFER_GAMMA 4

vec3 Multiply(vec3 Cb, vec3 Cs) {
    return Cb * Cs;
}

vec3 Screen(vec3 Cb, vec3 Cs) {
    return Cb + Cs - (Cb * Cs);
}

vec3 HardLight(vec3 Cb, vec3 Cs) {
    vec3 m = Multiply(Cb, 2.0 * Cs);
    vec3 s = Screen(Cb, 2.0 * Cs - 1.0);
    vec3 edge = vec3(0.5, 0.5, 0.5);
    return mix(m, s, step(edge, Cs));
}

// TODO: Worth doing with mix/step? Check GLSL output.
float ColorDodge(float Cb, float Cs) {
    if (Cb == 0.0)
        return 0.0;
    else if (Cs == 1.0)
        return 1.0;
    else
        return min(1.0, Cb / (1.0 - Cs));
}

// TODO: Worth doing with mix/step? Check GLSL output.
float ColorBurn(float Cb, float Cs) {
    if (Cb == 1.0)
        return 1.0;
    else if (Cs == 0.0)
        return 0.0;
    else
        return 1.0 - min(1.0, (1.0 - Cb) / Cs);
}

float SoftLight(float Cb, float Cs) {
    if (Cs <= 0.5) {
        return Cb - (1.0 - 2.0 * Cs) * Cb * (1.0 - Cb);
    } else {
        float D;

        if (Cb <= 0.25)
            D = ((16.0 * Cb - 12.0) * Cb + 4.0) * Cb;
        else
            D = sqrt(Cb);

        return Cb + (2.0 * Cs - 1.0) * (D - Cb);
    }
}

vec3 Difference(vec3 Cb, vec3 Cs) {
    return abs(Cb - Cs);
}

vec3 Exclusion(vec3 Cb, vec3 Cs) {
    return Cb + Cs - 2.0 * Cb * Cs;
}

// These functions below are taken from the spec.
// There's probably a much quicker way to implement
// them in GLSL...
float Sat(vec3 c) {
    return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
}

float Lum(vec3 c) {
    vec3 f = vec3(0.3, 0.59, 0.11);
    return dot(c, f);
}

vec3 ClipColor(vec3 C) {
    float L = Lum(C);
    float n = min(C.r, min(C.g, C.b));
    float x = max(C.r, max(C.g, C.b));

    if (n < 0.0)
        C = L + (((C - L) * L) / (L - n));

    if (x > 1.0)
        C = L + (((C - L) * (1.0 - L)) / (x - L));

    return C;
}

vec3 SetLum(vec3 C, float l) {
    float d = l - Lum(C);
    return ClipColor(C + d);
}

void SetSatInner(inout float Cmin, inout float Cmid, inout float Cmax, float s) {
    if (Cmax > Cmin) {
        Cmid = (((Cmid - Cmin) * s) / (Cmax - Cmin));
        Cmax = s;
    } else {
        Cmid = 0.0;
        Cmax = 0.0;
    }
    Cmin = 0.0;
}

vec3 SetSat(vec3 C, float s) {
    if (C.r <= C.g) {
        if (C.g <= C.b) {
            SetSatInner(C.r, C.g, C.b, s);
        } else {
            if (C.r <= C.b) {
                SetSatInner(C.r, C.b, C.g, s);
            } else {
                SetSatInner(C.b, C.r, C.g, s);
            }
        }
    } else {
        if (C.r <= C.b) {
            SetSatInner(C.g, C.r, C.b, s);
        } else {
            if (C.g <= C.b) {
                SetSatInner(C.g, C.b, C.r, s);
            } else {
                SetSatInner(C.b, C.g, C.r, s);
            }
        }
    }
    return C;
}

vec3 Hue(vec3 Cb, vec3 Cs) {
    return SetLum(SetSat(Cs, Sat(Cb)), Lum(Cb));
}

vec3 Saturation(vec3 Cb, vec3 Cs) {
    return SetLum(SetSat(Cb, Sat(Cs)), Lum(Cb));
}

vec3 Color(vec3 Cb, vec3 Cs) {
    return SetLum(Cs, Lum(Cb));
}

vec3 Luminosity(vec3 Cb, vec3 Cs) {
    return SetLum(Cb, Lum(Cs));
}

const int BlendMode_Normal      = 0;
const int BlendMode_Multiply    = 1;
const int BlendMode_Screen      = 2;
const int BlendMode_Overlay     = 3;
const int BlendMode_Darken      = 4;
const int BlendMode_Lighten     = 5;
const int BlendMode_ColorDodge  = 6;
const int BlendMode_ColorBurn   = 7;
const int BlendMode_HardLight   = 8;
const int BlendMode_SoftLight   = 9;
const int BlendMode_Difference  = 10;
const int BlendMode_Exclusion   = 11;
const int BlendMode_Hue         = 12;
const int BlendMode_Saturation  = 13;
const int BlendMode_Color       = 14;
const int BlendMode_Luminosity  = 15;

vec4 blend(vec4 Cs, vec4 Cb, int mode) {
    vec4 result = vec4(1.0, 0.0, 0.0, 1.0);

    switch (mode) {
        case BlendMode_Normal:
            result.rgb = Cs.rgb;
            break;
        case BlendMode_Multiply:
            result.rgb = Multiply(Cb.rgb, Cs.rgb);
            break;
        case BlendMode_Screen:
            result.rgb = Screen(Cb.rgb, Cs.rgb);
            break;
        case BlendMode_Overlay:
            // Overlay is inverse of Hardlight
            result.rgb = HardLight(Cs.rgb, Cb.rgb);
            break;
        case BlendMode_Darken:
            result.rgb = min(Cs.rgb, Cb.rgb);
            break;
        case BlendMode_Lighten:
            result.rgb = max(Cs.rgb, Cb.rgb);
            break;
        case BlendMode_ColorDodge:
            result.r = ColorDodge(Cb.r, Cs.r);
            result.g = ColorDodge(Cb.g, Cs.g);
            result.b = ColorDodge(Cb.b, Cs.b);
            break;
        case BlendMode_ColorBurn:
            result.r = ColorBurn(Cb.r, Cs.r);
            result.g = ColorBurn(Cb.g, Cs.g);
            result.b = ColorBurn(Cb.b, Cs.b);
            break;
        case BlendMode_HardLight:
            result.rgb = HardLight(Cb.rgb, Cs.rgb);
            break;
        case BlendMode_SoftLight:
            result.r = SoftLight(Cb.r, Cs.r);
            result.g = SoftLight(Cb.g, Cs.g);
            result.b = SoftLight(Cb.b, Cs.b);
            break;
        case BlendMode_Difference:
            result.rgb = Difference(Cb.rgb, Cs.rgb);
            break;
        case BlendMode_Exclusion:
            result.rgb = Exclusion(Cb.rgb, Cs.rgb);
            break;
        case BlendMode_Hue:
            result.rgb = Hue(Cb.rgb, Cs.rgb);
            break;
        case BlendMode_Saturation:
            result.rgb = Saturation(Cb.rgb, Cs.rgb);
            break;
        case BlendMode_Color:
            result.rgb = Color(Cb.rgb, Cs.rgb);
            break;
        case BlendMode_Luminosity:
            result.rgb = Luminosity(Cb.rgb, Cs.rgb);
            break;
        default: break;
    }
    vec3 rgb = (1.0 - Cb.a) * Cs.rgb + Cb.a * result.rgb;
    result = mix(vec4(Cb.rgb * Cb.a, Cb.a), vec4(rgb, 1.0), Cs.a);
    return result;
}

// Based on the Gecko's implementation in
// https://hg.mozilla.org/mozilla-central/file/91b4c3687d75/gfx/src/FilterSupport.cpp#l24
// These could be made faster by sampling a lookup table stored in a float texture
// with linear interpolation.

vec3 SrgbToLinear(vec3 color) {
    vec3 c1 = color / 12.92;
    vec3 c2 = pow(color / 1.055 + vec3(0.055 / 1.055), vec3(2.4));
    return if_then_else(lessThanEqual(color, vec3(0.04045)), c1, c2);
}

vec3 LinearToSrgb(vec3 color) {
    vec3 c1 = color * 12.92;
    vec3 c2 = vec3(1.055) * pow(color, vec3(1.0 / 2.4)) - vec3(0.055);
    return if_then_else(lessThanEqual(color, vec3(0.0031308)), c1, c2);
}

// This function has to be factored out due to the following issue:
// https://github.com/servo/webrender/wiki/Driver-issues#bug-1532245---switch-statement-inside-control-flow-inside-switch-statement-fails-to-compile-on-some-android-phones
// (and now the words "default: default:" so angle_shader_validation.rs passes)
vec4 ComponentTransfer(vec4 colora) {
    // We push a different amount of data to the gpu cache depending on the
    // function type.
    // Identity => 0 blocks
    // Table/Discrete => 64 blocks (256 values)
    // Linear => 1 block (2 values)
    // Gamma => 1 block (3 values)
    // We loop through the color components and increment the offset (for the
    // next color component) into the gpu cache based on how many blocks that
    // function type put into the gpu cache.
    // Table/Discrete use a 256 entry look up table.
    // Linear/Gamma are a simple calculation.
    int offset = 0;
    vec4 texel;
    int k;

    // Dynamically indexing a vector is buggy on some devices, so use a temporary array.
    int[4] funcs = int[4](vFuncs.r, vFuncs.g, vFuncs.b, vFuncs.a);
    for (int i = 0; i < 4; i++) {
        switch (funcs[i]) {
            case COMPONENT_TRANSFER_IDENTITY:
                break;
            case COMPONENT_TRANSFER_TABLE:
            case COMPONENT_TRANSFER_DISCRETE:
                // fetch value from lookup table
                k = int(floor(colora[i]*255.0 + 0.5));
                texel = fetch_from_gpu_cache_1_direct(vData.xy + ivec2(offset + k/4, 0));
                colora[i] = clamp(texel[k % 4], 0.0, 1.0);
                // offset plus 256/4 blocks
                offset = offset + 64;
                break;
            case COMPONENT_TRANSFER_LINEAR:
                // fetch the two values for use in the linear equation
                texel = fetch_from_gpu_cache_1_direct(vData.xy + ivec2(offset, 0));
                colora[i] = clamp(texel[0] * colora[i] + texel[1], 0.0, 1.0);
                // offset plus 1 block
                offset = offset + 1;
                break;
            case COMPONENT_TRANSFER_GAMMA:
                // fetch the three values for use in the gamma equation
                texel = fetch_from_gpu_cache_1_direct(vData.xy + ivec2(offset, 0));
                colora[i] = clamp(texel[0] * pow(colora[i], texel[1]) + texel[2], 0.0, 1.0);
                // offset plus 1 block
                offset = offset + 1;
                break;
            default:
                // shouldn't happen
                break;
        }
    }
    return colora;
}

// Composite Filter

vec4 composite(vec4 Cs, vec4 Cb, int mode) {
    vec4 Cr = vec4(0.0, 1.0, 0.0, 1.0);
    switch (mode) {
        case COMPOSITE_OVER:
            Cr.rgb = Cs.a * Cs.rgb + Cb.a * Cb.rgb * (1.0 - Cs.a);
            Cr.a = Cs.a + Cb.a * (1.0 - Cs.a);
            break;
        case COMPOSITE_IN:
            Cr.rgb = Cs.a * Cs.rgb * Cb.a;
            Cr.a = Cs.a * Cb.a;
            break;
        case COMPOSITE_OUT:
            Cr.rgb = Cs.a * Cs.rgb * (1.0 - Cb.a);
            Cr.a = Cs.a * (1.0 - Cb.a);
            break;
        case COMPOSITE_ATOP:
            Cr.rgb = Cs.a * Cs.rgb * Cb.a + Cb.a * Cb.rgb * (1.0 - Cs.a);
            Cr.a = Cs.a * Cb.a + Cb.a * (1.0 - Cs.a);
            break;
        case COMPOSITE_XOR:
            Cr.rgb = Cs.a * Cs.rgb * (1.0 - Cb.a) + Cb.a * Cb.rgb * (1.0 - Cs.a);
            Cr.a = Cs.a * (1.0 - Cb.a) + Cb.a * (1.0 - Cs.a);
            break;
        case COMPOSITE_LIGHTER:
            Cr.rgb = Cs.a * Cs.rgb + Cb.a * Cb.rgb;
            Cr.a = Cs.a + Cb.a;
            Cr = clamp(Cr, vec4(0.0), vec4(1.0));
            break;
        case COMPOSITE_ARITHMETIC:
            Cr = vec4(vFilterData0.x) * Cs * Cb + vec4(vFilterData0.y) * Cs + vec4(vFilterData0.z) * Cb + vec4(vFilterData0.w);
            Cr = clamp(Cr, vec4(0.0), vec4(1.0));
            break;
        default:
            break;
    }
    return Cr;
}

vec4 sampleInUvRect(sampler2D sampler, vec2 uv, vec4 uvRect) {
    vec2 clamped = clamp(uv.xy, uvRect.xy, uvRect.zw);
    return texture(sampler, clamped);
}

void main(void) {
    vec4 Ca = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 Cb = vec4(0.0, 0.0, 0.0, 0.0);
    if (vFilterInputCount > 0) {
        Ca = sampleInUvRect(sColor0, vInput1Uv, vInput1UvRect);
        if (Ca.a != 0.0) {
            Ca.rgb /= Ca.a;
        }
    }
    if (vFilterInputCount > 1) {
        Cb = sampleInUvRect(sColor1, vInput2Uv, vInput2UvRect);
        if (Cb.a != 0.0) {
            Cb.rgb /= Cb.a;
        }
    }

    vec4 result = vec4(1.0, 0.0, 0.0, 1.0);

    bool needsPremul = true;

    switch (vFilterKind) {
        case FILTER_BLEND:
            result = blend(Ca, Cb, vData.x);
            needsPremul = false;
            break;
        case FILTER_FLOOD:
            result = vFilterData0;
            needsPremul = false;
            break;
        case FILTER_LINEAR_TO_SRGB:
            result.rgb = LinearToSrgb(Ca.rgb);
            result.a = Ca.a;
            break;
        case FILTER_SRGB_TO_LINEAR:
            result.rgb = SrgbToLinear(Ca.rgb);
            result.a = Ca.a;
            break;
        case FILTER_OPACITY:
            result.rgb = Ca.rgb;
            result.a = Ca.a * vFloat0.x;
            break;
        case FILTER_COLOR_MATRIX:
            result = vColorMat * Ca + vFilterData0;
            result = clamp(result, vec4(0.0), vec4(1.0));
            break;
        case FILTER_DROP_SHADOW:
            vec4 shadow = vec4(vFilterData0.rgb, Cb.a * vFilterData0.a);
            // Normal blend + source-over coposite
            result = blend(Ca, shadow, BlendMode_Normal);
            needsPremul = false;
            break;
        case FILTER_OFFSET:
            vec2 offsetUv = vInput1Uv + vFilterData0.xy;
            result = sampleInUvRect(sColor0, offsetUv, vInput1UvRect);
            result *= point_inside_rect(offsetUv, vFilterData1.xy, vFilterData1.zw);
            needsPremul = false;
            break;
        case FILTER_COMPONENT_TRANSFER:
            result = ComponentTransfer(Ca);
            break;
        case FILTER_IDENTITY:
            result = Ca;
            break;
        case FILTER_COMPOSITE:
            result = composite(Ca, Cb, vData.x);
            needsPremul = false;
        default:
            break;
    }

    if (needsPremul) {
        result.rgb *= result.a;
    }

    oFragColor = result;
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared,shared_other

varying vec4 vColor;

#ifdef WR_VERTEX_SHADER
in vec4 aColor;

void main(void) {
    vColor = vec4(aColor.rgb * aColor.a, aColor.a);
    vec4 pos = vec4(aPosition, 0.0, 1.0);
    pos.xy = floor(pos.xy + 0.5);
    gl_Position = uTransform * pos;
}
#endif

#ifdef WR_FRAGMENT_SHADER
void main(void) {
    oFragColor = vColor;
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define WR_FEATURE_TEXTURE_2D

#include shared,shared_other

varying vec2 vColorTexCoord;
varying vec4 vColor;

#ifdef WR_VERTEX_SHADER
in vec4 aColor;
in vec2 aColorTexCoord;

void main(void) {
    vColor = aColor;
    vColorTexCoord = aColorTexCoord;
    vec4 pos = vec4(aPosition, 0.0, 1.0);
    pos.xy = floor(pos.xy + 0.5);
    gl_Position = uTransform * pos;
}
#endif

#ifdef WR_FRAGMENT_SHADER
void main(void) {
    float alpha = texture(sColor0, vColorTexCoord).r;
    oFragColor = vColor * alpha;
}
#endif
ellipse/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// Preprocess the radii for computing the distance approximation. This should
// be used in the vertex shader if possible to avoid doing expensive division
// in the fragment shader. When dealing with a point (zero radii), approximate
// it as an ellipse with very small radii so that we don't need to branch.
vec2 inverse_radii_squared(vec2 radii) {
    return 1.0 / max(radii * radii, 1.0e-6);
}

#ifdef WR_FRAGMENT_SHADER

// One iteration of Newton's method on the 2D equation of an ellipse:
//
//     E(x, y) = x^2/a^2 + y^2/b^2 - 1
//
// The Jacobian of this equation is:
//
//     J(E(x, y)) = [ 2*x/a^2 2*y/b^2 ]
//
// We approximate the distance with:
//
//     E(x, y) / ||J(E(x, y))||
//
// See G. Taubin, "Distance Approximations for Rasterizing Implicit
// Curves", section 3.
//
// A scale relative to the unit scale of the ellipse may be passed in to cause
// the math to degenerate to length(p) when scale is 0, or otherwise give the
// normal distance approximation if scale is 1.
float distance_to_ellipse_approx(vec2 p, vec2 inv_radii_sq, float scale) {
    vec2 p_r = p * inv_radii_sq;
    float g = dot(p, p_r) - scale;
    vec2 dG = (1.0 + scale) * p_r;
    return g * inversesqrt(dot(dG, dG));
}

// Slower but more accurate version that uses the exact distance when dealing
// with a 0-radius point distance and otherwise uses the faster approximation
// when dealing with non-zero radii.
float distance_to_ellipse(vec2 p, vec2 radii) {
    return distance_to_ellipse_approx(p, inverse_radii_squared(radii),
                                      float(all(greaterThan(radii, vec2(0.0)))));
}

float distance_to_rounded_rect(
    vec2 pos,
    vec4 center_radius_tl,
    vec4 center_radius_tr,
    vec4 center_radius_br,
    vec4 center_radius_bl,
    vec4 rect_bounds
) {
    // Clip against each ellipse. If the fragment is in a corner, one of the
    // branches below will select it as the corner to calculate the distance
    // to. We want to choose the smallest distance inside either of the axis
    // bounds as the overall distance we use to compare which corner is closer
    // than another. If outside any ellipse, default to a small offset so a
    // negative distance is returned for it.
    vec4 corner = vec4(vec2(1.0e-6), vec2(1.0));
    center_radius_tl.xy = center_radius_tl.xy - pos;
    center_radius_tr.xy = (center_radius_tr.xy - pos) * vec2(-1.0, 1.0);
    center_radius_br.xy = pos - center_radius_br.xy;
    center_radius_bl.xy = (center_radius_bl.xy - pos) * vec2(1.0, -1.0);
    if (min(center_radius_tl.x, center_radius_tl.y) > min(corner.x, corner.y)) {
        corner = center_radius_tl;
    }
    if (min(center_radius_tr.x, center_radius_tr.y) > min(corner.x, corner.y)) {
        corner = center_radius_tr;
    }
    if (min(center_radius_br.x, center_radius_br.y) > min(corner.x, corner.y)) {
        corner = center_radius_br;
    }
    if (min(center_radius_bl.x, center_radius_bl.y) > min(corner.x, corner.y)) {
        corner = center_radius_bl;
    }

    // Calculate the distance of the selected corner and the rectangle bounds,
    // whichever is greater.
    return max(distance_to_ellipse_approx(corner.xy, corner.zw, 1.0),
               signed_distance_rect(pos, rect_bounds.xy, rect_bounds.zw));
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

uniform HIGHP_SAMPLER_FLOAT sampler2D sGpuCache;

#define VECS_PER_IMAGE_RESOURCE     2

// TODO(gw): This is here temporarily while we have
//           both GPU store and cache. When the GPU
//           store code is removed, we can change the
//           PrimitiveInstance instance structure to
//           use 2x unsigned shorts as vertex attributes
//           instead of an int, and encode the UV directly
//           in the vertices.
ivec2 get_gpu_cache_uv(HIGHP_FS_ADDRESS int address) {
    return ivec2(uint(address) % WR_MAX_VERTEX_TEXTURE_WIDTH,
                 uint(address) / WR_MAX_VERTEX_TEXTURE_WIDTH);
}

vec4[2] fetch_from_gpu_cache_2_direct(ivec2 address) {
    return vec4[2](
        TEXEL_FETCH(sGpuCache, address, 0, ivec2(0, 0)),
        TEXEL_FETCH(sGpuCache, address, 0, ivec2(1, 0))
    );
}

vec4[2] fetch_from_gpu_cache_2(HIGHP_FS_ADDRESS int address) {
    ivec2 uv = get_gpu_cache_uv(address);
    return vec4[2](
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(0, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(1, 0))
    );
}

vec4 fetch_from_gpu_cache_1_direct(ivec2 address) {
    return texelFetch(sGpuCache, address, 0);
}

vec4 fetch_from_gpu_cache_1(HIGHP_FS_ADDRESS int address) {
    ivec2 uv = get_gpu_cache_uv(address);
    return texelFetch(sGpuCache, uv, 0);
}

#ifdef WR_VERTEX_SHADER

vec4[8] fetch_from_gpu_cache_8(int address) {
    ivec2 uv = get_gpu_cache_uv(address);
    return vec4[8](
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(0, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(1, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(2, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(3, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(4, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(5, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(6, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(7, 0))
    );
}

vec4[3] fetch_from_gpu_cache_3(int address) {
    ivec2 uv = get_gpu_cache_uv(address);
    return vec4[3](
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(0, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(1, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(2, 0))
    );
}

vec4[3] fetch_from_gpu_cache_3_direct(ivec2 address) {
    return vec4[3](
        TEXEL_FETCH(sGpuCache, address, 0, ivec2(0, 0)),
        TEXEL_FETCH(sGpuCache, address, 0, ivec2(1, 0)),
        TEXEL_FETCH(sGpuCache, address, 0, ivec2(2, 0))
    );
}

vec4[4] fetch_from_gpu_cache_4_direct(ivec2 address) {
    return vec4[4](
        TEXEL_FETCH(sGpuCache, address, 0, ivec2(0, 0)),
        TEXEL_FETCH(sGpuCache, address, 0, ivec2(1, 0)),
        TEXEL_FETCH(sGpuCache, address, 0, ivec2(2, 0)),
        TEXEL_FETCH(sGpuCache, address, 0, ivec2(3, 0))
    );
}

vec4[4] fetch_from_gpu_cache_4(int address) {
    ivec2 uv = get_gpu_cache_uv(address);
    return vec4[4](
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(0, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(1, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(2, 0)),
        TEXEL_FETCH(sGpuCache, uv, 0, ivec2(3, 0))
    );
}

//TODO: image resource is too specific for this module

struct ImageSource {
    RectWithEndpoint uv_rect;
    vec4 user_data;
};

ImageSource fetch_image_source(int address) {
    //Note: number of blocks has to match `renderer::BLOCKS_PER_UV_RECT`
    vec4 data[2] = fetch_from_gpu_cache_2(address);
    RectWithEndpoint uv_rect = RectWithEndpoint(data[0].xy, data[0].zw);
    return ImageSource(uv_rect, data[1]);
}

ImageSource fetch_image_source_direct(ivec2 address) {
    vec4 data[2] = fetch_from_gpu_cache_2_direct(address);
    RectWithEndpoint uv_rect = RectWithEndpoint(data[0].xy, data[0].zw);
    return ImageSource(uv_rect, data[1]);
}

// Fetch optional extra data for a texture cache resource. This can contain
// a polygon defining a UV rect within the texture cache resource.
// Note: the polygon coordinates are in homogeneous space.
struct ImageSourceExtra {
    vec4 st_tl;
    vec4 st_tr;
    vec4 st_bl;
    vec4 st_br;
};

ImageSourceExtra fetch_image_source_extra(int address) {
    vec4 data[4] = fetch_from_gpu_cache_4(address + VECS_PER_IMAGE_RESOURCE);
    return ImageSourceExtra(
        data[0],
        data[1],
        data[2],
        data[3]
    );
}

#endif //WR_VERTEX_SHADER
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include base

varying vec4 vData;

#ifdef WR_VERTEX_SHADER
in vec4 aValue;
in vec2 aPosition;

void main() {
    vData = aValue;
    gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    gl_PointSize = 1.0;
}

#endif //WR_VERTEX_SHADER

#ifdef WR_FRAGMENT_SHADER
out vec4 oValue;

void main() {
    oValue = vData;
}
#endif //WR_FRAGMENT_SHADER
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// Gradient GPU cache address.
// Packed in to a vector to work around bug 1630356.
flat varying HIGHP_FS_ADDRESS ivec2 v_gradient_address;
// Repetition along the gradient stops.
// Packed in to a vector to work around bug 1630356.
flat varying vec2 v_gradient_repeat;

#ifdef WR_FRAGMENT_SHADER

#ifdef WR_FEATURE_DITHERING
vec4 dither(vec4 color) {
    const int matrix_mask = 7;

    ivec2 pos = ivec2(gl_FragCoord.xy) & ivec2(matrix_mask);
    float noise_normalized = (texelFetch(sDither, pos, 0).r * 255.0 + 0.5) / 64.0;
    float noise = (noise_normalized - 0.5) / 256.0; // scale down to the unit length

    return color + vec4(noise, noise, noise, 0);
}
#else
vec4 dither(vec4 color) {
    return color;
}
#endif //WR_FEATURE_DITHERING

#define GRADIENT_ENTRIES 128.0

float clamp_gradient_entry(float offset) {
    // Calculate the color entry index to use for this offset:
    //     offsets < 0 use the first color entry, 0
    //     offsets from [0, 1) use the color entries in the range of [1, N-1)
    //     offsets >= 1 use the last color entry, N-1
    //     so transform the range [0, 1) -> [1, N-1)

    // TODO(gw): In the future we might consider making the size of the
    // LUT vary based on number / distribution of stops in the gradient.
    // Ensure we don't fetch outside the valid range of the LUT.
    return clamp(1.0 + offset * GRADIENT_ENTRIES, 0.0, 1.0 + GRADIENT_ENTRIES);
}

vec4 sample_gradient(float offset) {
    // Modulo the offset if the gradient repeats.
    offset -= floor(offset) * v_gradient_repeat.x;

    // Calculate the texel to index into the gradient color entries:
    //     floor(x) is the gradient color entry index
    //     fract(x) is the linear filtering factor between start and end
    float x = clamp_gradient_entry(offset);
    float entry_index = floor(x);
    float entry_fract = x - entry_index;

    // Fetch the start and end color. There is a [start, end] color per entry.
    vec4 texels[2] = fetch_from_gpu_cache_2(v_gradient_address.x + 2 * int(entry_index));

    // Finally interpolate and apply dithering
    return dither(texels[0] + texels[1] * entry_fract);
}

#endif //WR_FRAGMENT_SHADER
gradient_shared/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include gradient

// Size of the gradient pattern's rectangle, used to compute horizontal and vertical
// repetitions. Not to be confused with another kind of repetition of the pattern
// which happens along the gradient stops.
flat varying vec2 v_repeated_size;

varying vec2 v_pos;

#ifdef WR_FEATURE_ALPHA_PASS
flat varying vec2 v_tile_repeat;
#endif

#ifdef WR_VERTEX_SHADER
void write_gradient_vertex(
    VertexInfo vi,
    RectWithEndpoint local_rect,
    RectWithEndpoint segment_rect,
    ivec4 prim_user_data,
    int brush_flags,
    vec4 texel_rect,
    int extend_mode,
    vec2 stretch_size
) {
    if ((brush_flags & BRUSH_FLAG_SEGMENT_RELATIVE) != 0) {
        v_pos = (vi.local_pos - segment_rect.p0) / rect_size(segment_rect);
        v_pos = v_pos * (texel_rect.zw - texel_rect.xy) + texel_rect.xy;
        v_pos = v_pos * rect_size(local_rect);
    } else {
        v_pos = vi.local_pos - local_rect.p0;
    }

    vec2 tile_repeat = rect_size(local_rect) / stretch_size;
    v_repeated_size = stretch_size;

    // Normalize UV to 0..1 scale.
    v_pos /= v_repeated_size;

    v_gradient_address.x = prim_user_data.x;

    // Whether to repeat the gradient along the line instead of clamping.
    v_gradient_repeat.x = float(extend_mode == EXTEND_MODE_REPEAT);

#ifdef WR_FEATURE_ALPHA_PASS
    v_tile_repeat = tile_repeat;
#endif
}
#endif //WR_VERTEX_SHADER

#ifdef WR_FRAGMENT_SHADER
vec2 compute_repeated_pos() {
#if defined(WR_FEATURE_ALPHA_PASS) && !defined(SWGL_ANTIALIAS)
    // Handle top and left inflated edges (see brush_image).
    vec2 local_pos = max(v_pos, vec2(0.0));

    // Apply potential horizontal and vertical repetitions.
    vec2 pos = fract(local_pos);

    // Handle bottom and right inflated edges (see brush_image).
    if (local_pos.x >= v_tile_repeat.x) {
        pos.x = 1.0;
    }
    if (local_pos.y >= v_tile_repeat.y) {
        pos.y = 1.0;
    }
    return pos;
#else
    // Apply potential horizontal and vertical repetitions.
    return fract(v_pos);
#endif
}

#endif //WR_FRAGMENT_SHADER

prim_shared/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include rect,render_task,gpu_cache,transform

#define EXTEND_MODE_CLAMP  0
#define EXTEND_MODE_REPEAT 1

#define SUBPX_DIR_NONE        0
#define SUBPX_DIR_HORIZONTAL  1
#define SUBPX_DIR_VERTICAL    2
#define SUBPX_DIR_MIXED       3

#define RASTER_LOCAL            0
#define RASTER_SCREEN           1

uniform sampler2D sClipMask;

#ifndef SWGL_CLIP_MASK
// TODO: convert back to RectWithEndpoint if driver issues are resolved, if ever.
flat varying vec4 vClipMaskUvBounds;
varying vec2 vClipMaskUv;
#endif

#ifdef WR_VERTEX_SHADER

#define COLOR_MODE_FROM_PASS            0
#define COLOR_MODE_ALPHA                1
#define COLOR_MODE_SUBPX_CONST_COLOR    2
#define COLOR_MODE_SUBPX_BG_PASS0       3
#define COLOR_MODE_SUBPX_BG_PASS1       4
#define COLOR_MODE_SUBPX_BG_PASS2       5
#define COLOR_MODE_SUBPX_DUAL_SOURCE    6
#define COLOR_MODE_BITMAP_SHADOW        7
#define COLOR_MODE_COLOR_BITMAP         8
#define COLOR_MODE_IMAGE                9
#define COLOR_MODE_MULTIPLY_DUAL_SOURCE 10

uniform HIGHP_SAMPLER_FLOAT sampler2D sPrimitiveHeadersF;
uniform HIGHP_SAMPLER_FLOAT isampler2D sPrimitiveHeadersI;

// Instanced attributes
PER_INSTANCE in ivec4 aData;

#define VECS_PER_PRIM_HEADER_F 2U
#define VECS_PER_PRIM_HEADER_I 2U

struct Instance
{
    int prim_header_address;
    int picture_task_address;
    int clip_address;
    int segment_index;
    int flags;
    int resource_address;
    int brush_kind;
};

Instance decode_instance_attributes() {
    Instance instance;

    instance.prim_header_address = aData.x;
    instance.picture_task_address = aData.y >> 16;
    instance.clip_address = aData.y & 0xffff;
    instance.segment_index = aData.z & 0xffff;
    instance.flags = aData.z >> 16;
    instance.resource_address = aData.w & 0xffffff;
    instance.brush_kind = aData.w >> 24;

    return instance;
}

struct PrimitiveHeader {
    RectWithEndpoint local_rect;
    RectWithEndpoint local_clip_rect;
    float z;
    int specific_prim_address;
    int transform_id;
    ivec4 user_data;
};

PrimitiveHeader fetch_prim_header(int index) {
    PrimitiveHeader ph;

    ivec2 uv_f = get_fetch_uv(index, VECS_PER_PRIM_HEADER_F);
    vec4 local_rect = TEXEL_FETCH(sPrimitiveHeadersF, uv_f, 0, ivec2(0, 0));
    vec4 local_clip_rect = TEXEL_FETCH(sPrimitiveHeadersF, uv_f, 0, ivec2(1, 0));
    ph.local_rect = RectWithEndpoint(local_rect.xy, local_rect.zw);
    ph.local_clip_rect = RectWithEndpoint(local_clip_rect.xy, local_clip_rect.zw);

    ivec2 uv_i = get_fetch_uv(index, VECS_PER_PRIM_HEADER_I);
    ivec4 data0 = TEXEL_FETCH(sPrimitiveHeadersI, uv_i, 0, ivec2(0, 0));
    ivec4 data1 = TEXEL_FETCH(sPrimitiveHeadersI, uv_i, 0, ivec2(1, 0));
    ph.z = float(data0.x);
    ph.specific_prim_address = data0.y;
    ph.transform_id = data0.z;
    ph.user_data = data1;

    return ph;
}

struct VertexInfo {
    vec2 local_pos;
    vec4 world_pos;
};

VertexInfo write_vertex(vec2 local_pos,
                        RectWithEndpoint local_clip_rect,
                        float z,
                        Transform transform,
                        PictureTask task) {
    // Clamp to the two local clip rects.
    vec2 clamped_local_pos = rect_clamp(local_clip_rect, local_pos);

    // Transform the current vertex to world space.
    vec4 world_pos = transform.m * vec4(clamped_local_pos, 0.0, 1.0);

    // Convert the world positions to device pixel space.
    vec2 device_pos = world_pos.xy * task.device_pixel_scale;

    // Apply offsets for the render task to get correct screen location.
    vec2 final_offset = -task.content_origin + task.task_rect.p0;

    gl_Position = uTransform * vec4(device_pos + final_offset * world_pos.w, z * world_pos.w, world_pos.w);

    VertexInfo vi = VertexInfo(
        clamped_local_pos,
        world_pos
    );

    return vi;
}

RectWithEndpoint clip_and_init_antialiasing(RectWithEndpoint segment_rect,
                                            RectWithEndpoint prim_rect,
                                            RectWithEndpoint clip_rect,
                                            int edge_flags,
                                            float z,
                                            Transform transform,
                                            PictureTask task) {
#ifdef SWGL_ANTIALIAS
    // Check if the bounds are smaller than the unmodified segment rect. If so,
    // it is safe to enable AA on those edges.
    bvec4 clipped = bvec4(greaterThan(clip_rect.p0, segment_rect.p0),
                          lessThan(clip_rect.p1, segment_rect.p1));
    swgl_antiAlias(edge_flags | (clipped.x ? 1 : 0) | (clipped.y ? 2 : 0) |
                   (clipped.z ? 4 : 0) | (clipped.w ? 8 : 0));
#endif

    segment_rect.p0 = clamp(segment_rect.p0, clip_rect.p0, clip_rect.p1);
    segment_rect.p1 = clamp(segment_rect.p1, clip_rect.p0, clip_rect.p1);

#ifndef SWGL_ANTIALIAS
    prim_rect.p0 = clamp(prim_rect.p0, clip_rect.p0, clip_rect.p1);
    prim_rect.p1 = clamp(prim_rect.p1, clip_rect.p0, clip_rect.p1);

    // Select between the segment and prim edges based on edge mask.
    // We must perform the bitwise-and for each component individually, as a
    // vector bitwise-and followed by conversion to bvec4 causes shader
    // compilation crashes on some Adreno devices. See bug 1715746.
    bvec4 clip_edge_mask = bvec4(bool(edge_flags & 1), bool(edge_flags & 2), bool(edge_flags & 4), bool(edge_flags & 8));
    init_transform_vs(mix(
        vec4(vec2(-1e16), vec2(1e16)),
        vec4(segment_rect.p0, segment_rect.p1),
        clip_edge_mask
    ));

    // As this is a transform shader, extrude by 2 (local space) pixels
    // in each direction. This gives enough space around the edge to
    // apply distance anti-aliasing. Technically, it:
    // (a) slightly over-estimates the number of required pixels in the simple case.
    // (b) might not provide enough edge in edge case perspective projections.
    // However, it's fast and simple. If / when we ever run into issues, we
    // can do some math on the projection matrix to work out a variable
    // amount to extrude.

    // Only extrude along edges where we are going to apply AA.
    float extrude_amount = 2.0;
    vec4 extrude_distance = mix(vec4(0.0), vec4(extrude_amount), clip_edge_mask);
    segment_rect.p0 -= extrude_distance.xy;
    segment_rect.p1 += extrude_distance.zw;
#endif

    return segment_rect;
}

void write_clip(vec4 world_pos, ClipArea area, PictureTask task) {
#ifdef SWGL_CLIP_MASK
    swgl_clipMask(
        sClipMask,
        (task.task_rect.p0 - task.content_origin) - (area.task_rect.p0 - area.screen_origin),
        area.task_rect.p0,
        rect_size(area.task_rect)
    );
#else
    vec2 uv = world_pos.xy * area.device_pixel_scale +
        world_pos.w * (area.task_rect.p0 - area.screen_origin);
    vClipMaskUvBounds = vec4(
        area.task_rect.p0,
        area.task_rect.p1
    );
    vClipMaskUv = uv;
#endif
}

// Read the exta image data containing the homogeneous screen space coordinates
// of the corners, interpolate between them, and return real screen space UV.
vec2 get_image_quad_uv(int address, vec2 f) {
    ImageSourceExtra extra_data = fetch_image_source_extra(address);
    vec4 x = mix(extra_data.st_tl, extra_data.st_tr, f.x);
    vec4 y = mix(extra_data.st_bl, extra_data.st_br, f.x);
    vec4 z = mix(x, y, f.y);
    return z.xy / z.w;
}
#endif //WR_VERTEX_SHADER

#ifdef WR_FRAGMENT_SHADER

struct Fragment {
    vec4 color;
#ifdef WR_FEATURE_DUAL_SOURCE_BLENDING
    vec4 blend;
#endif
};

float do_clip() {
#ifdef SWGL_CLIP_MASK
    // SWGL relies on builtin clip-mask support to do this more efficiently,
    // so no clipping is required here.
    return 1.0;
#else
    // check for the dummy bounds, which are given to the opaque objects
    if (vClipMaskUvBounds.xy == vClipMaskUvBounds.zw) {
        return 1.0;
    }
    // anything outside of the mask is considered transparent
    //Note: we assume gl_FragCoord.w == interpolated(1 / vClipMaskUv.w)
    vec2 mask_uv = vClipMaskUv * gl_FragCoord.w;
    bvec2 left = lessThanEqual(vClipMaskUvBounds.xy, mask_uv); // inclusive
    bvec2 right = greaterThan(vClipMaskUvBounds.zw, mask_uv); // non-inclusive
    // bail out if the pixel is outside the valid bounds
    if (!all(bvec4(left, right))) {
        return 0.0;
    }
    // finally, the slow path - fetch the mask value from an image
    return texelFetch(sClipMask, ivec2(mask_uv), 0).r;
#endif
}

#endif //WR_FRAGMENT_SHADER
e7b0cd0b3e62ff6/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared

varying vec4 vColor;

#ifdef WR_VERTEX_SHADER
PER_INSTANCE in vec4 aRect;
PER_INSTANCE in vec4 aColor;

void main(void) {
    vec2 pos = mix(aRect.xy, aRect.zw, aPosition.xy);
    gl_Position = uTransform * vec4(pos, 0.0, 1.0);
    gl_Position.z = gl_Position.w; // force depth clear to 1.0
    vColor = aColor;
}
#endif

#ifdef WR_FRAGMENT_SHADER
void main(void) {
    oFragColor = vColor;
}
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include base

#ifdef WR_VERTEX_SHADER

attribute vec2 aPosition;

// See CopyInstance struct.
attribute vec4 a_src_rect;
attribute vec4 a_dst_rect;
attribute vec2 a_dst_texture_size;

varying vec2 v_uv;

void main(void) {
    // We use texel fetch so v_uv is in unnormalized device space.
    v_uv = mix(a_src_rect.xy, a_src_rect.zw, aPosition.xy);

    // Transform into framebuffer [-1, 1] space.
    vec2 pos = mix(a_dst_rect.xy, a_dst_rect.zw, aPosition.xy);
    gl_Position = vec4(pos / (a_dst_texture_size  * 0.5) - vec2(1.0, 1.0), 0.0, 1.0);
}
#endif

#ifdef WR_FRAGMENT_SHADER


out vec4 oFragColor;

varying vec2 v_uv;

uniform sampler2D sColor0;

void main(void) {
    oFragColor = texelFetch(sColor0, ivec2(v_uv), 0);
}

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#define WR_FEATURE_TEXTURE_2D

#include shared,prim_shared

// interpolated UV coordinates to sample.
varying vec2 vUv;

// Flag to allow perspective interpolation of UV.
// Packed in to a vector to work around bug 1630356.
flat varying vec2 vPerspective;

flat varying vec4 vUvSampleBounds;

#ifdef WR_VERTEX_SHADER
struct SplitGeometry {
    vec2 local[4];
};

SplitGeometry fetch_split_geometry(int address) {
    ivec2 uv = get_gpu_cache_uv(address);

    vec4 data0 = TEXEL_FETCH(sGpuCache, uv, 0, ivec2(0, 0));
    vec4 data1 = TEXEL_FETCH(sGpuCache, uv, 0, ivec2(1, 0));

    SplitGeometry geo;
    geo.local = vec2[4](
        data0.xy,
        data0.zw,
        data1.xy,
        data1.zw
    );

    return geo;
}

vec2 bilerp(vec2 a, vec2 b, vec2 c, vec2 d, float s, float t) {
    vec2 x = mix(a, b, t);
    vec2 y = mix(c, d, t);
    return mix(x, y, s);
}

struct SplitCompositeInstance {
    int prim_header_index;
    int polygons_address;
    float z;
    int render_task_index;
};

SplitCompositeInstance fetch_composite_instance() {
    SplitCompositeInstance ci;

    ci.prim_header_index = aData.x;
    ci.polygons_address = aData.y;
    ci.z = float(aData.z);
    ci.render_task_index = aData.w;

    return ci;
}

void main(void) {
    SplitCompositeInstance ci = fetch_composite_instance();
    SplitGeometry geometry = fetch_split_geometry(ci.polygons_address);
    PrimitiveHeader ph = fetch_prim_header(ci.prim_header_index);
    PictureTask dest_task = fetch_picture_task(ci.render_task_index);
    Transform transform = fetch_transform(ph.transform_id);
    ImageSource res = fetch_image_source(ph.user_data.x);
    ClipArea clip_area = fetch_clip_area(ph.user_data.w);

    vec2 dest_origin = dest_task.task_rect.p0 -
                       dest_task.content_origin;

    vec2 local_pos = bilerp(geometry.local[0], geometry.local[1],
                            geometry.local[3], geometry.local[2],
                            aPosition.y, aPosition.x);
    vec4 world_pos = transform.m * vec4(local_pos, 0.0, 1.0);

    vec4 final_pos = vec4(
        dest_origin * world_pos.w + world_pos.xy * dest_task.device_pixel_scale,
        world_pos.w * ci.z,
        world_pos.w
    );

    write_clip(
        world_pos,
        clip_area,
        dest_task
    );

    gl_Position = uTransform * final_pos;

    vec2 texture_size = vec2(TEX_SIZE(sColor0));
    vec2 uv0 = res.uv_rect.p0;
    vec2 uv1 = res.uv_rect.p1;

    vec2 min_uv = min(uv0, uv1);
    vec2 max_uv = max(uv0, uv1);

    vUvSampleBounds = vec4(
        min_uv + vec2(0.5),
        max_uv - vec2(0.5)
    ) / texture_size.xyxy;

    vec2 f = (local_pos - ph.local_rect.p0) / rect_size(ph.local_rect);
    f = get_image_quad_uv(ph.user_data.x, f);
    vec2 uv = mix(uv0, uv1, f);
    float perspective_interpolate = float(ph.user_data.y);

    vUv = uv / texture_size * mix(gl_Position.w, 1.0, perspective_interpolate);
    vPerspective.x = perspective_interpolate;
}
#endif

#ifdef WR_FRAGMENT_SHADER
void main(void) {
    float alpha = do_clip();
    float perspective_divisor = mix(gl_FragCoord.w, 1.0, vPerspective.x);
    vec2 uv = clamp(vUv * perspective_divisor, vUvSampleBounds.xy, vUvSampleBounds.zw);
    write_output(alpha * texture(sColor0, uv));
}

#ifdef SWGL_DRAW_SPAN
void swgl_drawSpanRGBA8() {
    float perspective_divisor = mix(swgl_forceScalar(gl_FragCoord.w), 1.0, vPerspective.x);
    vec2 uv = vUv * perspective_divisor;

    swgl_commitTextureRGBA8(sColor0, uv, vUvSampleBounds);
}
#endif

#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared,prim_shared

flat varying vec4 v_color;
flat varying vec3 v_mask_swizzle;
// Normalized bounds of the source image in the texture.
flat varying vec4 v_uv_bounds;

// Interpolated UV coordinates to sample.
varying vec2 v_uv;


#if defined(WR_FEATURE_GLYPH_TRANSFORM) && !defined(SWGL_CLIP_DIST)
varying vec4 v_uv_clip;
#endif

#ifdef WR_VERTEX_SHADER

#define VECS_PER_TEXT_RUN           2
#define GLYPHS_PER_GPU_BLOCK        2U

#ifdef WR_FEATURE_GLYPH_TRANSFORM
RectWithEndpoint transform_rect(RectWithEndpoint rect, mat2 transform) {
    vec2 size = rect_size(rect);
    vec2 center = transform * (rect.p0 + size * 0.5);
    vec2 radius = mat2(abs(transform[0]), abs(transform[1])) * (size * 0.5);
    return RectWithEndpoint(center - radius, center + radius);
}

bool rect_inside_rect(RectWithEndpoint little, RectWithEndpoint big) {
    return all(lessThanEqual(vec4(big.p0, little.p1), vec4(little.p0, big.p1)));
}
#endif //WR_FEATURE_GLYPH_TRANSFORM

struct Glyph {
    vec2 offset;
};

Glyph fetch_glyph(int specific_prim_address,
                  int glyph_index) {
    // Two glyphs are packed in each texel in the GPU cache.
    int glyph_address = specific_prim_address +
                        VECS_PER_TEXT_RUN +
                        int(uint(glyph_index) / GLYPHS_PER_GPU_BLOCK);
    vec4 data = fetch_from_gpu_cache_1(glyph_address);
    // Select XY or ZW based on glyph index.
    vec2 glyph = mix(data.xy, data.zw,
                     bvec2(uint(glyph_index) % GLYPHS_PER_GPU_BLOCK == 1U));

    return Glyph(glyph);
}

struct GlyphResource {
    vec4 uv_rect;
    vec2 offset;
    float scale;
};

GlyphResource fetch_glyph_resource(int address) {
    vec4 data[2] = fetch_from_gpu_cache_2(address);
    return GlyphResource(data[0], data[1].xy, data[1].z);
}

struct TextRun {
    vec4 color;
    vec4 bg_color;
};

TextRun fetch_text_run(int address) {
    vec4 data[2] = fetch_from_gpu_cache_2(address);
    return TextRun(data[0], data[1]);
}

vec2 get_snap_bias(int subpx_dir) {
    // In subpixel mode, the subpixel offset has already been
    // accounted for while rasterizing the glyph. However, we
    // must still round with a subpixel bias rather than rounding
    // to the nearest whole pixel, depending on subpixel direciton.
    switch (subpx_dir) {
        case SUBPX_DIR_NONE:
        default:
            return vec2(0.5);
        case SUBPX_DIR_HORIZONTAL:
            // Glyphs positioned [-0.125, 0.125] get a
            // subpx position of zero. So include that
            // offset in the glyph position to ensure
            // we round to the correct whole position.
            return vec2(0.125, 0.5);
        case SUBPX_DIR_VERTICAL:
            return vec2(0.5, 0.125);
        case SUBPX_DIR_MIXED:
            return vec2(0.125);
    }
}

void main() {
    Instance instance = decode_instance_attributes();
    PrimitiveHeader ph = fetch_prim_header(instance.prim_header_address);
    Transform transform = fetch_transform(ph.transform_id);
    ClipArea clip_area = fetch_clip_area(instance.clip_address);
    PictureTask task = fetch_picture_task(instance.picture_task_address);

    int glyph_index = instance.segment_index;
    int subpx_dir = (instance.flags >> 8) & 0xff;
    int color_mode = instance.flags & 0xff;

    // Note that the reference frame relative offset is stored in the prim local
    // rect size during batching, instead of the actual size of the primitive.
    TextRun text = fetch_text_run(ph.specific_prim_address);
    vec2 text_offset = ph.local_rect.p1;

    if (color_mode == COLOR_MODE_FROM_PASS) {
        color_mode = uMode;
    }

    // Note that the unsnapped reference frame relative offset has already
    // been subtracted from the prim local rect origin during batching.
    // It was done this way to avoid pushing both the snapped and the
    // unsnapped offsets to the shader.
    Glyph glyph = fetch_glyph(ph.specific_prim_address, glyph_index);
    glyph.offset += ph.local_rect.p0;

    GlyphResource res = fetch_glyph_resource(instance.resource_address);

    vec2 snap_bias = get_snap_bias(subpx_dir);

    // Glyph space refers to the pixel space used by glyph rasterization during frame
    // building. If a non-identity transform was used, WR_FEATURE_GLYPH_TRANSFORM will
    // be set. Otherwise, regardless of whether the raster space is LOCAL or SCREEN,
    // we ignored the transform during glyph rasterization, and need to snap just using
    // the device pixel scale and the raster scale.
#ifdef WR_FEATURE_GLYPH_TRANSFORM
    // Transform from local space to glyph space.
    mat2 glyph_transform = mat2(transform.m) * task.device_pixel_scale;
    vec2 glyph_translation = transform.m[3].xy * task.device_pixel_scale;

    // Transform from glyph space back to local space.
    mat2 glyph_transform_inv = inverse(glyph_transform);

    // Glyph raster pixels include the impact of the transform. This path can only be
    // entered for 3d transforms that can be coerced into a 2d transform; they have no
    // perspective, and have a 2d inverse. This is a looser condition than axis aligned
    // transforms because it also allows 2d rotations.
    vec2 raster_glyph_offset = floor(glyph_transform * glyph.offset + snap_bias);

    // We want to eliminate any subpixel translation in device space to ensure glyph
    // snapping is stable for equivalent glyph subpixel positions. Note that we must take
    // into account the translation from the transform for snapping purposes.
    vec2 raster_text_offset = floor(glyph_transform * text_offset + glyph_translation + 0.5) - glyph_translation;

    vec2 glyph_origin = res.offset + raster_glyph_offset + raster_text_offset;
    // Compute the glyph rect in glyph space.
    RectWithEndpoint glyph_rect = RectWithEndpoint(
        glyph_origin,
        glyph_origin + res.uv_rect.zw - res.uv_rect.xy
    );

    // The glyph rect is in glyph space, so transform it back to local space.
    RectWithEndpoint local_rect = transform_rect(glyph_rect, glyph_transform_inv);

    // Select the corner of the glyph's local space rect that we are processing.
    vec2 local_pos = mix(local_rect.p0, local_rect.p1, aPosition.xy);

    // If the glyph's local rect would fit inside the local clip rect, then select a corner from
    // the device space glyph rect to reduce overdraw of clipped pixels in the fragment shader.
    // Otherwise, fall back to clamping the glyph's local rect to the local clip rect.
    if (rect_inside_rect(local_rect, ph.local_clip_rect)) {
        local_pos = glyph_transform_inv * mix(glyph_rect.p0, glyph_rect.p1, aPosition.xy);
    }
#else
    float raster_scale = float(ph.user_data.x) / 65535.0;

    // Scale in which the glyph is snapped when rasterized.
    float glyph_raster_scale = raster_scale * task.device_pixel_scale;

    // Scale from glyph space to local space.
    float glyph_scale_inv = res.scale / glyph_raster_scale;

    // Glyph raster pixels do not include the impact of the transform. Instead it was
    // replaced with an identity transform during glyph rasterization. As such only the
    // impact of the raster scale (if in local space) and the device pixel scale (for both
    // local and screen space) are included.
    //
    // This implies one or more of the following conditions:
    // - The transform is an identity. In that case, setting WR_FEATURE_GLYPH_TRANSFORM
    //   should have the same output result as not. We just distingush which path to use
    //   based on the transform used during glyph rasterization. (Screen space).
    // - The transform contains an animation. We will imply local raster space in such
    //   cases to avoid constantly rerasterizing the glyphs.
    // - The transform has perspective or does not have a 2d inverse (Screen or local space).
    // - The transform's scale will result in result in very large rasterized glyphs and
    //   we clamped the size. This will imply local raster space.
    vec2 raster_glyph_offset = floor(glyph.offset * glyph_raster_scale + snap_bias) / res.scale;

    // Compute the glyph rect in local space.
    //
    // The transform may be animated, so we don't want to do any snapping here for the
    // text offset to avoid glyphs wiggling. The text offset should have been snapped
    // already for axis aligned transforms excluding any animations during frame building.
    vec2 glyph_origin = glyph_scale_inv * (res.offset + raster_glyph_offset) + text_offset;
    RectWithEndpoint glyph_rect = RectWithEndpoint(
        glyph_origin,
        glyph_origin + glyph_scale_inv * (res.uv_rect.zw - res.uv_rect.xy)
    );

    // Select the corner of the glyph rect that we are processing.
    vec2 local_pos = mix(glyph_rect.p0, glyph_rect.p1, aPosition.xy);
#endif

    VertexInfo vi = write_vertex(
        local_pos,
        ph.local_clip_rect,
        ph.z,
        transform,
        task
    );

#ifdef WR_FEATURE_GLYPH_TRANSFORM
    vec2 f = (glyph_transform * vi.local_pos - glyph_rect.p0) / rect_size(glyph_rect);
    #ifdef SWGL_CLIP_DIST
        gl_ClipDistance[0] = f.x;
        gl_ClipDistance[1] = f.y;
        gl_ClipDistance[2] = 1.0 - f.x;
        gl_ClipDistance[3] = 1.0 - f.y;
    #else
        v_uv_clip = vec4(f, 1.0 - f);
    #endif
#else
    vec2 f = (vi.local_pos - glyph_rect.p0) / rect_size(glyph_rect);
#endif

    write_clip(vi.world_pos, clip_area, task);

    switch (color_mode) {
        case COLOR_MODE_ALPHA:
            v_mask_swizzle = vec3(0.0, 1.0, 1.0);
            v_color = text.color;
            break;
        case COLOR_MODE_BITMAP_SHADOW:
            #ifdef SWGL_BLEND
                swgl_blendDropShadow(text.color);
                v_mask_swizzle = vec3(1.0, 0.0, 0.0);
                v_color = vec4(1.0);
            #else
                v_mask_swizzle = vec3(0.0, 1.0, 0.0);
                v_color = text.color;
            #endif
            break;
        case COLOR_MODE_SUBPX_BG_PASS2:
            v_mask_swizzle = vec3(1.0, 0.0, 0.0);
            v_color = text.color;
            break;
        case COLOR_MODE_SUBPX_CONST_COLOR:
        case COLOR_MODE_SUBPX_BG_PASS0:
        case COLOR_MODE_COLOR_BITMAP:
            v_mask_swizzle = vec3(1.0, 0.0, 0.0);
            v_color = vec4(text.color.a);
            break;
        case COLOR_MODE_SUBPX_BG_PASS1:
            v_mask_swizzle = vec3(-1.0, 1.0, 0.0);
            v_color = vec4(text.color.a) * text.bg_color;
            break;
        case COLOR_MODE_SUBPX_DUAL_SOURCE:
            #ifdef SWGL_BLEND
                swgl_blendSubpixelText(text.color);
                v_mask_swizzle = vec3(1.0, 0.0, 0.0);
                v_color = vec4(1.0);
            #else
                v_mask_swizzle = vec3(text.color.a, 0.0, 0.0);
                v_color = text.color;
            #endif
            break;
        default:
            v_mask_swizzle = vec3(0.0, 0.0, 0.0);
            v_color = vec4(1.0);
    }

    vec2 texture_size = vec2(TEX_SIZE(sColor0));
    vec2 st0 = res.uv_rect.xy / texture_size;
    vec2 st1 = res.uv_rect.zw / texture_size;

    v_uv = mix(st0, st1, f);
    v_uv_bounds = (res.uv_rect + vec4(0.5, 0.5, -0.5, -0.5)) / texture_size.xyxy;
}

#endif // WR_VERTEX_SHADER

#ifdef WR_FRAGMENT_SHADER

Fragment text_fs(void) {
    Fragment frag;

    vec2 tc = clamp(v_uv, v_uv_bounds.xy, v_uv_bounds.zw);
    vec4 mask = texture(sColor0, tc);
    // v_mask_swizzle.z != 0 means we are using an R8 texture as alpha,
    // and therefore must swizzle from the r channel to all channels.
    mask = mix(mask, mask.rrrr, bvec4(v_mask_swizzle.z != 0.0));
    #ifndef WR_FEATURE_DUAL_SOURCE_BLENDING
        mask.rgb = mask.rgb * v_mask_swizzle.x + mask.aaa * v_mask_swizzle.y;
    #endif

    #if defined(WR_FEATURE_GLYPH_TRANSFORM) && !defined(SWGL_CLIP_DIST)
        mask *= float(all(greaterThanEqual(v_uv_clip, vec4(0.0))));
    #endif

    frag.color = v_color * mask;

    #if defined(WR_FEATURE_DUAL_SOURCE_BLENDING) && !defined(SWGL_BLEND)
        frag.blend = mask * v_mask_swizzle.x + mask.aaaa * v_mask_swizzle.y;
    #endif

    return frag;
}


void main() {
    Fragment frag = text_fs();

    float clip_mask = do_clip();
    frag.color *= clip_mask;

    #if defined(WR_FEATURE_DEBUG_OVERDRAW)
        oFragColor = WR_DEBUG_OVERDRAW_COLOR;
    #elif defined(WR_FEATURE_DUAL_SOURCE_BLENDING) && !defined(SWGL_BLEND)
        oFragColor = frag.color;
        oFragBlend = frag.blend * clip_mask;
    #else
        write_output(frag.color);
    #endif
}

#if defined(SWGL_DRAW_SPAN) && defined(SWGL_BLEND) && defined(SWGL_CLIP_DIST)
void swgl_drawSpanRGBA8() {
    // Only support simple swizzles for now. More complex swizzles must either
    // be handled by blend overrides or the slow path.
    if (v_mask_swizzle.x != 0.0 && v_mask_swizzle.x != 1.0) {
        return;
    }

    #ifdef WR_FEATURE_DUAL_SOURCE_BLENDING
        swgl_commitTextureLinearRGBA8(sColor0, v_uv, v_uv_bounds);
    #else
        if (swgl_isTextureR8(sColor0)) {
            swgl_commitTextureLinearColorR8ToRGBA8(sColor0, v_uv, v_uv_bounds, v_color);
        } else {
            swgl_commitTextureLinearColorRGBA8(sColor0, v_uv, v_uv_bounds, v_color);
        }
    #endif
}
#endif

#endif // WR_FRAGMENT_SHADER
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

struct RectWithSize {
    vec2 p0;
    vec2 size;
};

struct RectWithEndpoint {
    vec2 p0;
    vec2 p1;
};

float point_inside_rect(vec2 p, vec2 p0, vec2 p1) {
    vec2 s = step(p0, p) - step(p1, p);
    return s.x * s.y;
}

vec2 signed_distance_rect_xy(vec2 pos, vec2 p0, vec2 p1) {
    // Instead of using a true signed distance to rect here, we just use the
    // simpler approximation of the maximum distance on either axis from the
    // outside of the rectangle. This avoids expensive use of length() and only
    // causes mostly imperceptible differences at corner pixels.
    return max(p0 - pos, pos - p1);
}

float signed_distance_rect(vec2 pos, vec2 p0, vec2 p1) {
    // Collapse the per-axis distances to edges to a single approximate value.
    vec2 d = signed_distance_rect_xy(pos, p0, p1);
    return max(d.x, d.y);
}

vec2 rect_clamp(RectWithEndpoint rect, vec2 pt) {
    return clamp(pt, rect.p0, rect.p1);
}

vec2 rect_size(RectWithEndpoint rect) {
    return rect.p1 - rect.p0;
}
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */


#ifdef WR_VERTEX_SHADER
#define VECS_PER_RENDER_TASK        2U

uniform HIGHP_SAMPLER_FLOAT sampler2D sRenderTasks;

struct RenderTaskData {
    RectWithEndpoint task_rect;
    vec4 user_data;
};

// See RenderTaskData in render_task.rs
RenderTaskData fetch_render_task_data(int index) {
    ivec2 uv = get_fetch_uv(index, VECS_PER_RENDER_TASK);

    vec4 texel0 = TEXEL_FETCH(sRenderTasks, uv, 0, ivec2(0, 0));
    vec4 texel1 = TEXEL_FETCH(sRenderTasks, uv, 0, ivec2(1, 0));

    RectWithEndpoint task_rect = RectWithEndpoint(
        texel0.xy,
        texel0.zw
    );

    RenderTaskData data = RenderTaskData(
        task_rect,
        texel1
    );

    return data;
}

RectWithEndpoint fetch_render_task_rect(int index) {
    ivec2 uv = get_fetch_uv(index, VECS_PER_RENDER_TASK);

    vec4 texel0 = TEXEL_FETCH(sRenderTasks, uv, 0, ivec2(0, 0));
    vec4 texel1 = TEXEL_FETCH(sRenderTasks, uv, 0, ivec2(1, 0));

    RectWithEndpoint task_rect = RectWithEndpoint(
        texel0.xy,
        texel0.zw
    );

    return task_rect;
}

#define PIC_TYPE_IMAGE          1
#define PIC_TYPE_TEXT_SHADOW    2

/*
 The dynamic picture that this brush exists on. Right now, it
 contains minimal information. In the future, it will describe
 the transform mode of primitives on this picture, among other things.
 */
struct PictureTask {
    RectWithEndpoint task_rect;
    float device_pixel_scale;
    vec2 content_origin;
};

PictureTask fetch_picture_task(int address) {
    RenderTaskData task_data = fetch_render_task_data(address);

    PictureTask task = PictureTask(
        task_data.task_rect,
        task_data.user_data.x,
        task_data.user_data.yz
    );

    return task;
}

#define CLIP_TASK_EMPTY 0x7FFF

struct ClipArea {
    RectWithEndpoint task_rect;
    float device_pixel_scale;
    vec2 screen_origin;
};

ClipArea fetch_clip_area(int index) {
    ClipArea area;

    if (index >= CLIP_TASK_EMPTY) {
        area.task_rect = RectWithEndpoint(vec2(0.0), vec2(0.0));
        area.device_pixel_scale = 0.0;
        area.screen_origin = vec2(0.0);
    } else {
        RenderTaskData task_data = fetch_render_task_data(index);

        area.task_rect = task_data.task_rect;
        area.device_pixel_scale = task_data.user_data.x;
        area.screen_origin = task_data.user_data.yz;
    }

    return area;
}

#endif //WR_VERTEX_SHADER
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifdef WR_FEATURE_TEXTURE_EXTERNAL
// Please check https://www.khronos.org/registry/OpenGL/extensions/OES/OES_EGL_image_external_essl3.txt
// for this extension.
#extension GL_OES_EGL_image_external_essl3 : require
#endif

#ifdef WR_FEATURE_TEXTURE_EXTERNAL_ESSL1
// Some GLES 3 devices do not support GL_OES_EGL_image_external_essl3, so we
// must use GL_OES_EGL_image_external instead and make the shader ESSL1
// compatible.
#extension GL_OES_EGL_image_external : require
#endif

#ifdef WR_FEATURE_ADVANCED_BLEND
#extension GL_KHR_blend_equation_advanced : require
#endif

#ifdef WR_FEATURE_DUAL_SOURCE_BLENDING
#ifdef GL_ES
#extension GL_EXT_blend_func_extended : require
#else
#extension GL_ARB_explicit_attrib_location : require
#endif
#endif

#include base

#if defined(WR_FEATURE_TEXTURE_EXTERNAL_ESSL1)
#define TEX_SAMPLE(sampler, tex_coord) texture2D(sampler, tex_coord.xy)
#else
#define TEX_SAMPLE(sampler, tex_coord) texture(sampler, tex_coord.xy)
#endif

#if defined(WR_FEATURE_TEXTURE_EXTERNAL) && defined(PLATFORM_ANDROID)
// On some Mali GPUs we have encountered crashes in glDrawElements when using
// textureSize(samplerExternalOES) in a vertex shader without potentially
// sampling from the texture. This tricks the driver in to thinking the texture
// may be sampled from, avoiding the crash. See bug 1692848.
uniform bool u_mali_workaround_dummy;
#define TEX_SIZE(sampler) (u_mali_workaround_dummy ? ivec2(texture(sampler, vec2(0.0, 0.0)).rr) : textureSize(sampler, 0))
#else
#define TEX_SIZE(sampler) textureSize(sampler, 0)
#endif

//======================================================================================
// Vertex shader attributes and uniforms
//======================================================================================
#ifdef WR_VERTEX_SHADER
    // A generic uniform that shaders can optionally use to configure
    // an operation mode for this batch.
    uniform int uMode;

    // Uniform inputs
    uniform mat4 uTransform;       // Orthographic projection

    // Attribute inputs
    attribute vec2 aPosition;

    // get_fetch_uv is a macro to work around a macOS Intel driver parsing bug.
    // TODO: convert back to a function once the driver issues are resolved, if ever.
    // https://github.com/servo/webrender/pull/623
    // https://github.com/servo/servo/issues/13953
    // Do the division with unsigned ints because that's more efficient with D3D
    #define get_fetch_uv(i, vpi)  ivec2(int(vpi * (uint(i) % (WR_MAX_VERTEX_TEXTURE_WIDTH/vpi))), int(uint(i) / (WR_MAX_VERTEX_TEXTURE_WIDTH/vpi)))
#endif

//======================================================================================
// Fragment shader attributes and uniforms
//======================================================================================
#ifdef WR_FRAGMENT_SHADER
    // Uniform inputs

    // Fragment shader outputs
    #ifdef WR_FEATURE_ADVANCED_BLEND
        layout(blend_support_all_equations) out;
    #endif

    #if __VERSION__ == 100
        #define oFragColor gl_FragColor
    #elif defined(WR_FEATURE_DUAL_SOURCE_BLENDING)
        layout(location = 0, index = 0) out vec4 oFragColor;
        layout(location = 0, index = 1) out vec4 oFragBlend;
    #else
        out vec4 oFragColor;
    #endif

    // Write an output color in normal shaders.
    void write_output(vec4 color) {
        oFragColor = color;
    }

    #define EPSILON                     0.0001

    // "Show Overdraw" color. Premultiplied.
    #define WR_DEBUG_OVERDRAW_COLOR     vec4(0.110, 0.077, 0.027, 0.125)

    float distance_to_line(vec2 p0, vec2 perp_dir, vec2 p) {
        vec2 dir_to_p0 = p0 - p;
        return dot(normalize(perp_dir), dir_to_p0);
    }

// fwidth is not defined in ESSL 1, but that's okay because we don't need
// it for any ESSL 1 shader variants.
#if __VERSION__ != 100
    /// Find the appropriate half range to apply the AA approximation over.
    /// This range represents a coefficient to go from one CSS pixel to half a device pixel.
    vec2 compute_aa_range_xy(vec2 position) {
        return fwidth(position);
    }

    float compute_aa_range(vec2 position) {
        // The constant factor is chosen to compensate for the fact that length(fw) is equal
        // to sqrt(2) times the device pixel ratio in the typical case.
        //
        // This coefficient is chosen to ensure that any sample 0.5 pixels or more inside of
        // the shape has no anti-aliasing applied to it (since pixels are sampled at their center,
        // such a pixel (axis aligned) is fully inside the border). We need this so that antialiased
        // curves properly connect with non-antialiased vertical or horizontal lines, among other things.
        //
        // Lines over a half-pixel away from the pixel center *can* intersect with the pixel square;
        // indeed, unless they are horizontal or vertical, they are guaranteed to. However, choosing
        // a nonzero area for such pixels causes noticeable artifacts at the junction between an anti-
        // aliased corner and a straight edge.
        //
        // We may want to adjust this constant in specific scenarios (for example keep the principled
        // value for straight edges where we want pixel-perfect equivalence with non antialiased lines
        // when axis aligned, while selecting a larger and smoother aa range on curves).
        //
        // As a further optimization, we compute the reciprocal of this range, such that we
        // can then use the cheaper inversesqrt() instead of length(). This also elides a
        // division that would otherwise be necessary inside distance_aa.
        #ifdef SWGL
            // SWGL uses an approximation for fwidth() such that it returns equal x and y.
            // Thus, sqrt(2)/length(w) = sqrt(2)/sqrt(x*x + x*x) = recip(x).
            return recip(fwidth(position).x);
        #else
            // sqrt(2)/length(w) = inversesqrt(0.5 * dot(w, w))
            vec2 w = fwidth(position);
            return inversesqrt(0.5 * dot(w, w));
        #endif
    }
#endif

    /// Return the blending coefficient for distance antialiasing.
    ///
    /// 0.0 means inside the shape, 1.0 means outside.
    ///
    /// This makes the simplifying assumption that the area of a 1x1 pixel square
    /// under a line is reasonably similar to just the signed Euclidian distance
    /// from the center of the square to that line. This diverges slightly from
    /// better approximations of the exact area, but the difference between the
    /// methods is not perceptibly noticeable, while this approximation is much
    /// faster to compute.
    ///
    /// See the comments in `compute_aa_range()` for more information on the
    /// cutoff values of -0.5 and 0.5.
    float distance_aa_xy(vec2 aa_range, vec2 signed_distance) {
        // The aa_range is the raw per-axis filter width, so we need to divide
        // the local signed distance by the filter width to get an approximation
        // of screen distance.
        #ifdef SWGL
            // The SWGL fwidth() approximation returns uniform X and Y ranges.
            vec2 dist = signed_distance * recip(aa_range.x);
        #else
            vec2 dist = signed_distance / aa_range;
        #endif
        // Choose whichever axis is further outside the rectangle for AA.
        return clamp(0.5 - max(dist.x, dist.y), 0.0, 1.0);
    }

    float distance_aa(float aa_range, float signed_distance) {
        // The aa_range is already stored as a reciprocal with uniform scale,
        // so just multiply it, then use that for AA.
        float dist = signed_distance * aa_range;
        return clamp(0.5 - dist, 0.0, 1.0);
    }

    /// Component-wise selection.
    ///
    /// The idea of using this is to ensure both potential branches are executed before
    /// selecting the result, to avoid observable timing differences based on the condition.
    ///
    /// Example usage: color = if_then_else(LessThanEqual(color, vec3(0.5)), vec3(0.0), vec3(1.0));
    ///
    /// The above example sets each component to 0.0 or 1.0 independently depending on whether
    /// their values are below or above 0.5.
    ///
    /// This is written as a macro in order to work with vectors of any dimension.
    ///
    /// Note: Some older android devices don't support mix with bvec. If we ever run into them
    /// the only option we have is to polyfill it with a branch per component.
    #define if_then_else(cond, then_branch, else_branch) mix(else_branch, then_branch, cond)
#endif

//======================================================================================
// Shared shader uniforms
//======================================================================================
#ifdef WR_FEATURE_TEXTURE_2D
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sColor2;
#elif defined WR_FEATURE_TEXTURE_RECT
uniform sampler2DRect sColor0;
uniform sampler2DRect sColor1;
uniform sampler2DRect sColor2;
#elif defined(WR_FEATURE_TEXTURE_EXTERNAL) || defined(WR_FEATURE_TEXTURE_EXTERNAL_ESSL1)
uniform samplerExternalOES sColor0;
uniform samplerExternalOES sColor1;
uniform samplerExternalOES sColor2;
#endif

#ifdef WR_FEATURE_DITHERING
uniform sampler2D sDither;
#endif

//======================================================================================
// Interpolator definitions
//======================================================================================

//======================================================================================
// VS only types and UBOs
//======================================================================================

//======================================================================================
// VS only functions
//======================================================================================
shared_other/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

//======================================================================================
// Vertex shader attributes and uniforms
//======================================================================================
#ifdef WR_VERTEX_SHADER
#endif

//======================================================================================
// Fragment shader attributes and uniforms
//======================================================================================
#ifdef WR_FRAGMENT_SHADER
#endif

//======================================================================================
// Interpolator definitions
//======================================================================================

//======================================================================================
// VS only types and UBOs
//======================================================================================

//======================================================================================
// VS only functions
//======================================================================================

//======================================================================================
// FS only functions
//======================================================================================
#ifdef WR_FRAGMENT_SHADER
#endif
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

flat varying vec4 vTransformBounds;

#ifdef WR_VERTEX_SHADER

#define VECS_PER_TRANSFORM   8U
uniform HIGHP_SAMPLER_FLOAT sampler2D sTransformPalette;

void init_transform_vs(vec4 local_bounds) {
    vTransformBounds = local_bounds;
}

struct Transform {
    mat4 m;
    mat4 inv_m;
    bool is_axis_aligned;
};

Transform fetch_transform(int id) {
    Transform transform;

    transform.is_axis_aligned = (id >> 24) == 0;
    int index = id & 0x00ffffff;

    // Create a UV base coord for each 8 texels.
    // This is required because trying to use an offset
    // of more than 8 texels doesn't work on some versions
    // of macOS.
    ivec2 uv = get_fetch_uv(index, VECS_PER_TRANSFORM);
    ivec2 uv0 = ivec2(uv.x + 0, uv.y);

    transform.m[0] = TEXEL_FETCH(sTransformPalette, uv0, 0, ivec2(0, 0));
    transform.m[1] = TEXEL_FETCH(sTransformPalette, uv0, 0, ivec2(1, 0));
    transform.m[2] = TEXEL_FETCH(sTransformPalette, uv0, 0, ivec2(2, 0));
    transform.m[3] = TEXEL_FETCH(sTransformPalette, uv0, 0, ivec2(3, 0));

    transform.inv_m[0] = TEXEL_FETCH(sTransformPalette, uv0, 0, ivec2(4, 0));
    transform.inv_m[1] = TEXEL_FETCH(sTransformPalette, uv0, 0, ivec2(5, 0));
    transform.inv_m[2] = TEXEL_FETCH(sTransformPalette, uv0, 0, ivec2(6, 0));
    transform.inv_m[3] = TEXEL_FETCH(sTransformPalette, uv0, 0, ivec2(7, 0));

    return transform;
}

// Return the intersection of the plane (set up by "normal" and "point")
// with the ray (set up by "ray_origin" and "ray_dir"),
// writing the resulting scaler into "t".
bool ray_plane(vec3 normal, vec3 pt, vec3 ray_origin, vec3 ray_dir, out float t)
{
    float denom = dot(normal, ray_dir);
    if (abs(denom) > 1e-6) {
        vec3 d = pt - ray_origin;
        t = dot(d, normal) / denom;
        return t >= 0.0;
    }

    return false;
}

// Apply the inverse transform "inv_transform"
// to the reference point "ref" in CSS space,
// producing a local point on a Transform plane,
// set by a base point "a" and a normal "n".
vec4 untransform(vec2 ref, vec3 n, vec3 a, mat4 inv_transform) {
    vec3 p = vec3(ref, -10000.0);
    vec3 d = vec3(0, 0, 1.0);

    float t = 0.0;
    // get an intersection of the Transform plane with Z axis vector,
    // originated from the "ref" point
    ray_plane(n, a, p, d, t);
    float z = p.z + d.z * t; // Z of the visible point on the Transform

    vec4 r = inv_transform * vec4(ref, z, 1.0);
    return r;
}

// Given a CSS space position, transform it back into the Transform space.
vec4 get_node_pos(vec2 pos, Transform transform) {
    // get a point on the scroll node plane
    vec4 ah = transform.m * vec4(0.0, 0.0, 0.0, 1.0);
    vec3 a = ah.xyz / ah.w;

    // get the normal to the scroll node plane
    vec3 n = transpose(mat3(transform.inv_m)) * vec3(0.0, 0.0, 1.0);
    return untransform(pos, n, a, transform.inv_m);
}

#endif //WR_VERTEX_SHADER

#ifdef WR_FRAGMENT_SHADER

// Assume transform bounds are set to a large scale to signal they are invalid.
bool has_valid_transform_bounds() {
    return vTransformBounds.w < 1.0e15;
}

float init_transform_fs(vec2 local_pos) {
    // Ideally we want to track distances in screen space after transformation
    // as signed distance calculations lose context about the direction vector
    // to exit the geometry, merely remembering the minimum distance to the
    // exit. However, we can't always sanely track distances in screen space
    // due to perspective transforms, clipping, and other concerns, so we do
    // this in local space. However, this causes problems tracking distances
    // in local space when attempting to scale by a uniform AA range later in
    // the presence of a transform which actually has non-uniform scaling.
    //
    // To work around this, we independently track the distances on the local
    // space X and Y axes and then scale them by the independent AA ranges (as
    // computed from fwidth derivatives) for the X and Y axes. This can break
    // down at certain angles (45 degrees or close to it), but still gives a
    // better approximation of screen-space distances in the presence of non-
    // uniform scaling for other rotations.
    //
    // Get signed distance from local rect bounds.
    vec2 d = signed_distance_rect_xy(
        local_pos,
        vTransformBounds.xy,
        vTransformBounds.zw
    );

    // Find the appropriate distance to apply the AA smoothstep over.
    vec2 aa_range = compute_aa_range_xy(local_pos);

    // Only apply AA to fragments outside the signed distance field.
    return distance_aa_xy(aa_range, d);
}

float init_transform_rough_fs(vec2 local_pos) {
    return point_inside_rect(
        local_pos,
        vTransformBounds.xy,
        vTransformBounds.zw
    );
}

#endif //WR_FRAGMENT_SHADER
yuv/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include shared

#define YUV_FORMAT_NV12             0
#define YUV_FORMAT_P010             1
#define YUV_FORMAT_PLANAR           2
#define YUV_FORMAT_INTERLEAVED      3

//#define YUV_PRECISION mediump
#define YUV_PRECISION

#ifdef WR_VERTEX_SHADER

#ifdef WR_FEATURE_TEXTURE_RECT
    #define TEX_SIZE_YUV(sampler) vec2(1.0)
#else
    #define TEX_SIZE_YUV(sampler) vec2(TEX_SIZE(sampler).xy)
#endif

// `YuvRangedColorSpace`
#define YUV_COLOR_SPACE_REC601_NARROW  0
#define YUV_COLOR_SPACE_REC601_FULL    1
#define YUV_COLOR_SPACE_REC709_NARROW  2
#define YUV_COLOR_SPACE_REC709_FULL    3
#define YUV_COLOR_SPACE_REC2020_NARROW 4
#define YUV_COLOR_SPACE_REC2020_FULL   5
#define YUV_COLOR_SPACE_GBR_IDENTITY   6

// The constants added to the Y, U and V components are applied in the fragment shader.

// `rgbFromYuv` from https://jdashg.github.io/misc/colors/from-coeffs.html
// The matrix is stored in column-major.
const mat3 RgbFromYuv_Rec601 = mat3(
  1.00000, 1.00000, 1.00000,
  0.00000,-0.17207, 0.88600,
  0.70100,-0.35707, 0.00000
);
const mat3 RgbFromYuv_Rec709 = mat3(
  1.00000, 1.00000, 1.00000,
  0.00000,-0.09366, 0.92780,
  0.78740,-0.23406, 0.00000
);
const mat3 RgbFromYuv_Rec2020 = mat3(
  1.00000, 1.00000, 1.00000,
  0.00000,-0.08228, 0.94070,
  0.73730,-0.28568, 0.00000
);

// The matrix is stored in column-major.
// Identity is stored as GBR
const mat3 RgbFromYuv_GbrIdentity = mat3(
    0.0              ,  1.0,                0.0,
    0.0              ,  0.0,                1.0,
    1.0              ,  0.0,                0.0
);

// -

struct YuvPrimitive {
    int channel_bit_depth;
    int color_space;
    int yuv_format;
};

struct YuvColorSamplingInfo {
    mat3 rgb_from_yuv;
    vec4 packed_zero_one_vals;
};

struct YuvColorMatrixInfo {
    vec3 ycbcr_bias;
    mat3 rgb_from_debiased_ycbrc;
};

// -

vec4 yuv_channel_zero_one_identity(int bit_depth, float channel_max) {
    float all_ones_normalized = float((1 << bit_depth) - 1) / channel_max;
    return vec4(0.0, 0.0, all_ones_normalized, all_ones_normalized);
}

vec4 yuv_channel_zero_one_narrow_range(int bit_depth, float channel_max) {
    // Note: 512/1023 != 128/255
    ivec4 zero_one_ints = ivec4(16, 128, 235, 240) << (bit_depth - 8);
    return vec4(zero_one_ints) / channel_max;
}

vec4 yuv_channel_zero_one_full_range(int bit_depth, float channel_max) {
    vec4 narrow = yuv_channel_zero_one_narrow_range(bit_depth, channel_max);
    vec4 identity = yuv_channel_zero_one_identity(bit_depth, channel_max);
    return vec4(0.0, narrow.y, identity.z, identity.w);
}

YuvColorSamplingInfo get_yuv_color_info(YuvPrimitive prim) {
    float channel_max = 255.0;
    if (prim.channel_bit_depth > 8) {
        if (prim.yuv_format == YUV_FORMAT_P010) {
            // This is an MSB format.
            channel_max = float((1 << prim.channel_bit_depth) - 1);
        } else {
            // For >8bpc, we get the low bits, not the high bits:
            // 10bpc(1.0): 0b0000_0011_1111_1111
            channel_max = 65535.0;
        }
    }
    if (prim.color_space == YUV_COLOR_SPACE_REC601_NARROW) {
        return YuvColorSamplingInfo(RgbFromYuv_Rec601,
                yuv_channel_zero_one_narrow_range(prim.channel_bit_depth, channel_max));
    } else if (prim.color_space == YUV_COLOR_SPACE_REC601_FULL) {
        return YuvColorSamplingInfo(RgbFromYuv_Rec601,
                yuv_channel_zero_one_full_range(prim.channel_bit_depth, channel_max));

    } else if (prim.color_space == YUV_COLOR_SPACE_REC709_NARROW) {
        return YuvColorSamplingInfo(RgbFromYuv_Rec709,
                yuv_channel_zero_one_narrow_range(prim.channel_bit_depth, channel_max));
    } else if (prim.color_space == YUV_COLOR_SPACE_REC709_FULL) {
        return YuvColorSamplingInfo(RgbFromYuv_Rec709,
                yuv_channel_zero_one_full_range(prim.channel_bit_depth, channel_max));

    } else if (prim.color_space == YUV_COLOR_SPACE_REC2020_NARROW) {
        return YuvColorSamplingInfo(RgbFromYuv_Rec2020,
                yuv_channel_zero_one_narrow_range(prim.channel_bit_depth, channel_max));
    } else if (prim.color_space == YUV_COLOR_SPACE_REC2020_FULL) {
        return YuvColorSamplingInfo(RgbFromYuv_Rec2020,
                yuv_channel_zero_one_full_range(prim.channel_bit_depth, channel_max));

    } else {
        // Identity
        return YuvColorSamplingInfo(RgbFromYuv_GbrIdentity,
                yuv_channel_zero_one_identity(prim.channel_bit_depth, channel_max));
    }
}

YuvColorMatrixInfo get_rgb_from_ycbcr_info(YuvPrimitive prim) {
    YuvColorSamplingInfo info = get_yuv_color_info(prim);

    vec2 zero = info.packed_zero_one_vals.xy;
    vec2 one = info.packed_zero_one_vals.zw;
    // Such that yuv_value = (ycbcr_sample - zero) / (one - zero)
    vec2 scale = 1.0 / (one - zero);

    YuvColorMatrixInfo mat_info;
    mat_info.ycbcr_bias = zero.xyy;
    mat3 yuv_from_debiased_ycbcr = mat3(scale.x,     0.0,     0.0,
                                            0.0, scale.y,     0.0,
                                            0.0,     0.0, scale.y);
    mat_info.rgb_from_debiased_ycbrc = info.rgb_from_yuv * yuv_from_debiased_ycbcr;
    return mat_info;
}

void write_uv_rect(
    vec2 uv0,
    vec2 uv1,
    vec2 f,
    vec2 texture_size,
    out vec2 uv,
    out vec4 uv_bounds
) {
    uv = mix(uv0, uv1, f);

    uv_bounds = vec4(uv0 + vec2(0.5), uv1 - vec2(0.5));

    #ifndef WR_FEATURE_TEXTURE_RECT
        uv /= texture_size;
        uv_bounds /= texture_size.xyxy;
    #endif
}
#endif

#ifdef WR_FRAGMENT_SHADER

vec4 sample_yuv(
    int format,
    YUV_PRECISION vec3 ycbcr_bias,
    YUV_PRECISION mat3 rgb_from_debiased_ycbrc,
    vec2 in_uv_y,
    vec2 in_uv_u,
    vec2 in_uv_v,
    vec4 uv_bounds_y,
    vec4 uv_bounds_u,
    vec4 uv_bounds_v
) {
    YUV_PRECISION vec3 ycbcr_sample;

    switch (format) {
        case YUV_FORMAT_PLANAR:
            {
                // The yuv_planar format should have this third texture coordinate.
                vec2 uv_y = clamp(in_uv_y, uv_bounds_y.xy, uv_bounds_y.zw);
                vec2 uv_u = clamp(in_uv_u, uv_bounds_u.xy, uv_bounds_u.zw);
                vec2 uv_v = clamp(in_uv_v, uv_bounds_v.xy, uv_bounds_v.zw);
                ycbcr_sample.x = TEX_SAMPLE(sColor0, uv_y).r;
                ycbcr_sample.y = TEX_SAMPLE(sColor1, uv_u).r;
                ycbcr_sample.z = TEX_SAMPLE(sColor2, uv_v).r;
            }
            break;

        case YUV_FORMAT_NV12:
        case YUV_FORMAT_P010:
            {
                vec2 uv_y = clamp(in_uv_y, uv_bounds_y.xy, uv_bounds_y.zw);
                vec2 uv_uv = clamp(in_uv_u, uv_bounds_u.xy, uv_bounds_u.zw);
                ycbcr_sample.x = TEX_SAMPLE(sColor0, uv_y).r;
                ycbcr_sample.yz = TEX_SAMPLE(sColor1, uv_uv).rg;
            }
            break;

        case YUV_FORMAT_INTERLEAVED:
            {
                // "The Y, Cb and Cr color channels within the 422 data are mapped into
                // the existing green, blue and red color channels."
                // https://www.khronos.org/registry/OpenGL/extensions/APPLE/APPLE_rgb_422.txt
                vec2 uv_y = clamp(in_uv_y, uv_bounds_y.xy, uv_bounds_y.zw);
                ycbcr_sample = TEX_SAMPLE(sColor0, uv_y).gbr;
            }
            break;

        default:
            ycbcr_sample = vec3(0.0);
            break;
    }
    //if (true) return vec4(ycbcr_sample, 1.0);

    // See the YuvColorMatrix definition for an explanation of where the constants come from.
    YUV_PRECISION vec3 rgb = rgb_from_debiased_ycbrc * (ycbcr_sample - ycbcr_bias);

    #if defined(WR_FEATURE_ALPHA_PASS) && defined(SWGL_CLIP_MASK)
        // Avoid out-of-range RGB values that can mess with blending. These occur due to invalid
        // YUV values outside the mappable space that never the less can be generated.
        rgb = clamp(rgb, 0.0, 1.0);
    #endif
    return vec4(rgb, 1.0);
}
#endif
#version 150
// brush_blend
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_uv;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective_amount;
flat out ivec2 v_op_table_address_vec;
flat out mat4 v_color_mat;
flat out vec4 v_funcs;
flat out vec4 v_color_offset;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  ivec2 tmpvar_40;
  tmpvar_40.x = int((uint(tmpvar_12.x) % 1024u));
  tmpvar_40.y = int((uint(tmpvar_12.x) / 1024u));
  vec4 tmpvar_41;
  tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
  vec2 tmpvar_42;
  tmpvar_42 = (1.0/(vec2(textureSize (sColor0, 0))));
  vec2 tmpvar_43;
  tmpvar_43 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  int tmpvar_44;
  tmpvar_44 = (tmpvar_12.x + 2);
  ivec2 tmpvar_45;
  tmpvar_45.x = int((uint(tmpvar_44) % 1024u));
  tmpvar_45.y = int((uint(tmpvar_44) / 1024u));
  vec4 tmpvar_46;
  tmpvar_46 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(1, 0)), tmpvar_43.x), mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(3, 0)), tmpvar_43.x), tmpvar_43.y);
  vec2 tmpvar_47;
  tmpvar_47 = mix (tmpvar_41.xy, tmpvar_41.zw, (tmpvar_46.xy / tmpvar_46.w));
  float tmpvar_48;
  if (((tmpvar_27 & 1) != 0)) {
    tmpvar_48 = 1.0;
  } else {
    tmpvar_48 = 0.0;
  };
  v_uv = ((tmpvar_47 * tmpvar_42) * mix (tmpvar_38.w, 1.0, tmpvar_48));
  v_perspective_amount.x = tmpvar_48;
  vec4 tmpvar_49;
  tmpvar_49.xy = (tmpvar_41.xy + vec2(0.5, 0.5));
  tmpvar_49.zw = (tmpvar_41.zw - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_49 * tmpvar_42.xyxy);
  float tmpvar_50;
  tmpvar_50 = (float(tmpvar_12.z) / 65536.0);
  v_op_table_address_vec.x = (tmpvar_12.y & 65535);
  v_perspective_amount.y = tmpvar_50;
  v_funcs.x = float(((tmpvar_12.y >> 28) & 15));
  v_funcs.y = float(((tmpvar_12.y >> 24) & 15));
  v_funcs.z = float(((tmpvar_12.y >> 20) & 15));
  v_funcs.w = float(((tmpvar_12.y >> 16) & 15));
  int tmpvar_51;
  tmpvar_51 = tmpvar_12.z;
  vec4 tmpvar_52;
  mat4 tmpvar_53;
  int tmpvar_54;
  float tmpvar_55;
  tmpvar_55 = (1.0 - tmpvar_50);
  if ((v_op_table_address_vec.x == 1)) {
    vec4 tmpvar_56;
    tmpvar_56.w = 0.0;
    tmpvar_56.x = (0.2126 + (0.7874 * tmpvar_55));
    tmpvar_56.y = (0.2126 - (0.2126 * tmpvar_55));
    tmpvar_56.z = (0.2126 - (0.2126 * tmpvar_55));
    vec4 tmpvar_57;
    tmpvar_57.w = 0.0;
    tmpvar_57.x = (0.7152 - (0.7152 * tmpvar_55));
    tmpvar_57.y = (0.7152 + (0.2848 * tmpvar_55));
    tmpvar_57.z = (0.7152 - (0.7152 * tmpvar_55));
    vec4 tmpvar_58;
    tmpvar_58.w = 0.0;
    tmpvar_58.x = (0.0722 - (0.0722 * tmpvar_55));
    tmpvar_58.y = (0.0722 - (0.0722 * tmpvar_55));
    tmpvar_58.z = (0.0722 + (0.9278 * tmpvar_55));
    mat4 tmpvar_59;
    tmpvar_59[uint(0)] = tmpvar_56;
    tmpvar_59[1u] = tmpvar_57;
    tmpvar_59[2u] = tmpvar_58;
    tmpvar_59[3u] = vec4(0.0, 0.0, 0.0, 1.0);
    tmpvar_53 = tmpvar_59;
    tmpvar_52 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    if ((v_op_table_address_vec.x == 2)) {
      float tmpvar_60;
      tmpvar_60 = cos(tmpvar_50);
      float tmpvar_61;
      tmpvar_61 = sin(tmpvar_50);
      vec4 tmpvar_62;
      tmpvar_62.w = 0.0;
      tmpvar_62.x = ((0.2126 + (0.7874 * tmpvar_60)) - (0.2126 * tmpvar_61));
      tmpvar_62.y = ((0.2126 - (0.2126 * tmpvar_60)) + (0.143 * tmpvar_61));
      tmpvar_62.z = ((0.2126 - (0.2126 * tmpvar_60)) - (0.7874 * tmpvar_61));
      vec4 tmpvar_63;
      tmpvar_63.w = 0.0;
      tmpvar_63.x = ((0.7152 - (0.7152 * tmpvar_60)) - (0.7152 * tmpvar_61));
      tmpvar_63.y = ((0.7152 + (0.2848 * tmpvar_60)) + (0.14 * tmpvar_61));
      tmpvar_63.z = ((0.7152 - (0.7152 * tmpvar_60)) + (0.7152 * tmpvar_61));
      vec4 tmpvar_64;
      tmpvar_64.w = 0.0;
      tmpvar_64.x = ((0.0722 - (0.0722 * tmpvar_60)) + (0.9278 * tmpvar_61));
      tmpvar_64.y = ((0.0722 - (0.0722 * tmpvar_60)) - (0.283 * tmpvar_61));
      tmpvar_64.z = ((0.0722 + (0.9278 * tmpvar_60)) + (0.0722 * tmpvar_61));
      mat4 tmpvar_65;
      tmpvar_65[uint(0)] = tmpvar_62;
      tmpvar_65[1u] = tmpvar_63;
      tmpvar_65[2u] = tmpvar_64;
      tmpvar_65[3u] = vec4(0.0, 0.0, 0.0, 1.0);
      tmpvar_53 = tmpvar_65;
      tmpvar_52 = vec4(0.0, 0.0, 0.0, 0.0);
    } else {
      if ((v_op_table_address_vec.x == 4)) {
        vec4 tmpvar_66;
        tmpvar_66.w = 0.0;
        tmpvar_66.x = ((tmpvar_55 * 0.2126) + tmpvar_50);
        tmpvar_66.y = (tmpvar_55 * 0.2126);
        tmpvar_66.z = (tmpvar_55 * 0.2126);
        vec4 tmpvar_67;
        tmpvar_67.w = 0.0;
        tmpvar_67.x = (tmpvar_55 * 0.7152);
        tmpvar_67.y = ((tmpvar_55 * 0.7152) + tmpvar_50);
        tmpvar_67.z = (tmpvar_55 * 0.7152);
        vec4 tmpvar_68;
        tmpvar_68.w = 0.0;
        tmpvar_68.x = (tmpvar_55 * 0.0722);
        tmpvar_68.y = (tmpvar_55 * 0.0722);
        tmpvar_68.z = ((tmpvar_55 * 0.0722) + tmpvar_50);
        mat4 tmpvar_69;
        tmpvar_69[uint(0)] = tmpvar_66;
        tmpvar_69[1u] = tmpvar_67;
        tmpvar_69[2u] = tmpvar_68;
        tmpvar_69[3u] = vec4(0.0, 0.0, 0.0, 1.0);
        tmpvar_53 = tmpvar_69;
        tmpvar_52 = vec4(0.0, 0.0, 0.0, 0.0);
      } else {
        if ((v_op_table_address_vec.x == 5)) {
          vec4 tmpvar_70;
          tmpvar_70.w = 0.0;
          tmpvar_70.x = (0.393 + (0.607 * tmpvar_55));
          tmpvar_70.y = (0.349 - (0.349 * tmpvar_55));
          tmpvar_70.z = (0.272 - (0.272 * tmpvar_55));
          vec4 tmpvar_71;
          tmpvar_71.w = 0.0;
          tmpvar_71.x = (0.769 - (0.769 * tmpvar_55));
          tmpvar_71.y = (0.686 + (0.314 * tmpvar_55));
          tmpvar_71.z = (0.534 - (0.534 * tmpvar_55));
          vec4 tmpvar_72;
          tmpvar_72.w = 0.0;
          tmpvar_72.x = (0.189 - (0.189 * tmpvar_55));
          tmpvar_72.y = (0.168 - (0.168 * tmpvar_55));
          tmpvar_72.z = (0.131 + (0.869 * tmpvar_55));
          mat4 tmpvar_73;
          tmpvar_73[uint(0)] = tmpvar_70;
          tmpvar_73[1u] = tmpvar_71;
          tmpvar_73[2u] = tmpvar_72;
          tmpvar_73[3u] = vec4(0.0, 0.0, 0.0, 1.0);
          tmpvar_53 = tmpvar_73;
          tmpvar_52 = vec4(0.0, 0.0, 0.0, 0.0);
        } else {
          if ((v_op_table_address_vec.x == 7)) {
            ivec2 tmpvar_74;
            tmpvar_74.x = int((uint(tmpvar_12.z) % 1024u));
            tmpvar_74.y = int((uint(tmpvar_12.z) / 1024u));
            int tmpvar_75;
            tmpvar_75 = (tmpvar_12.z + 4);
            ivec2 tmpvar_76;
            tmpvar_76.x = int((uint(tmpvar_75) % 1024u));
            tmpvar_76.y = int((uint(tmpvar_75) / 1024u));
            mat4 tmpvar_77;
            tmpvar_77[uint(0)] = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(0, 0));
            tmpvar_77[1u] = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(1, 0));
            tmpvar_77[2u] = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(2, 0));
            tmpvar_77[3u] = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(3, 0));
            tmpvar_53 = tmpvar_77;
            tmpvar_52 = texelFetch (sGpuCache, tmpvar_76, 0);
          } else {
            if ((v_op_table_address_vec.x == 11)) {
              tmpvar_54 = tmpvar_51;
            } else {
              if ((v_op_table_address_vec.x == 10)) {
                ivec2 tmpvar_78;
                tmpvar_78.x = int((uint(tmpvar_12.z) % 1024u));
                tmpvar_78.y = int((uint(tmpvar_12.z) / 1024u));
                tmpvar_52 = texelFetch (sGpuCache, tmpvar_78, 0);
              };
            };
          };
        };
      };
    };
  };
  v_color_offset = tmpvar_52;
  v_color_mat = tmpvar_53;
  v_op_table_address_vec.y = tmpvar_54;
}

#version 150
// brush_blend
// features: []

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sGpuCache;
in vec2 v_uv;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective_amount;
flat in ivec2 v_op_table_address_vec;
flat in mat4 v_color_mat;
flat in vec4 v_funcs;
flat in vec4 v_color_offset;
void main ()
{
  vec4 tmpvar_1;
  tmpvar_1 = texture (sColor0, min (max ((v_uv * 
    mix (gl_FragCoord.w, 1.0, v_perspective_amount.x)
  ), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  vec3 tmpvar_2;
  float tmpvar_3;
  tmpvar_3 = tmpvar_1.w;
  vec3 tmpvar_4;
  if ((tmpvar_1.w != 0.0)) {
    tmpvar_4 = (tmpvar_1.xyz / tmpvar_1.w);
  } else {
    tmpvar_4 = tmpvar_1.xyz;
  };
  tmpvar_2 = tmpvar_4;
  bool tmpvar_5;
  bool tmpvar_6;
  tmpvar_6 = bool(0);
  tmpvar_5 = (0 == v_op_table_address_vec.x);
  if (tmpvar_5) {
    tmpvar_2 = min (max ((
      ((tmpvar_4 * v_perspective_amount.y) - (0.5 * v_perspective_amount.y))
     + 0.5), 0.0), 1.0);
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (3 == v_op_table_address_vec.x));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    tmpvar_2 = mix (tmpvar_2, (vec3(1.0, 1.0, 1.0) - tmpvar_2), v_perspective_amount.y);
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (6 == v_op_table_address_vec.x));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    tmpvar_2 = min (max ((tmpvar_2 * v_perspective_amount.y), 0.0), 1.0);
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (8 == v_op_table_address_vec.x));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    tmpvar_2 = mix(pow ((
      (tmpvar_2 / 1.055)
     + vec3(0.0521327, 0.0521327, 0.0521327)), vec3(2.4, 2.4, 2.4)), (tmpvar_2 / 12.92), bvec3(greaterThanEqual (vec3(0.04045, 0.04045, 0.04045), tmpvar_2)));
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (9 == v_op_table_address_vec.x));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    tmpvar_2 = mix(((vec3(1.055, 1.055, 1.055) * 
      pow (tmpvar_2, vec3(0.4166667, 0.4166667, 0.4166667))
    ) - vec3(0.055, 0.055, 0.055)), (tmpvar_2 * 12.92), bvec3(greaterThanEqual (vec3(0.0031308, 0.0031308, 0.0031308), tmpvar_2)));
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (11 == v_op_table_address_vec.x));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    vec4 tmpvar_7;
    tmpvar_7.xyz = tmpvar_2;
    tmpvar_7.w = tmpvar_3;
    vec4 tmpvar_8;
    tmpvar_8 = tmpvar_7;
    int k_9;
    int offset_10;
    offset_10 = 0;
    int tmpvar_11;
    int tmpvar_12;
    int tmpvar_13;
    int tmpvar_14;
    tmpvar_11 = int(v_funcs.x);
    tmpvar_12 = int(v_funcs.y);
    tmpvar_13 = int(v_funcs.z);
    tmpvar_14 = int(v_funcs.w);
    bool tmpvar_15;
    bool tmpvar_16;
    tmpvar_16 = bool(0);
    tmpvar_15 = (0 == tmpvar_11);
    if (tmpvar_15) {
      tmpvar_16 = bool(1);
    };
    tmpvar_15 = (tmpvar_15 || (1 == tmpvar_11));
    tmpvar_15 = (tmpvar_15 || (2 == tmpvar_11));
    tmpvar_15 = (tmpvar_15 && !(tmpvar_16));
    if (tmpvar_15) {
      k_9 = int(floor((
        (tmpvar_7[0] * 255.0)
       + 0.5)));
      int tmpvar_17;
      tmpvar_17 = (v_op_table_address_vec.y + (k_9 / 4));
      ivec2 tmpvar_18;
      tmpvar_18.x = int((uint(tmpvar_17) % 1024u));
      tmpvar_18.y = int((uint(tmpvar_17) / 1024u));
      vec4 tmpvar_19;
      tmpvar_19 = texelFetch (sGpuCache, tmpvar_18, 0);
      tmpvar_8[0] = min (max (tmpvar_19[(k_9 % 4)], 0.0), 1.0);
      offset_10 = 64;
      tmpvar_16 = bool(1);
    };
    tmpvar_15 = (tmpvar_15 || (3 == tmpvar_11));
    tmpvar_15 = (tmpvar_15 && !(tmpvar_16));
    if (tmpvar_15) {
      int tmpvar_20;
      tmpvar_20 = (v_op_table_address_vec.y + offset_10);
      ivec2 tmpvar_21;
      tmpvar_21.x = int((uint(tmpvar_20) % 1024u));
      tmpvar_21.y = int((uint(tmpvar_20) / 1024u));
      vec4 tmpvar_22;
      tmpvar_22 = texelFetch (sGpuCache, tmpvar_21, 0);
      tmpvar_8[0] = min (max ((
        (tmpvar_22[0] * tmpvar_8[0])
       + tmpvar_22[1]), 0.0), 1.0);
      offset_10++;
      tmpvar_16 = bool(1);
    };
    tmpvar_15 = (tmpvar_15 || (4 == tmpvar_11));
    tmpvar_15 = (tmpvar_15 && !(tmpvar_16));
    if (tmpvar_15) {
      int tmpvar_23;
      tmpvar_23 = (v_op_table_address_vec.y + offset_10);
      ivec2 tmpvar_24;
      tmpvar_24.x = int((uint(tmpvar_23) % 1024u));
      tmpvar_24.y = int((uint(tmpvar_23) / 1024u));
      vec4 tmpvar_25;
      tmpvar_25 = texelFetch (sGpuCache, tmpvar_24, 0);
      tmpvar_8[0] = min (max ((
        (tmpvar_25[0] * pow (tmpvar_8[0], tmpvar_25[1]))
       + tmpvar_25[2]), 0.0), 1.0);
      offset_10++;
      tmpvar_16 = bool(1);
    };
    tmpvar_15 = !(tmpvar_16);
    if (tmpvar_15) {
      tmpvar_16 = bool(1);
    };
    bool tmpvar_26;
    bool tmpvar_27;
    tmpvar_27 = bool(0);
    tmpvar_26 = (0 == tmpvar_12);
    if (tmpvar_26) {
      tmpvar_27 = bool(1);
    };
    tmpvar_26 = (tmpvar_26 || (1 == tmpvar_12));
    tmpvar_26 = (tmpvar_26 || (2 == tmpvar_12));
    tmpvar_26 = (tmpvar_26 && !(tmpvar_27));
    if (tmpvar_26) {
      k_9 = int(floor((
        (tmpvar_8[1] * 255.0)
       + 0.5)));
      int tmpvar_28;
      tmpvar_28 = ((v_op_table_address_vec.y + offset_10) + (k_9 / 4));
      ivec2 tmpvar_29;
      tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
      tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
      vec4 tmpvar_30;
      tmpvar_30 = texelFetch (sGpuCache, tmpvar_29, 0);
      tmpvar_8[1] = min (max (tmpvar_30[(k_9 % 4)], 0.0), 1.0);
      offset_10 += 64;
      tmpvar_27 = bool(1);
    };
    tmpvar_26 = (tmpvar_26 || (3 == tmpvar_12));
    tmpvar_26 = (tmpvar_26 && !(tmpvar_27));
    if (tmpvar_26) {
      int tmpvar_31;
      tmpvar_31 = (v_op_table_address_vec.y + offset_10);
      ivec2 tmpvar_32;
      tmpvar_32.x = int((uint(tmpvar_31) % 1024u));
      tmpvar_32.y = int((uint(tmpvar_31) / 1024u));
      vec4 tmpvar_33;
      tmpvar_33 = texelFetch (sGpuCache, tmpvar_32, 0);
      tmpvar_8[1] = min (max ((
        (tmpvar_33[0] * tmpvar_8[1])
       + tmpvar_33[1]), 0.0), 1.0);
      offset_10++;
      tmpvar_27 = bool(1);
    };
    tmpvar_26 = (tmpvar_26 || (4 == tmpvar_12));
    tmpvar_26 = (tmpvar_26 && !(tmpvar_27));
    if (tmpvar_26) {
      int tmpvar_34;
      tmpvar_34 = (v_op_table_address_vec.y + offset_10);
      ivec2 tmpvar_35;
      tmpvar_35.x = int((uint(tmpvar_34) % 1024u));
      tmpvar_35.y = int((uint(tmpvar_34) / 1024u));
      vec4 tmpvar_36;
      tmpvar_36 = texelFetch (sGpuCache, tmpvar_35, 0);
      tmpvar_8[1] = min (max ((
        (tmpvar_36[0] * pow (tmpvar_8[1], tmpvar_36[1]))
       + tmpvar_36[2]), 0.0), 1.0);
      offset_10++;
      tmpvar_27 = bool(1);
    };
    tmpvar_26 = !(tmpvar_27);
    if (tmpvar_26) {
      tmpvar_27 = bool(1);
    };
    bool tmpvar_37;
    bool tmpvar_38;
    tmpvar_38 = bool(0);
    tmpvar_37 = (0 == tmpvar_13);
    if (tmpvar_37) {
      tmpvar_38 = bool(1);
    };
    tmpvar_37 = (tmpvar_37 || (1 == tmpvar_13));
    tmpvar_37 = (tmpvar_37 || (2 == tmpvar_13));
    tmpvar_37 = (tmpvar_37 && !(tmpvar_38));
    if (tmpvar_37) {
      k_9 = int(floor((
        (tmpvar_8[2] * 255.0)
       + 0.5)));
      int tmpvar_39;
      tmpvar_39 = ((v_op_table_address_vec.y + offset_10) + (k_9 / 4));
      ivec2 tmpvar_40;
      tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
      tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
      vec4 tmpvar_41;
      tmpvar_41 = texelFetch (sGpuCache, tmpvar_40, 0);
      tmpvar_8[2] = min (max (tmpvar_41[(k_9 % 4)], 0.0), 1.0);
      offset_10 += 64;
      tmpvar_38 = bool(1);
    };
    tmpvar_37 = (tmpvar_37 || (3 == tmpvar_13));
    tmpvar_37 = (tmpvar_37 && !(tmpvar_38));
    if (tmpvar_37) {
      int tmpvar_42;
      tmpvar_42 = (v_op_table_address_vec.y + offset_10);
      ivec2 tmpvar_43;
      tmpvar_43.x = int((uint(tmpvar_42) % 1024u));
      tmpvar_43.y = int((uint(tmpvar_42) / 1024u));
      vec4 tmpvar_44;
      tmpvar_44 = texelFetch (sGpuCache, tmpvar_43, 0);
      tmpvar_8[2] = min (max ((
        (tmpvar_44[0] * tmpvar_8[2])
       + tmpvar_44[1]), 0.0), 1.0);
      offset_10++;
      tmpvar_38 = bool(1);
    };
    tmpvar_37 = (tmpvar_37 || (4 == tmpvar_13));
    tmpvar_37 = (tmpvar_37 && !(tmpvar_38));
    if (tmpvar_37) {
      int tmpvar_45;
      tmpvar_45 = (v_op_table_address_vec.y + offset_10);
      ivec2 tmpvar_46;
      tmpvar_46.x = int((uint(tmpvar_45) % 1024u));
      tmpvar_46.y = int((uint(tmpvar_45) / 1024u));
      vec4 tmpvar_47;
      tmpvar_47 = texelFetch (sGpuCache, tmpvar_46, 0);
      tmpvar_8[2] = min (max ((
        (tmpvar_47[0] * pow (tmpvar_8[2], tmpvar_47[1]))
       + tmpvar_47[2]), 0.0), 1.0);
      offset_10++;
      tmpvar_38 = bool(1);
    };
    tmpvar_37 = !(tmpvar_38);
    if (tmpvar_37) {
      tmpvar_38 = bool(1);
    };
    bool tmpvar_48;
    bool tmpvar_49;
    tmpvar_49 = bool(0);
    tmpvar_48 = (0 == tmpvar_14);
    if (tmpvar_48) {
      tmpvar_49 = bool(1);
    };
    tmpvar_48 = (tmpvar_48 || (1 == tmpvar_14));
    tmpvar_48 = (tmpvar_48 || (2 == tmpvar_14));
    tmpvar_48 = (tmpvar_48 && !(tmpvar_49));
    if (tmpvar_48) {
      k_9 = int(floor((
        (tmpvar_8[3] * 255.0)
       + 0.5)));
      int tmpvar_50;
      tmpvar_50 = ((v_op_table_address_vec.y + offset_10) + (k_9 / 4));
      ivec2 tmpvar_51;
      tmpvar_51.x = int((uint(tmpvar_50) % 1024u));
      tmpvar_51.y = int((uint(tmpvar_50) / 1024u));
      vec4 tmpvar_52;
      tmpvar_52 = texelFetch (sGpuCache, tmpvar_51, 0);
      tmpvar_8[3] = min (max (tmpvar_52[(k_9 % 4)], 0.0), 1.0);
      offset_10 += 64;
      tmpvar_49 = bool(1);
    };
    tmpvar_48 = (tmpvar_48 || (3 == tmpvar_14));
    tmpvar_48 = (tmpvar_48 && !(tmpvar_49));
    if (tmpvar_48) {
      int tmpvar_53;
      tmpvar_53 = (v_op_table_address_vec.y + offset_10);
      ivec2 tmpvar_54;
      tmpvar_54.x = int((uint(tmpvar_53) % 1024u));
      tmpvar_54.y = int((uint(tmpvar_53) / 1024u));
      vec4 tmpvar_55;
      tmpvar_55 = texelFetch (sGpuCache, tmpvar_54, 0);
      tmpvar_8[3] = min (max ((
        (tmpvar_55[0] * tmpvar_8[3])
       + tmpvar_55[1]), 0.0), 1.0);
      offset_10++;
      tmpvar_49 = bool(1);
    };
    tmpvar_48 = (tmpvar_48 || (4 == tmpvar_14));
    tmpvar_48 = (tmpvar_48 && !(tmpvar_49));
    if (tmpvar_48) {
      int tmpvar_56;
      tmpvar_56 = (v_op_table_address_vec.y + offset_10);
      ivec2 tmpvar_57;
      tmpvar_57.x = int((uint(tmpvar_56) % 1024u));
      tmpvar_57.y = int((uint(tmpvar_56) / 1024u));
      vec4 tmpvar_58;
      tmpvar_58 = texelFetch (sGpuCache, tmpvar_57, 0);
      tmpvar_8[3] = min (max ((
        (tmpvar_58[0] * pow (tmpvar_8[3], tmpvar_58[1]))
       + tmpvar_58[2]), 0.0), 1.0);
      offset_10++;
      tmpvar_49 = bool(1);
    };
    tmpvar_48 = !(tmpvar_49);
    if (tmpvar_48) {
      tmpvar_49 = bool(1);
    };
    tmpvar_2 = tmpvar_8.xyz;
    tmpvar_3 = tmpvar_8.w;
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (10 == v_op_table_address_vec.x));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    tmpvar_2 = v_color_offset.xyz;
    tmpvar_3 = v_color_offset.w;
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = !(tmpvar_6);
  if (tmpvar_5) {
    vec4 tmpvar_59;
    tmpvar_59.xyz = tmpvar_2;
    tmpvar_59.w = tmpvar_3;
    vec4 tmpvar_60;
    tmpvar_60 = min (max ((
      (v_color_mat * tmpvar_59)
     + v_color_offset), 0.0), 1.0);
    tmpvar_2 = tmpvar_60.xyz;
    tmpvar_3 = tmpvar_60.w;
  };
  vec4 tmpvar_61;
  tmpvar_61.w = 1.0;
  tmpvar_61.xyz = tmpvar_2;
  oFragColor = (tmpvar_3 * tmpvar_61);
}

brush_blend_ALPHA_PASS#version 150
// brush_blend
// features: ["ALPHA_PASS"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective_amount;
flat out ivec2 v_op_table_address_vec;
flat out mat4 v_color_mat;
flat out vec4 v_funcs;
flat out vec4 v_color_offset;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  vec2 tmpvar_11;
  vec2 tmpvar_12;
  tmpvar_11 = tmpvar_8.xy;
  tmpvar_12 = tmpvar_8.zw;
  ivec2 tmpvar_13;
  tmpvar_13.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_13.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(0, 0));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_14.x);
  mat4 transform_m_16;
  bool transform_is_axis_aligned_17;
  transform_is_axis_aligned_17 = ((tmpvar_14.z >> 24) == 0);
  int tmpvar_18;
  tmpvar_18 = (tmpvar_14.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_16[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_16[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_16[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_16[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  ivec2 tmpvar_20;
  tmpvar_20.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_20.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_21;
  tmpvar_21 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(0, 0));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_23;
  float area_device_pixel_scale_24;
  vec2 area_screen_origin_25;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_23 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_24 = 0.0;
    area_screen_origin_25 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_26;
    tmpvar_26.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_26.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_27;
    tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
    area_task_rect_23.p0 = tmpvar_27.xy;
    area_task_rect_23.p1 = tmpvar_27.zw;
    area_device_pixel_scale_24 = tmpvar_28.x;
    area_screen_origin_25 = tmpvar_28.yz;
  };
  vec2 tmpvar_29;
  vec2 tmpvar_30;
  tmpvar_29 = tmpvar_11;
  tmpvar_30 = tmpvar_12;
  vec2 adjusted_segment_rect_p0_31;
  vec2 adjusted_segment_rect_p1_32;
  vec2 segment_rect_p0_33;
  vec2 segment_rect_p1_34;
  int tmpvar_35;
  tmpvar_35 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_36;
  tmpvar_36 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_33 = tmpvar_9;
    segment_rect_p1_34 = tmpvar_10;
  } else {
    int tmpvar_37;
    tmpvar_37 = ((tmpvar_14.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_38;
    tmpvar_38.x = int((uint(tmpvar_37) % 1024u));
    tmpvar_38.y = int((uint(tmpvar_37) / 1024u));
    vec4 tmpvar_39;
    tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_38, 0, ivec2(0, 0));
    segment_rect_p0_33 = (tmpvar_39.xy + tmpvar_7.xy);
    segment_rect_p1_34 = (tmpvar_39.zw + tmpvar_7.xy);
  };
  adjusted_segment_rect_p0_31 = segment_rect_p0_33;
  adjusted_segment_rect_p1_32 = segment_rect_p1_34;
  if ((!(transform_is_axis_aligned_17) || ((tmpvar_36 & 256) != 0))) {
    vec2 tmpvar_40;
    tmpvar_40 = min (max (segment_rect_p0_33, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_41;
    tmpvar_41 = min (max (segment_rect_p1_34, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_42;
    tmpvar_42.x = bool((tmpvar_35 & 1));
    tmpvar_42.y = bool((tmpvar_35 & 2));
    tmpvar_42.z = bool((tmpvar_35 & 4));
    tmpvar_42.w = bool((tmpvar_35 & 8));
    vec4 tmpvar_43;
    tmpvar_43.xy = tmpvar_40;
    tmpvar_43.zw = tmpvar_41;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_43, bvec4(tmpvar_42));
    vec4 tmpvar_44;
    tmpvar_44 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_42));
    adjusted_segment_rect_p0_31 = (tmpvar_40 - tmpvar_44.xy);
    adjusted_segment_rect_p1_32 = (tmpvar_41 + tmpvar_44.zw);
    tmpvar_29 = vec2(-1e+16, -1e+16);
    tmpvar_30 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_45;
  tmpvar_45 = min (max (mix (adjusted_segment_rect_p0_31, adjusted_segment_rect_p1_32, aPosition), tmpvar_29), tmpvar_30);
  vec4 tmpvar_46;
  tmpvar_46.zw = vec2(0.0, 1.0);
  tmpvar_46.xy = tmpvar_45;
  vec4 tmpvar_47;
  tmpvar_47 = (transform_m_16 * tmpvar_46);
  vec4 tmpvar_48;
  tmpvar_48.xy = ((tmpvar_47.xy * tmpvar_22.x) + ((
    -(tmpvar_22.yz)
   + tmpvar_21.xy) * tmpvar_47.w));
  tmpvar_48.z = (ph_z_5 * tmpvar_47.w);
  tmpvar_48.w = tmpvar_47.w;
  gl_Position = (uTransform * tmpvar_48);
  vec4 tmpvar_49;
  tmpvar_49.xy = area_task_rect_23.p0;
  tmpvar_49.zw = area_task_rect_23.p1;
  vClipMaskUvBounds = tmpvar_49;
  vClipMaskUv = ((tmpvar_47.xy * area_device_pixel_scale_24) + (tmpvar_47.w * (area_task_rect_23.p0 - area_screen_origin_25)));
  ivec2 tmpvar_50;
  tmpvar_50.x = int((uint(tmpvar_15.x) % 1024u));
  tmpvar_50.y = int((uint(tmpvar_15.x) / 1024u));
  vec4 tmpvar_51;
  tmpvar_51 = texelFetchOffset (sGpuCache, tmpvar_50, 0, ivec2(0, 0));
  vec2 tmpvar_52;
  tmpvar_52 = (1.0/(vec2(textureSize (sColor0, 0))));
  vec2 tmpvar_53;
  tmpvar_53 = ((tmpvar_45 - tmpvar_7.xy) / (tmpvar_7.zw - tmpvar_7.xy));
  int tmpvar_54;
  tmpvar_54 = (tmpvar_15.x + 2);
  ivec2 tmpvar_55;
  tmpvar_55.x = int((uint(tmpvar_54) % 1024u));
  tmpvar_55.y = int((uint(tmpvar_54) / 1024u));
  vec4 tmpvar_56;
  tmpvar_56 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(1, 0)), tmpvar_53.x), mix (texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(3, 0)), tmpvar_53.x), tmpvar_53.y);
  vec2 tmpvar_57;
  tmpvar_57 = mix (tmpvar_51.xy, tmpvar_51.zw, (tmpvar_56.xy / tmpvar_56.w));
  float tmpvar_58;
  if (((tmpvar_36 & 1) != 0)) {
    tmpvar_58 = 1.0;
  } else {
    tmpvar_58 = 0.0;
  };
  v_uv = ((tmpvar_57 * tmpvar_52) * mix (tmpvar_47.w, 1.0, tmpvar_58));
  v_perspective_amount.x = tmpvar_58;
  vec4 tmpvar_59;
  tmpvar_59.xy = (tmpvar_51.xy + vec2(0.5, 0.5));
  tmpvar_59.zw = (tmpvar_51.zw - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_59 * tmpvar_52.xyxy);
  float tmpvar_60;
  tmpvar_60 = (float(tmpvar_15.z) / 65536.0);
  v_op_table_address_vec.x = (tmpvar_15.y & 65535);
  v_perspective_amount.y = tmpvar_60;
  v_funcs.x = float(((tmpvar_15.y >> 28) & 15));
  v_funcs.y = float(((tmpvar_15.y >> 24) & 15));
  v_funcs.z = float(((tmpvar_15.y >> 20) & 15));
  v_funcs.w = float(((tmpvar_15.y >> 16) & 15));
  int tmpvar_61;
  tmpvar_61 = tmpvar_15.z;
  vec4 tmpvar_62;
  mat4 tmpvar_63;
  int tmpvar_64;
  float tmpvar_65;
  tmpvar_65 = (1.0 - tmpvar_60);
  if ((v_op_table_address_vec.x == 1)) {
    vec4 tmpvar_66;
    tmpvar_66.w = 0.0;
    tmpvar_66.x = (0.2126 + (0.7874 * tmpvar_65));
    tmpvar_66.y = (0.2126 - (0.2126 * tmpvar_65));
    tmpvar_66.z = (0.2126 - (0.2126 * tmpvar_65));
    vec4 tmpvar_67;
    tmpvar_67.w = 0.0;
    tmpvar_67.x = (0.7152 - (0.7152 * tmpvar_65));
    tmpvar_67.y = (0.7152 + (0.2848 * tmpvar_65));
    tmpvar_67.z = (0.7152 - (0.7152 * tmpvar_65));
    vec4 tmpvar_68;
    tmpvar_68.w = 0.0;
    tmpvar_68.x = (0.0722 - (0.0722 * tmpvar_65));
    tmpvar_68.y = (0.0722 - (0.0722 * tmpvar_65));
    tmpvar_68.z = (0.0722 + (0.9278 * tmpvar_65));
    mat4 tmpvar_69;
    tmpvar_69[uint(0)] = tmpvar_66;
    tmpvar_69[1u] = tmpvar_67;
    tmpvar_69[2u] = tmpvar_68;
    tmpvar_69[3u] = vec4(0.0, 0.0, 0.0, 1.0);
    tmpvar_63 = tmpvar_69;
    tmpvar_62 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    if ((v_op_table_address_vec.x == 2)) {
      float tmpvar_70;
      tmpvar_70 = cos(tmpvar_60);
      float tmpvar_71;
      tmpvar_71 = sin(tmpvar_60);
      vec4 tmpvar_72;
      tmpvar_72.w = 0.0;
      tmpvar_72.x = ((0.2126 + (0.7874 * tmpvar_70)) - (0.2126 * tmpvar_71));
      tmpvar_72.y = ((0.2126 - (0.2126 * tmpvar_70)) + (0.143 * tmpvar_71));
      tmpvar_72.z = ((0.2126 - (0.2126 * tmpvar_70)) - (0.7874 * tmpvar_71));
      vec4 tmpvar_73;
      tmpvar_73.w = 0.0;
      tmpvar_73.x = ((0.7152 - (0.7152 * tmpvar_70)) - (0.7152 * tmpvar_71));
      tmpvar_73.y = ((0.7152 + (0.2848 * tmpvar_70)) + (0.14 * tmpvar_71));
      tmpvar_73.z = ((0.7152 - (0.7152 * tmpvar_70)) + (0.7152 * tmpvar_71));
      vec4 tmpvar_74;
      tmpvar_74.w = 0.0;
      tmpvar_74.x = ((0.0722 - (0.0722 * tmpvar_70)) + (0.9278 * tmpvar_71));
      tmpvar_74.y = ((0.0722 - (0.0722 * tmpvar_70)) - (0.283 * tmpvar_71));
      tmpvar_74.z = ((0.0722 + (0.9278 * tmpvar_70)) + (0.0722 * tmpvar_71));
      mat4 tmpvar_75;
      tmpvar_75[uint(0)] = tmpvar_72;
      tmpvar_75[1u] = tmpvar_73;
      tmpvar_75[2u] = tmpvar_74;
      tmpvar_75[3u] = vec4(0.0, 0.0, 0.0, 1.0);
      tmpvar_63 = tmpvar_75;
      tmpvar_62 = vec4(0.0, 0.0, 0.0, 0.0);
    } else {
      if ((v_op_table_address_vec.x == 4)) {
        vec4 tmpvar_76;
        tmpvar_76.w = 0.0;
        tmpvar_76.x = ((tmpvar_65 * 0.2126) + tmpvar_60);
        tmpvar_76.y = (tmpvar_65 * 0.2126);
        tmpvar_76.z = (tmpvar_65 * 0.2126);
        vec4 tmpvar_77;
        tmpvar_77.w = 0.0;
        tmpvar_77.x = (tmpvar_65 * 0.7152);
        tmpvar_77.y = ((tmpvar_65 * 0.7152) + tmpvar_60);
        tmpvar_77.z = (tmpvar_65 * 0.7152);
        vec4 tmpvar_78;
        tmpvar_78.w = 0.0;
        tmpvar_78.x = (tmpvar_65 * 0.0722);
        tmpvar_78.y = (tmpvar_65 * 0.0722);
        tmpvar_78.z = ((tmpvar_65 * 0.0722) + tmpvar_60);
        mat4 tmpvar_79;
        tmpvar_79[uint(0)] = tmpvar_76;
        tmpvar_79[1u] = tmpvar_77;
        tmpvar_79[2u] = tmpvar_78;
        tmpvar_79[3u] = vec4(0.0, 0.0, 0.0, 1.0);
        tmpvar_63 = tmpvar_79;
        tmpvar_62 = vec4(0.0, 0.0, 0.0, 0.0);
      } else {
        if ((v_op_table_address_vec.x == 5)) {
          vec4 tmpvar_80;
          tmpvar_80.w = 0.0;
          tmpvar_80.x = (0.393 + (0.607 * tmpvar_65));
          tmpvar_80.y = (0.349 - (0.349 * tmpvar_65));
          tmpvar_80.z = (0.272 - (0.272 * tmpvar_65));
          vec4 tmpvar_81;
          tmpvar_81.w = 0.0;
          tmpvar_81.x = (0.769 - (0.769 * tmpvar_65));
          tmpvar_81.y = (0.686 + (0.314 * tmpvar_65));
          tmpvar_81.z = (0.534 - (0.534 * tmpvar_65));
          vec4 tmpvar_82;
          tmpvar_82.w = 0.0;
          tmpvar_82.x = (0.189 - (0.189 * tmpvar_65));
          tmpvar_82.y = (0.168 - (0.168 * tmpvar_65));
          tmpvar_82.z = (0.131 + (0.869 * tmpvar_65));
          mat4 tmpvar_83;
          tmpvar_83[uint(0)] = tmpvar_80;
          tmpvar_83[1u] = tmpvar_81;
          tmpvar_83[2u] = tmpvar_82;
          tmpvar_83[3u] = vec4(0.0, 0.0, 0.0, 1.0);
          tmpvar_63 = tmpvar_83;
          tmpvar_62 = vec4(0.0, 0.0, 0.0, 0.0);
        } else {
          if ((v_op_table_address_vec.x == 7)) {
            ivec2 tmpvar_84;
            tmpvar_84.x = int((uint(tmpvar_15.z) % 1024u));
            tmpvar_84.y = int((uint(tmpvar_15.z) / 1024u));
            int tmpvar_85;
            tmpvar_85 = (tmpvar_15.z + 4);
            ivec2 tmpvar_86;
            tmpvar_86.x = int((uint(tmpvar_85) % 1024u));
            tmpvar_86.y = int((uint(tmpvar_85) / 1024u));
            mat4 tmpvar_87;
            tmpvar_87[uint(0)] = texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(0, 0));
            tmpvar_87[1u] = texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(1, 0));
            tmpvar_87[2u] = texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(2, 0));
            tmpvar_87[3u] = texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(3, 0));
            tmpvar_63 = tmpvar_87;
            tmpvar_62 = texelFetch (sGpuCache, tmpvar_86, 0);
          } else {
            if ((v_op_table_address_vec.x == 11)) {
              tmpvar_64 = tmpvar_61;
            } else {
              if ((v_op_table_address_vec.x == 10)) {
                ivec2 tmpvar_88;
                tmpvar_88.x = int((uint(tmpvar_15.z) % 1024u));
                tmpvar_88.y = int((uint(tmpvar_15.z) / 1024u));
                tmpvar_62 = texelFetch (sGpuCache, tmpvar_88, 0);
              };
            };
          };
        };
      };
    };
  };
  v_color_offset = tmpvar_62;
  v_color_mat = tmpvar_63;
  v_op_table_address_vec.y = tmpvar_64;
  v_local_pos = tmpvar_45;
}

#version 150
// brush_blend
// features: ["ALPHA_PASS"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sGpuCache;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 v_uv;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective_amount;
flat in ivec2 v_op_table_address_vec;
flat in mat4 v_color_mat;
flat in vec4 v_funcs;
flat in vec4 v_color_offset;
void main ()
{
  vec4 frag_color_1;
  vec4 tmpvar_2;
  tmpvar_2 = texture (sColor0, min (max ((v_uv * 
    mix (gl_FragCoord.w, 1.0, v_perspective_amount.x)
  ), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  vec3 tmpvar_3;
  float tmpvar_4;
  tmpvar_4 = tmpvar_2.w;
  vec3 tmpvar_5;
  if ((tmpvar_2.w != 0.0)) {
    tmpvar_5 = (tmpvar_2.xyz / tmpvar_2.w);
  } else {
    tmpvar_5 = tmpvar_2.xyz;
  };
  tmpvar_3 = tmpvar_5;
  bool tmpvar_6;
  bool tmpvar_7;
  tmpvar_7 = bool(0);
  tmpvar_6 = (0 == v_op_table_address_vec.x);
  if (tmpvar_6) {
    tmpvar_3 = min (max ((
      ((tmpvar_5 * v_perspective_amount.y) - (0.5 * v_perspective_amount.y))
     + 0.5), 0.0), 1.0);
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (3 == v_op_table_address_vec.x));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    tmpvar_3 = mix (tmpvar_3, (vec3(1.0, 1.0, 1.0) - tmpvar_3), v_perspective_amount.y);
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (6 == v_op_table_address_vec.x));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    tmpvar_3 = min (max ((tmpvar_3 * v_perspective_amount.y), 0.0), 1.0);
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (8 == v_op_table_address_vec.x));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    tmpvar_3 = mix(pow ((
      (tmpvar_3 / 1.055)
     + vec3(0.0521327, 0.0521327, 0.0521327)), vec3(2.4, 2.4, 2.4)), (tmpvar_3 / 12.92), bvec3(greaterThanEqual (vec3(0.04045, 0.04045, 0.04045), tmpvar_3)));
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (9 == v_op_table_address_vec.x));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    tmpvar_3 = mix(((vec3(1.055, 1.055, 1.055) * 
      pow (tmpvar_3, vec3(0.4166667, 0.4166667, 0.4166667))
    ) - vec3(0.055, 0.055, 0.055)), (tmpvar_3 * 12.92), bvec3(greaterThanEqual (vec3(0.0031308, 0.0031308, 0.0031308), tmpvar_3)));
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (11 == v_op_table_address_vec.x));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    vec4 tmpvar_8;
    tmpvar_8.xyz = tmpvar_3;
    tmpvar_8.w = tmpvar_4;
    vec4 tmpvar_9;
    tmpvar_9 = tmpvar_8;
    int k_10;
    int offset_11;
    offset_11 = 0;
    int tmpvar_12;
    int tmpvar_13;
    int tmpvar_14;
    int tmpvar_15;
    tmpvar_12 = int(v_funcs.x);
    tmpvar_13 = int(v_funcs.y);
    tmpvar_14 = int(v_funcs.z);
    tmpvar_15 = int(v_funcs.w);
    bool tmpvar_16;
    bool tmpvar_17;
    tmpvar_17 = bool(0);
    tmpvar_16 = (0 == tmpvar_12);
    if (tmpvar_16) {
      tmpvar_17 = bool(1);
    };
    tmpvar_16 = (tmpvar_16 || (1 == tmpvar_12));
    tmpvar_16 = (tmpvar_16 || (2 == tmpvar_12));
    tmpvar_16 = (tmpvar_16 && !(tmpvar_17));
    if (tmpvar_16) {
      k_10 = int(floor((
        (tmpvar_8[0] * 255.0)
       + 0.5)));
      int tmpvar_18;
      tmpvar_18 = (v_op_table_address_vec.y + (k_10 / 4));
      ivec2 tmpvar_19;
      tmpvar_19.x = int((uint(tmpvar_18) % 1024u));
      tmpvar_19.y = int((uint(tmpvar_18) / 1024u));
      vec4 tmpvar_20;
      tmpvar_20 = texelFetch (sGpuCache, tmpvar_19, 0);
      tmpvar_9[0] = min (max (tmpvar_20[(k_10 % 4)], 0.0), 1.0);
      offset_11 = 64;
      tmpvar_17 = bool(1);
    };
    tmpvar_16 = (tmpvar_16 || (3 == tmpvar_12));
    tmpvar_16 = (tmpvar_16 && !(tmpvar_17));
    if (tmpvar_16) {
      int tmpvar_21;
      tmpvar_21 = (v_op_table_address_vec.y + offset_11);
      ivec2 tmpvar_22;
      tmpvar_22.x = int((uint(tmpvar_21) % 1024u));
      tmpvar_22.y = int((uint(tmpvar_21) / 1024u));
      vec4 tmpvar_23;
      tmpvar_23 = texelFetch (sGpuCache, tmpvar_22, 0);
      tmpvar_9[0] = min (max ((
        (tmpvar_23[0] * tmpvar_9[0])
       + tmpvar_23[1]), 0.0), 1.0);
      offset_11++;
      tmpvar_17 = bool(1);
    };
    tmpvar_16 = (tmpvar_16 || (4 == tmpvar_12));
    tmpvar_16 = (tmpvar_16 && !(tmpvar_17));
    if (tmpvar_16) {
      int tmpvar_24;
      tmpvar_24 = (v_op_table_address_vec.y + offset_11);
      ivec2 tmpvar_25;
      tmpvar_25.x = int((uint(tmpvar_24) % 1024u));
      tmpvar_25.y = int((uint(tmpvar_24) / 1024u));
      vec4 tmpvar_26;
      tmpvar_26 = texelFetch (sGpuCache, tmpvar_25, 0);
      tmpvar_9[0] = min (max ((
        (tmpvar_26[0] * pow (tmpvar_9[0], tmpvar_26[1]))
       + tmpvar_26[2]), 0.0), 1.0);
      offset_11++;
      tmpvar_17 = bool(1);
    };
    tmpvar_16 = !(tmpvar_17);
    if (tmpvar_16) {
      tmpvar_17 = bool(1);
    };
    bool tmpvar_27;
    bool tmpvar_28;
    tmpvar_28 = bool(0);
    tmpvar_27 = (0 == tmpvar_13);
    if (tmpvar_27) {
      tmpvar_28 = bool(1);
    };
    tmpvar_27 = (tmpvar_27 || (1 == tmpvar_13));
    tmpvar_27 = (tmpvar_27 || (2 == tmpvar_13));
    tmpvar_27 = (tmpvar_27 && !(tmpvar_28));
    if (tmpvar_27) {
      k_10 = int(floor((
        (tmpvar_9[1] * 255.0)
       + 0.5)));
      int tmpvar_29;
      tmpvar_29 = ((v_op_table_address_vec.y + offset_11) + (k_10 / 4));
      ivec2 tmpvar_30;
      tmpvar_30.x = int((uint(tmpvar_29) % 1024u));
      tmpvar_30.y = int((uint(tmpvar_29) / 1024u));
      vec4 tmpvar_31;
      tmpvar_31 = texelFetch (sGpuCache, tmpvar_30, 0);
      tmpvar_9[1] = min (max (tmpvar_31[(k_10 % 4)], 0.0), 1.0);
      offset_11 += 64;
      tmpvar_28 = bool(1);
    };
    tmpvar_27 = (tmpvar_27 || (3 == tmpvar_13));
    tmpvar_27 = (tmpvar_27 && !(tmpvar_28));
    if (tmpvar_27) {
      int tmpvar_32;
      tmpvar_32 = (v_op_table_address_vec.y + offset_11);
      ivec2 tmpvar_33;
      tmpvar_33.x = int((uint(tmpvar_32) % 1024u));
      tmpvar_33.y = int((uint(tmpvar_32) / 1024u));
      vec4 tmpvar_34;
      tmpvar_34 = texelFetch (sGpuCache, tmpvar_33, 0);
      tmpvar_9[1] = min (max ((
        (tmpvar_34[0] * tmpvar_9[1])
       + tmpvar_34[1]), 0.0), 1.0);
      offset_11++;
      tmpvar_28 = bool(1);
    };
    tmpvar_27 = (tmpvar_27 || (4 == tmpvar_13));
    tmpvar_27 = (tmpvar_27 && !(tmpvar_28));
    if (tmpvar_27) {
      int tmpvar_35;
      tmpvar_35 = (v_op_table_address_vec.y + offset_11);
      ivec2 tmpvar_36;
      tmpvar_36.x = int((uint(tmpvar_35) % 1024u));
      tmpvar_36.y = int((uint(tmpvar_35) / 1024u));
      vec4 tmpvar_37;
      tmpvar_37 = texelFetch (sGpuCache, tmpvar_36, 0);
      tmpvar_9[1] = min (max ((
        (tmpvar_37[0] * pow (tmpvar_9[1], tmpvar_37[1]))
       + tmpvar_37[2]), 0.0), 1.0);
      offset_11++;
      tmpvar_28 = bool(1);
    };
    tmpvar_27 = !(tmpvar_28);
    if (tmpvar_27) {
      tmpvar_28 = bool(1);
    };
    bool tmpvar_38;
    bool tmpvar_39;
    tmpvar_39 = bool(0);
    tmpvar_38 = (0 == tmpvar_14);
    if (tmpvar_38) {
      tmpvar_39 = bool(1);
    };
    tmpvar_38 = (tmpvar_38 || (1 == tmpvar_14));
    tmpvar_38 = (tmpvar_38 || (2 == tmpvar_14));
    tmpvar_38 = (tmpvar_38 && !(tmpvar_39));
    if (tmpvar_38) {
      k_10 = int(floor((
        (tmpvar_9[2] * 255.0)
       + 0.5)));
      int tmpvar_40;
      tmpvar_40 = ((v_op_table_address_vec.y + offset_11) + (k_10 / 4));
      ivec2 tmpvar_41;
      tmpvar_41.x = int((uint(tmpvar_40) % 1024u));
      tmpvar_41.y = int((uint(tmpvar_40) / 1024u));
      vec4 tmpvar_42;
      tmpvar_42 = texelFetch (sGpuCache, tmpvar_41, 0);
      tmpvar_9[2] = min (max (tmpvar_42[(k_10 % 4)], 0.0), 1.0);
      offset_11 += 64;
      tmpvar_39 = bool(1);
    };
    tmpvar_38 = (tmpvar_38 || (3 == tmpvar_14));
    tmpvar_38 = (tmpvar_38 && !(tmpvar_39));
    if (tmpvar_38) {
      int tmpvar_43;
      tmpvar_43 = (v_op_table_address_vec.y + offset_11);
      ivec2 tmpvar_44;
      tmpvar_44.x = int((uint(tmpvar_43) % 1024u));
      tmpvar_44.y = int((uint(tmpvar_43) / 1024u));
      vec4 tmpvar_45;
      tmpvar_45 = texelFetch (sGpuCache, tmpvar_44, 0);
      tmpvar_9[2] = min (max ((
        (tmpvar_45[0] * tmpvar_9[2])
       + tmpvar_45[1]), 0.0), 1.0);
      offset_11++;
      tmpvar_39 = bool(1);
    };
    tmpvar_38 = (tmpvar_38 || (4 == tmpvar_14));
    tmpvar_38 = (tmpvar_38 && !(tmpvar_39));
    if (tmpvar_38) {
      int tmpvar_46;
      tmpvar_46 = (v_op_table_address_vec.y + offset_11);
      ivec2 tmpvar_47;
      tmpvar_47.x = int((uint(tmpvar_46) % 1024u));
      tmpvar_47.y = int((uint(tmpvar_46) / 1024u));
      vec4 tmpvar_48;
      tmpvar_48 = texelFetch (sGpuCache, tmpvar_47, 0);
      tmpvar_9[2] = min (max ((
        (tmpvar_48[0] * pow (tmpvar_9[2], tmpvar_48[1]))
       + tmpvar_48[2]), 0.0), 1.0);
      offset_11++;
      tmpvar_39 = bool(1);
    };
    tmpvar_38 = !(tmpvar_39);
    if (tmpvar_38) {
      tmpvar_39 = bool(1);
    };
    bool tmpvar_49;
    bool tmpvar_50;
    tmpvar_50 = bool(0);
    tmpvar_49 = (0 == tmpvar_15);
    if (tmpvar_49) {
      tmpvar_50 = bool(1);
    };
    tmpvar_49 = (tmpvar_49 || (1 == tmpvar_15));
    tmpvar_49 = (tmpvar_49 || (2 == tmpvar_15));
    tmpvar_49 = (tmpvar_49 && !(tmpvar_50));
    if (tmpvar_49) {
      k_10 = int(floor((
        (tmpvar_9[3] * 255.0)
       + 0.5)));
      int tmpvar_51;
      tmpvar_51 = ((v_op_table_address_vec.y + offset_11) + (k_10 / 4));
      ivec2 tmpvar_52;
      tmpvar_52.x = int((uint(tmpvar_51) % 1024u));
      tmpvar_52.y = int((uint(tmpvar_51) / 1024u));
      vec4 tmpvar_53;
      tmpvar_53 = texelFetch (sGpuCache, tmpvar_52, 0);
      tmpvar_9[3] = min (max (tmpvar_53[(k_10 % 4)], 0.0), 1.0);
      offset_11 += 64;
      tmpvar_50 = bool(1);
    };
    tmpvar_49 = (tmpvar_49 || (3 == tmpvar_15));
    tmpvar_49 = (tmpvar_49 && !(tmpvar_50));
    if (tmpvar_49) {
      int tmpvar_54;
      tmpvar_54 = (v_op_table_address_vec.y + offset_11);
      ivec2 tmpvar_55;
      tmpvar_55.x = int((uint(tmpvar_54) % 1024u));
      tmpvar_55.y = int((uint(tmpvar_54) / 1024u));
      vec4 tmpvar_56;
      tmpvar_56 = texelFetch (sGpuCache, tmpvar_55, 0);
      tmpvar_9[3] = min (max ((
        (tmpvar_56[0] * tmpvar_9[3])
       + tmpvar_56[1]), 0.0), 1.0);
      offset_11++;
      tmpvar_50 = bool(1);
    };
    tmpvar_49 = (tmpvar_49 || (4 == tmpvar_15));
    tmpvar_49 = (tmpvar_49 && !(tmpvar_50));
    if (tmpvar_49) {
      int tmpvar_57;
      tmpvar_57 = (v_op_table_address_vec.y + offset_11);
      ivec2 tmpvar_58;
      tmpvar_58.x = int((uint(tmpvar_57) % 1024u));
      tmpvar_58.y = int((uint(tmpvar_57) / 1024u));
      vec4 tmpvar_59;
      tmpvar_59 = texelFetch (sGpuCache, tmpvar_58, 0);
      tmpvar_9[3] = min (max ((
        (tmpvar_59[0] * pow (tmpvar_9[3], tmpvar_59[1]))
       + tmpvar_59[2]), 0.0), 1.0);
      offset_11++;
      tmpvar_50 = bool(1);
    };
    tmpvar_49 = !(tmpvar_50);
    if (tmpvar_49) {
      tmpvar_50 = bool(1);
    };
    tmpvar_3 = tmpvar_9.xyz;
    tmpvar_4 = tmpvar_9.w;
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (10 == v_op_table_address_vec.x));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    tmpvar_3 = v_color_offset.xyz;
    tmpvar_4 = v_color_offset.w;
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = !(tmpvar_7);
  if (tmpvar_6) {
    vec4 tmpvar_60;
    tmpvar_60.xyz = tmpvar_3;
    tmpvar_60.w = tmpvar_4;
    vec4 tmpvar_61;
    tmpvar_61 = min (max ((
      (v_color_mat * tmpvar_60)
     + v_color_offset), 0.0), 1.0);
    tmpvar_3 = tmpvar_61.xyz;
    tmpvar_4 = tmpvar_61.w;
  };
  vec2 tmpvar_62;
  tmpvar_62 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  vec4 tmpvar_63;
  tmpvar_63.w = 1.0;
  tmpvar_63.xyz = tmpvar_3;
  frag_color_1 = ((tmpvar_4 * min (
    max ((0.5 - max (tmpvar_62.x, tmpvar_62.y)), 0.0)
  , 1.0)) * tmpvar_63);
  float tmpvar_64;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_64 = 1.0;
  } else {
    vec2 tmpvar_65;
    tmpvar_65 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_66;
    tmpvar_66.xy = greaterThanEqual (tmpvar_65, vClipMaskUvBounds.xy);
    tmpvar_66.zw = lessThan (tmpvar_65, vClipMaskUvBounds.zw);
    bool tmpvar_67;
    tmpvar_67 = (tmpvar_66 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_67)) {
      tmpvar_64 = 0.0;
    } else {
      tmpvar_64 = texelFetch (sClipMask, ivec2(tmpvar_65), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_64);
  oFragColor = frag_color_1;
}

brush_blend_DEBUG_OVERDRAW#version 150
// brush_blend
// features: ["DEBUG_OVERDRAW"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_uv;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective_amount;
flat out ivec2 v_op_table_address_vec;
flat out mat4 v_color_mat;
flat out vec4 v_funcs;
flat out vec4 v_color_offset;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  ivec2 tmpvar_40;
  tmpvar_40.x = int((uint(tmpvar_12.x) % 1024u));
  tmpvar_40.y = int((uint(tmpvar_12.x) / 1024u));
  vec4 tmpvar_41;
  tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
  vec2 tmpvar_42;
  tmpvar_42 = (1.0/(vec2(textureSize (sColor0, 0))));
  vec2 tmpvar_43;
  tmpvar_43 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  int tmpvar_44;
  tmpvar_44 = (tmpvar_12.x + 2);
  ivec2 tmpvar_45;
  tmpvar_45.x = int((uint(tmpvar_44) % 1024u));
  tmpvar_45.y = int((uint(tmpvar_44) / 1024u));
  vec4 tmpvar_46;
  tmpvar_46 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(1, 0)), tmpvar_43.x), mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(3, 0)), tmpvar_43.x), tmpvar_43.y);
  vec2 tmpvar_47;
  tmpvar_47 = mix (tmpvar_41.xy, tmpvar_41.zw, (tmpvar_46.xy / tmpvar_46.w));
  float tmpvar_48;
  if (((tmpvar_27 & 1) != 0)) {
    tmpvar_48 = 1.0;
  } else {
    tmpvar_48 = 0.0;
  };
  v_uv = ((tmpvar_47 * tmpvar_42) * mix (tmpvar_38.w, 1.0, tmpvar_48));
  v_perspective_amount.x = tmpvar_48;
  vec4 tmpvar_49;
  tmpvar_49.xy = (tmpvar_41.xy + vec2(0.5, 0.5));
  tmpvar_49.zw = (tmpvar_41.zw - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_49 * tmpvar_42.xyxy);
  float tmpvar_50;
  tmpvar_50 = (float(tmpvar_12.z) / 65536.0);
  v_op_table_address_vec.x = (tmpvar_12.y & 65535);
  v_perspective_amount.y = tmpvar_50;
  v_funcs.x = float(((tmpvar_12.y >> 28) & 15));
  v_funcs.y = float(((tmpvar_12.y >> 24) & 15));
  v_funcs.z = float(((tmpvar_12.y >> 20) & 15));
  v_funcs.w = float(((tmpvar_12.y >> 16) & 15));
  int tmpvar_51;
  tmpvar_51 = tmpvar_12.z;
  vec4 tmpvar_52;
  mat4 tmpvar_53;
  int tmpvar_54;
  float tmpvar_55;
  tmpvar_55 = (1.0 - tmpvar_50);
  if ((v_op_table_address_vec.x == 1)) {
    vec4 tmpvar_56;
    tmpvar_56.w = 0.0;
    tmpvar_56.x = (0.2126 + (0.7874 * tmpvar_55));
    tmpvar_56.y = (0.2126 - (0.2126 * tmpvar_55));
    tmpvar_56.z = (0.2126 - (0.2126 * tmpvar_55));
    vec4 tmpvar_57;
    tmpvar_57.w = 0.0;
    tmpvar_57.x = (0.7152 - (0.7152 * tmpvar_55));
    tmpvar_57.y = (0.7152 + (0.2848 * tmpvar_55));
    tmpvar_57.z = (0.7152 - (0.7152 * tmpvar_55));
    vec4 tmpvar_58;
    tmpvar_58.w = 0.0;
    tmpvar_58.x = (0.0722 - (0.0722 * tmpvar_55));
    tmpvar_58.y = (0.0722 - (0.0722 * tmpvar_55));
    tmpvar_58.z = (0.0722 + (0.9278 * tmpvar_55));
    mat4 tmpvar_59;
    tmpvar_59[uint(0)] = tmpvar_56;
    tmpvar_59[1u] = tmpvar_57;
    tmpvar_59[2u] = tmpvar_58;
    tmpvar_59[3u] = vec4(0.0, 0.0, 0.0, 1.0);
    tmpvar_53 = tmpvar_59;
    tmpvar_52 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    if ((v_op_table_address_vec.x == 2)) {
      float tmpvar_60;
      tmpvar_60 = cos(tmpvar_50);
      float tmpvar_61;
      tmpvar_61 = sin(tmpvar_50);
      vec4 tmpvar_62;
      tmpvar_62.w = 0.0;
      tmpvar_62.x = ((0.2126 + (0.7874 * tmpvar_60)) - (0.2126 * tmpvar_61));
      tmpvar_62.y = ((0.2126 - (0.2126 * tmpvar_60)) + (0.143 * tmpvar_61));
      tmpvar_62.z = ((0.2126 - (0.2126 * tmpvar_60)) - (0.7874 * tmpvar_61));
      vec4 tmpvar_63;
      tmpvar_63.w = 0.0;
      tmpvar_63.x = ((0.7152 - (0.7152 * tmpvar_60)) - (0.7152 * tmpvar_61));
      tmpvar_63.y = ((0.7152 + (0.2848 * tmpvar_60)) + (0.14 * tmpvar_61));
      tmpvar_63.z = ((0.7152 - (0.7152 * tmpvar_60)) + (0.7152 * tmpvar_61));
      vec4 tmpvar_64;
      tmpvar_64.w = 0.0;
      tmpvar_64.x = ((0.0722 - (0.0722 * tmpvar_60)) + (0.9278 * tmpvar_61));
      tmpvar_64.y = ((0.0722 - (0.0722 * tmpvar_60)) - (0.283 * tmpvar_61));
      tmpvar_64.z = ((0.0722 + (0.9278 * tmpvar_60)) + (0.0722 * tmpvar_61));
      mat4 tmpvar_65;
      tmpvar_65[uint(0)] = tmpvar_62;
      tmpvar_65[1u] = tmpvar_63;
      tmpvar_65[2u] = tmpvar_64;
      tmpvar_65[3u] = vec4(0.0, 0.0, 0.0, 1.0);
      tmpvar_53 = tmpvar_65;
      tmpvar_52 = vec4(0.0, 0.0, 0.0, 0.0);
    } else {
      if ((v_op_table_address_vec.x == 4)) {
        vec4 tmpvar_66;
        tmpvar_66.w = 0.0;
        tmpvar_66.x = ((tmpvar_55 * 0.2126) + tmpvar_50);
        tmpvar_66.y = (tmpvar_55 * 0.2126);
        tmpvar_66.z = (tmpvar_55 * 0.2126);
        vec4 tmpvar_67;
        tmpvar_67.w = 0.0;
        tmpvar_67.x = (tmpvar_55 * 0.7152);
        tmpvar_67.y = ((tmpvar_55 * 0.7152) + tmpvar_50);
        tmpvar_67.z = (tmpvar_55 * 0.7152);
        vec4 tmpvar_68;
        tmpvar_68.w = 0.0;
        tmpvar_68.x = (tmpvar_55 * 0.0722);
        tmpvar_68.y = (tmpvar_55 * 0.0722);
        tmpvar_68.z = ((tmpvar_55 * 0.0722) + tmpvar_50);
        mat4 tmpvar_69;
        tmpvar_69[uint(0)] = tmpvar_66;
        tmpvar_69[1u] = tmpvar_67;
        tmpvar_69[2u] = tmpvar_68;
        tmpvar_69[3u] = vec4(0.0, 0.0, 0.0, 1.0);
        tmpvar_53 = tmpvar_69;
        tmpvar_52 = vec4(0.0, 0.0, 0.0, 0.0);
      } else {
        if ((v_op_table_address_vec.x == 5)) {
          vec4 tmpvar_70;
          tmpvar_70.w = 0.0;
          tmpvar_70.x = (0.393 + (0.607 * tmpvar_55));
          tmpvar_70.y = (0.349 - (0.349 * tmpvar_55));
          tmpvar_70.z = (0.272 - (0.272 * tmpvar_55));
          vec4 tmpvar_71;
          tmpvar_71.w = 0.0;
          tmpvar_71.x = (0.769 - (0.769 * tmpvar_55));
          tmpvar_71.y = (0.686 + (0.314 * tmpvar_55));
          tmpvar_71.z = (0.534 - (0.534 * tmpvar_55));
          vec4 tmpvar_72;
          tmpvar_72.w = 0.0;
          tmpvar_72.x = (0.189 - (0.189 * tmpvar_55));
          tmpvar_72.y = (0.168 - (0.168 * tmpvar_55));
          tmpvar_72.z = (0.131 + (0.869 * tmpvar_55));
          mat4 tmpvar_73;
          tmpvar_73[uint(0)] = tmpvar_70;
          tmpvar_73[1u] = tmpvar_71;
          tmpvar_73[2u] = tmpvar_72;
          tmpvar_73[3u] = vec4(0.0, 0.0, 0.0, 1.0);
          tmpvar_53 = tmpvar_73;
          tmpvar_52 = vec4(0.0, 0.0, 0.0, 0.0);
        } else {
          if ((v_op_table_address_vec.x == 7)) {
            ivec2 tmpvar_74;
            tmpvar_74.x = int((uint(tmpvar_12.z) % 1024u));
            tmpvar_74.y = int((uint(tmpvar_12.z) / 1024u));
            int tmpvar_75;
            tmpvar_75 = (tmpvar_12.z + 4);
            ivec2 tmpvar_76;
            tmpvar_76.x = int((uint(tmpvar_75) % 1024u));
            tmpvar_76.y = int((uint(tmpvar_75) / 1024u));
            mat4 tmpvar_77;
            tmpvar_77[uint(0)] = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(0, 0));
            tmpvar_77[1u] = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(1, 0));
            tmpvar_77[2u] = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(2, 0));
            tmpvar_77[3u] = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(3, 0));
            tmpvar_53 = tmpvar_77;
            tmpvar_52 = texelFetch (sGpuCache, tmpvar_76, 0);
          } else {
            if ((v_op_table_address_vec.x == 11)) {
              tmpvar_54 = tmpvar_51;
            } else {
              if ((v_op_table_address_vec.x == 10)) {
                ivec2 tmpvar_78;
                tmpvar_78.x = int((uint(tmpvar_12.z) % 1024u));
                tmpvar_78.y = int((uint(tmpvar_12.z) / 1024u));
                tmpvar_52 = texelFetch (sGpuCache, tmpvar_78, 0);
              };
            };
          };
        };
      };
    };
  };
  v_color_offset = tmpvar_52;
  v_color_mat = tmpvar_53;
  v_op_table_address_vec.y = tmpvar_54;
}

#version 150
// brush_blend
// features: ["DEBUG_OVERDRAW"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

brush_image_ADVANCED_BLEND_ALPHA_PASS_ANTIALIASING_REPETITION_TEXTURE_2D#version 150
// brush_image
// features: ["ADVANCED_BLEND", "ALPHA_PASS", "ANTIALIASING", "REPETITION", "TEXTURE_2D"]

#extension GL_KHR_blend_equation_advanced : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  vec2 tmpvar_64;
  tmpvar_64 = vec2(textureSize (sColor0, 0));
  ivec2 tmpvar_65;
  tmpvar_65.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_65.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_66;
  tmpvar_66 = texelFetchOffset (sGpuCache, tmpvar_65, 0, ivec2(0, 0));
  uv0_58 = tmpvar_66.xy;
  uv1_57 = tmpvar_66.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    vec2 tmpvar_67;
    tmpvar_67 = (segment_rect_p1_35 - segment_rect_p0_34);
    stretch_size_54 = tmpvar_67;
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_68;
      tmpvar_68 = (tmpvar_66.zw - tmpvar_66.xy);
      uv0_58 = (tmpvar_66.xy + (segment_data_36.xy * tmpvar_68));
      uv1_57 = (tmpvar_66.xy + (segment_data_36.zw * tmpvar_68));
    };
    if (((tmpvar_38 & 128) != 0)) {
      vec2 vertical_uv_size_69;
      vec2 horizontal_uv_size_70;
      vec2 repeated_stretch_size_71;
      repeated_stretch_size_71 = tmpvar_67;
      vec2 tmpvar_72;
      tmpvar_72 = (uv1_57 - uv0_58);
      horizontal_uv_size_70 = tmpvar_72;
      vec2 tmpvar_73;
      tmpvar_73 = (uv1_57 - uv0_58);
      vertical_uv_size_69 = tmpvar_73;
      if (((tmpvar_38 & 64) != 0)) {
        repeated_stretch_size_71 = (segment_rect_p0_34 - tmpvar_8.xy);
        vertical_uv_size_69.x = (uv0_58.x - tmpvar_66.x);
        if (((vertical_uv_size_69.x < 0.001) || (repeated_stretch_size_71.x < 0.001))) {
          vertical_uv_size_69.x = (tmpvar_66.z - uv1_57.x);
          repeated_stretch_size_71.x = (tmpvar_8.z - segment_rect_p1_35.x);
        };
        horizontal_uv_size_70.y = (uv0_58.y - tmpvar_66.y);
        if (((horizontal_uv_size_70.y < 0.001) || (repeated_stretch_size_71.y < 0.001))) {
          horizontal_uv_size_70.y = (tmpvar_66.w - uv1_57.y);
          repeated_stretch_size_71.y = (tmpvar_8.w - segment_rect_p1_35.y);
        };
      };
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (repeated_stretch_size_71.y * (tmpvar_72.x / horizontal_uv_size_70.y));
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (repeated_stretch_size_71.x * (tmpvar_73.y / vertical_uv_size_69.x));
      };
    } else {
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (segment_data_36.z - segment_data_36.x);
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (segment_data_36.w - segment_data_36.y);
      };
    };
    if (((tmpvar_38 & 16) != 0)) {
      float tmpvar_74;
      tmpvar_74 = (segment_rect_p1_35.x - segment_rect_p0_34.x);
      stretch_size_54.x = (tmpvar_74 / max (1.0, roundEven(
        (tmpvar_74 / stretch_size_54.x)
      )));
    };
    if (((tmpvar_38 & 32) != 0)) {
      float tmpvar_75;
      tmpvar_75 = (segment_rect_p1_35.y - segment_rect_p0_34.y);
      stretch_size_54.y = (tmpvar_75 / max (1.0, roundEven(
        (tmpvar_75 / stretch_size_54.y)
      )));
    };
  };
  float tmpvar_76;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_76 = 1.0;
  } else {
    tmpvar_76 = 0.0;
  };
  v_perspective.x = tmpvar_76;
  vec2 tmpvar_77;
  tmpvar_77 = min (uv0_58, uv1_57);
  vec2 tmpvar_78;
  tmpvar_78 = max (uv0_58, uv1_57);
  vec4 tmpvar_79;
  tmpvar_79.xy = (tmpvar_77 + vec2(0.5, 0.5));
  tmpvar_79.zw = (tmpvar_78 - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_79 / tmpvar_64.xyxy);
  vec2 tmpvar_80;
  tmpvar_80 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_80;
  int tmpvar_81;
  tmpvar_81 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_81;
  int tmpvar_82;
  tmpvar_82 = (tmpvar_16.x >> 16);
  if ((tmpvar_81 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_83;
    tmpvar_83 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_84;
    tmpvar_84.x = int((uint(tmpvar_83) % 1024u));
    tmpvar_84.y = int((uint(tmpvar_83) / 1024u));
    vec4 tmpvar_85;
    tmpvar_85 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(1, 0)), tmpvar_80.x), mix (texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(3, 0)), tmpvar_80.x), tmpvar_80.y);
    f_53 = (tmpvar_85.xy / tmpvar_85.w);
  };
  vec2 tmpvar_86;
  tmpvar_86 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_77);
  v_uv = (v_uv / tmpvar_64);
  v_uv = (v_uv * tmpvar_86);
  if ((tmpvar_76 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec4 tmpvar_87;
  tmpvar_87.xy = tmpvar_77;
  tmpvar_87.zw = tmpvar_78;
  v_uv_bounds = (tmpvar_87 / tmpvar_64.xyxy);
  v_uv = (v_uv / (v_uv_bounds.zw - v_uv_bounds.xy));
  v_tile_repeat = tmpvar_86;
  float tmpvar_88;
  tmpvar_88 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_89;
  bool tmpvar_90;
  tmpvar_90 = bool(0);
  tmpvar_89 = (0 == tmpvar_82);
  if (tmpvar_89) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_88);
    tmpvar_90 = bool(1);
  };
  tmpvar_89 = !(tmpvar_90);
  if (tmpvar_89) {
    image_data_color_59 = (image_data_color_59 * tmpvar_88);
    tmpvar_90 = bool(1);
  };
  bool tmpvar_91;
  bool tmpvar_92;
  tmpvar_92 = bool(0);
  tmpvar_91 = (1 == color_mode_52);
  tmpvar_91 = (tmpvar_91 || (7 == color_mode_52));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (5 == color_mode_52));
  tmpvar_91 = (tmpvar_91 || (9 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (2 == color_mode_52));
  tmpvar_91 = (tmpvar_91 || (3 == color_mode_52));
  tmpvar_91 = (tmpvar_91 || (8 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (4 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (6 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    vec2 tmpvar_93;
    tmpvar_93.y = 0.0;
    tmpvar_93.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_93;
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (10 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    vec2 tmpvar_94;
    tmpvar_94.x = -(image_data_color_59.w);
    tmpvar_94.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_94;
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = !(tmpvar_92);
  if (tmpvar_91) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ADVANCED_BLEND", "ALPHA_PASS", "ANTIALIASING", "REPETITION", "TEXTURE_2D"]

#extension GL_KHR_blend_equation_advanced : enable
layout(blend_support_all_equations) out;
precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec2 v_tile_repeat;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 texel_2;
  vec2 repeated_uv_3;
  vec2 tmpvar_4;
  tmpvar_4 = max ((v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x)), vec2(0.0, 0.0));
  repeated_uv_3 = ((fract(tmpvar_4) * (v_uv_bounds.zw - v_uv_bounds.xy)) + v_uv_bounds.xy);
  if ((tmpvar_4.x >= v_tile_repeat.x)) {
    repeated_uv_3.x = v_uv_bounds.z;
  };
  if ((tmpvar_4.y >= v_tile_repeat.y)) {
    repeated_uv_3.y = v_uv_bounds.w;
  };
  vec4 tmpvar_5;
  tmpvar_5 = texture (sColor0, min (max (repeated_uv_3, v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  texel_2.w = tmpvar_5.w;
  vec2 tmpvar_6;
  tmpvar_6 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  texel_2.xyz = ((tmpvar_5.xyz * v_mask_swizzle.x) + (tmpvar_5.www * v_mask_swizzle.y));
  frag_color_1 = (v_color * (texel_2 * min (
    max ((0.5 - max (tmpvar_6.x, tmpvar_6.y)), 0.0)
  , 1.0)));
  float tmpvar_7;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_7 = 1.0;
  } else {
    vec2 tmpvar_8;
    tmpvar_8 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_9;
    tmpvar_9.xy = greaterThanEqual (tmpvar_8, vClipMaskUvBounds.xy);
    tmpvar_9.zw = lessThan (tmpvar_8, vClipMaskUvBounds.zw);
    bool tmpvar_10;
    tmpvar_10 = (tmpvar_9 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_10)) {
      tmpvar_7 = 0.0;
    } else {
      tmpvar_7 = texelFetch (sClipMask, ivec2(tmpvar_8), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_7);
  oFragColor = frag_color_1;
}

brush_image_ADVANCED_BLEND_ALPHA_PASS_ANTIALIASING_REPETITION_TEXTURE_RECT#version 150
// brush_image
// features: ["ADVANCED_BLEND", "ALPHA_PASS", "ANTIALIASING", "REPETITION", "TEXTURE_RECT"]

#extension GL_KHR_blend_equation_advanced : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2DRect sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  ivec2 tmpvar_64;
  tmpvar_64.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_64.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_65;
  tmpvar_65 = texelFetchOffset (sGpuCache, tmpvar_64, 0, ivec2(0, 0));
  uv0_58 = tmpvar_65.xy;
  uv1_57 = tmpvar_65.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    vec2 tmpvar_66;
    tmpvar_66 = (segment_rect_p1_35 - segment_rect_p0_34);
    stretch_size_54 = tmpvar_66;
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_67;
      tmpvar_67 = (tmpvar_65.zw - tmpvar_65.xy);
      uv0_58 = (tmpvar_65.xy + (segment_data_36.xy * tmpvar_67));
      uv1_57 = (tmpvar_65.xy + (segment_data_36.zw * tmpvar_67));
    };
    if (((tmpvar_38 & 128) != 0)) {
      vec2 vertical_uv_size_68;
      vec2 horizontal_uv_size_69;
      vec2 repeated_stretch_size_70;
      repeated_stretch_size_70 = tmpvar_66;
      vec2 tmpvar_71;
      tmpvar_71 = (uv1_57 - uv0_58);
      horizontal_uv_size_69 = tmpvar_71;
      vec2 tmpvar_72;
      tmpvar_72 = (uv1_57 - uv0_58);
      vertical_uv_size_68 = tmpvar_72;
      if (((tmpvar_38 & 64) != 0)) {
        repeated_stretch_size_70 = (segment_rect_p0_34 - tmpvar_8.xy);
        vertical_uv_size_68.x = (uv0_58.x - tmpvar_65.x);
        if (((vertical_uv_size_68.x < 0.001) || (repeated_stretch_size_70.x < 0.001))) {
          vertical_uv_size_68.x = (tmpvar_65.z - uv1_57.x);
          repeated_stretch_size_70.x = (tmpvar_8.z - segment_rect_p1_35.x);
        };
        horizontal_uv_size_69.y = (uv0_58.y - tmpvar_65.y);
        if (((horizontal_uv_size_69.y < 0.001) || (repeated_stretch_size_70.y < 0.001))) {
          horizontal_uv_size_69.y = (tmpvar_65.w - uv1_57.y);
          repeated_stretch_size_70.y = (tmpvar_8.w - segment_rect_p1_35.y);
        };
      };
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (repeated_stretch_size_70.y * (tmpvar_71.x / horizontal_uv_size_69.y));
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (repeated_stretch_size_70.x * (tmpvar_72.y / vertical_uv_size_68.x));
      };
    } else {
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (segment_data_36.z - segment_data_36.x);
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (segment_data_36.w - segment_data_36.y);
      };
    };
    if (((tmpvar_38 & 16) != 0)) {
      float tmpvar_73;
      tmpvar_73 = (segment_rect_p1_35.x - segment_rect_p0_34.x);
      stretch_size_54.x = (tmpvar_73 / max (1.0, roundEven(
        (tmpvar_73 / stretch_size_54.x)
      )));
    };
    if (((tmpvar_38 & 32) != 0)) {
      float tmpvar_74;
      tmpvar_74 = (segment_rect_p1_35.y - segment_rect_p0_34.y);
      stretch_size_54.y = (tmpvar_74 / max (1.0, roundEven(
        (tmpvar_74 / stretch_size_54.y)
      )));
    };
  };
  float tmpvar_75;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_75 = 1.0;
  } else {
    tmpvar_75 = 0.0;
  };
  v_perspective.x = tmpvar_75;
  vec2 tmpvar_76;
  tmpvar_76 = min (uv0_58, uv1_57);
  vec4 tmpvar_77;
  tmpvar_77.xy = (tmpvar_76 + vec2(0.5, 0.5));
  tmpvar_77.zw = (max (uv0_58, uv1_57) - vec2(0.5, 0.5));
  v_uv_sample_bounds = tmpvar_77;
  vec2 tmpvar_78;
  tmpvar_78 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_78;
  int tmpvar_79;
  tmpvar_79 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_79;
  int tmpvar_80;
  tmpvar_80 = (tmpvar_16.x >> 16);
  if ((tmpvar_79 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_81;
    tmpvar_81 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_82;
    tmpvar_82.x = int((uint(tmpvar_81) % 1024u));
    tmpvar_82.y = int((uint(tmpvar_81) / 1024u));
    vec4 tmpvar_83;
    tmpvar_83 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(1, 0)), tmpvar_78.x), mix (texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(3, 0)), tmpvar_78.x), tmpvar_78.y);
    f_53 = (tmpvar_83.xy / tmpvar_83.w);
  };
  vec2 tmpvar_84;
  tmpvar_84 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_76);
  v_uv = (v_uv * tmpvar_84);
  if ((tmpvar_75 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec2 tmpvar_85;
  tmpvar_85 = vec2(textureSize (sColor0));
  vec4 tmpvar_86;
  tmpvar_86.xy = vec2(0.0, 0.0);
  tmpvar_86.zw = tmpvar_85;
  v_uv_bounds = tmpvar_86;
  v_uv = (v_uv / tmpvar_85);
  v_tile_repeat = tmpvar_84;
  float tmpvar_87;
  tmpvar_87 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_88;
  bool tmpvar_89;
  tmpvar_89 = bool(0);
  tmpvar_88 = (0 == tmpvar_80);
  if (tmpvar_88) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_87);
    tmpvar_89 = bool(1);
  };
  tmpvar_88 = !(tmpvar_89);
  if (tmpvar_88) {
    image_data_color_59 = (image_data_color_59 * tmpvar_87);
    tmpvar_89 = bool(1);
  };
  bool tmpvar_90;
  bool tmpvar_91;
  tmpvar_91 = bool(0);
  tmpvar_90 = (1 == color_mode_52);
  tmpvar_90 = (tmpvar_90 || (7 == color_mode_52));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (5 == color_mode_52));
  tmpvar_90 = (tmpvar_90 || (9 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (2 == color_mode_52));
  tmpvar_90 = (tmpvar_90 || (3 == color_mode_52));
  tmpvar_90 = (tmpvar_90 || (8 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (4 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (6 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    vec2 tmpvar_92;
    tmpvar_92.y = 0.0;
    tmpvar_92.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_92;
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (10 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    vec2 tmpvar_93;
    tmpvar_93.x = -(image_data_color_59.w);
    tmpvar_93.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_93;
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = !(tmpvar_91);
  if (tmpvar_90) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ADVANCED_BLEND", "ALPHA_PASS", "ANTIALIASING", "REPETITION", "TEXTURE_RECT"]

#extension GL_KHR_blend_equation_advanced : enable
layout(blend_support_all_equations) out;
precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec2 v_tile_repeat;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 texel_2;
  vec2 repeated_uv_3;
  vec2 tmpvar_4;
  tmpvar_4 = max ((v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x)), vec2(0.0, 0.0));
  repeated_uv_3 = ((fract(tmpvar_4) * (v_uv_bounds.zw - v_uv_bounds.xy)) + v_uv_bounds.xy);
  if ((tmpvar_4.x >= v_tile_repeat.x)) {
    repeated_uv_3.x = v_uv_bounds.z;
  };
  if ((tmpvar_4.y >= v_tile_repeat.y)) {
    repeated_uv_3.y = v_uv_bounds.w;
  };
  vec4 tmpvar_5;
  tmpvar_5 = texture (sColor0, min (max (repeated_uv_3, v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  texel_2.w = tmpvar_5.w;
  vec2 tmpvar_6;
  tmpvar_6 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  texel_2.xyz = ((tmpvar_5.xyz * v_mask_swizzle.x) + (tmpvar_5.www * v_mask_swizzle.y));
  frag_color_1 = (v_color * (texel_2 * min (
    max ((0.5 - max (tmpvar_6.x, tmpvar_6.y)), 0.0)
  , 1.0)));
  float tmpvar_7;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_7 = 1.0;
  } else {
    vec2 tmpvar_8;
    tmpvar_8 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_9;
    tmpvar_9.xy = greaterThanEqual (tmpvar_8, vClipMaskUvBounds.xy);
    tmpvar_9.zw = lessThan (tmpvar_8, vClipMaskUvBounds.zw);
    bool tmpvar_10;
    tmpvar_10 = (tmpvar_9 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_10)) {
      tmpvar_7 = 0.0;
    } else {
      tmpvar_7 = texelFetch (sClipMask, ivec2(tmpvar_8), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_7);
  oFragColor = frag_color_1;
}

brush_image_ADVANCED_BLEND_ALPHA_PASS_TEXTURE_2D#version 150
// brush_image
// features: ["ADVANCED_BLEND", "ALPHA_PASS", "TEXTURE_2D"]

#extension GL_KHR_blend_equation_advanced : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  vec2 tmpvar_64;
  tmpvar_64 = vec2(textureSize (sColor0, 0));
  ivec2 tmpvar_65;
  tmpvar_65.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_65.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_66;
  tmpvar_66 = texelFetchOffset (sGpuCache, tmpvar_65, 0, ivec2(0, 0));
  uv0_58 = tmpvar_66.xy;
  uv1_57 = tmpvar_66.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    stretch_size_54 = (segment_rect_p1_35 - segment_rect_p0_34);
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_67;
      tmpvar_67 = (tmpvar_66.zw - tmpvar_66.xy);
      uv0_58 = (tmpvar_66.xy + (segment_data_36.xy * tmpvar_67));
      uv1_57 = (tmpvar_66.xy + (segment_data_36.zw * tmpvar_67));
    };
  };
  float tmpvar_68;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_68 = 1.0;
  } else {
    tmpvar_68 = 0.0;
  };
  v_perspective.x = tmpvar_68;
  vec2 tmpvar_69;
  tmpvar_69 = min (uv0_58, uv1_57);
  vec2 tmpvar_70;
  tmpvar_70 = max (uv0_58, uv1_57);
  vec4 tmpvar_71;
  tmpvar_71.xy = (tmpvar_69 + vec2(0.5, 0.5));
  tmpvar_71.zw = (tmpvar_70 - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_71 / tmpvar_64.xyxy);
  vec2 tmpvar_72;
  tmpvar_72 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_72;
  int tmpvar_73;
  tmpvar_73 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_73;
  int tmpvar_74;
  tmpvar_74 = (tmpvar_16.x >> 16);
  if ((tmpvar_73 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_75;
    tmpvar_75 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_76;
    tmpvar_76.x = int((uint(tmpvar_75) % 1024u));
    tmpvar_76.y = int((uint(tmpvar_75) / 1024u));
    vec4 tmpvar_77;
    tmpvar_77 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(1, 0)), tmpvar_72.x), mix (texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(3, 0)), tmpvar_72.x), tmpvar_72.y);
    f_53 = (tmpvar_77.xy / tmpvar_77.w);
  };
  vec2 tmpvar_78;
  tmpvar_78 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_69);
  v_uv = (v_uv / tmpvar_64);
  v_uv = (v_uv * tmpvar_78);
  if ((tmpvar_68 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec4 tmpvar_79;
  tmpvar_79.xy = tmpvar_69;
  tmpvar_79.zw = tmpvar_70;
  v_uv_bounds = (tmpvar_79 / tmpvar_64.xyxy);
  v_tile_repeat = tmpvar_78;
  float tmpvar_80;
  tmpvar_80 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_81;
  bool tmpvar_82;
  tmpvar_82 = bool(0);
  tmpvar_81 = (0 == tmpvar_74);
  if (tmpvar_81) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_80);
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = !(tmpvar_82);
  if (tmpvar_81) {
    image_data_color_59 = (image_data_color_59 * tmpvar_80);
    tmpvar_82 = bool(1);
  };
  bool tmpvar_83;
  bool tmpvar_84;
  tmpvar_84 = bool(0);
  tmpvar_83 = (1 == color_mode_52);
  tmpvar_83 = (tmpvar_83 || (7 == color_mode_52));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (5 == color_mode_52));
  tmpvar_83 = (tmpvar_83 || (9 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (2 == color_mode_52));
  tmpvar_83 = (tmpvar_83 || (3 == color_mode_52));
  tmpvar_83 = (tmpvar_83 || (8 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (4 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (6 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    vec2 tmpvar_85;
    tmpvar_85.y = 0.0;
    tmpvar_85.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_85;
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (10 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    vec2 tmpvar_86;
    tmpvar_86.x = -(image_data_color_59.w);
    tmpvar_86.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_86;
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = !(tmpvar_84);
  if (tmpvar_83) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ADVANCED_BLEND", "ALPHA_PASS", "TEXTURE_2D"]

#extension GL_KHR_blend_equation_advanced : enable
layout(blend_support_all_equations) out;
precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 texel_2;
  vec4 tmpvar_3;
  tmpvar_3 = texture (sColor0, min (max ((
    (v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x))
   + v_uv_bounds.xy), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  texel_2.w = tmpvar_3.w;
  texel_2.xyz = ((tmpvar_3.xyz * v_mask_swizzle.x) + (tmpvar_3.www * v_mask_swizzle.y));
  frag_color_1 = (v_color * texel_2);
  float tmpvar_4;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_4 = 1.0;
  } else {
    vec2 tmpvar_5;
    tmpvar_5 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_6;
    tmpvar_6.xy = greaterThanEqual (tmpvar_5, vClipMaskUvBounds.xy);
    tmpvar_6.zw = lessThan (tmpvar_5, vClipMaskUvBounds.zw);
    bool tmpvar_7;
    tmpvar_7 = (tmpvar_6 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_7)) {
      tmpvar_4 = 0.0;
    } else {
      tmpvar_4 = texelFetch (sClipMask, ivec2(tmpvar_5), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_4);
  oFragColor = frag_color_1;
}

brush_image_ADVANCED_BLEND_ALPHA_PASS_TEXTURE_RECT#version 150
// brush_image
// features: ["ADVANCED_BLEND", "ALPHA_PASS", "TEXTURE_RECT"]

#extension GL_KHR_blend_equation_advanced : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2DRect sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  ivec2 tmpvar_64;
  tmpvar_64.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_64.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_65;
  tmpvar_65 = texelFetchOffset (sGpuCache, tmpvar_64, 0, ivec2(0, 0));
  uv0_58 = tmpvar_65.xy;
  uv1_57 = tmpvar_65.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    stretch_size_54 = (segment_rect_p1_35 - segment_rect_p0_34);
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_66;
      tmpvar_66 = (tmpvar_65.zw - tmpvar_65.xy);
      uv0_58 = (tmpvar_65.xy + (segment_data_36.xy * tmpvar_66));
      uv1_57 = (tmpvar_65.xy + (segment_data_36.zw * tmpvar_66));
    };
  };
  float tmpvar_67;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_67 = 1.0;
  } else {
    tmpvar_67 = 0.0;
  };
  v_perspective.x = tmpvar_67;
  vec2 tmpvar_68;
  tmpvar_68 = min (uv0_58, uv1_57);
  vec4 tmpvar_69;
  tmpvar_69.xy = (tmpvar_68 + vec2(0.5, 0.5));
  tmpvar_69.zw = (max (uv0_58, uv1_57) - vec2(0.5, 0.5));
  v_uv_sample_bounds = tmpvar_69;
  vec2 tmpvar_70;
  tmpvar_70 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_70;
  int tmpvar_71;
  tmpvar_71 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_71;
  int tmpvar_72;
  tmpvar_72 = (tmpvar_16.x >> 16);
  if ((tmpvar_71 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_73;
    tmpvar_73 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_74;
    tmpvar_74.x = int((uint(tmpvar_73) % 1024u));
    tmpvar_74.y = int((uint(tmpvar_73) / 1024u));
    vec4 tmpvar_75;
    tmpvar_75 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(1, 0)), tmpvar_70.x), mix (texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(3, 0)), tmpvar_70.x), tmpvar_70.y);
    f_53 = (tmpvar_75.xy / tmpvar_75.w);
  };
  vec2 tmpvar_76;
  tmpvar_76 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_68);
  v_uv = (v_uv * tmpvar_76);
  if ((tmpvar_67 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec4 tmpvar_77;
  tmpvar_77.xy = vec2(0.0, 0.0);
  tmpvar_77.zw = vec2(textureSize (sColor0));
  v_uv_bounds = tmpvar_77;
  v_tile_repeat = tmpvar_76;
  float tmpvar_78;
  tmpvar_78 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_79;
  bool tmpvar_80;
  tmpvar_80 = bool(0);
  tmpvar_79 = (0 == tmpvar_72);
  if (tmpvar_79) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_78);
    tmpvar_80 = bool(1);
  };
  tmpvar_79 = !(tmpvar_80);
  if (tmpvar_79) {
    image_data_color_59 = (image_data_color_59 * tmpvar_78);
    tmpvar_80 = bool(1);
  };
  bool tmpvar_81;
  bool tmpvar_82;
  tmpvar_82 = bool(0);
  tmpvar_81 = (1 == color_mode_52);
  tmpvar_81 = (tmpvar_81 || (7 == color_mode_52));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (5 == color_mode_52));
  tmpvar_81 = (tmpvar_81 || (9 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (2 == color_mode_52));
  tmpvar_81 = (tmpvar_81 || (3 == color_mode_52));
  tmpvar_81 = (tmpvar_81 || (8 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (4 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (6 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    vec2 tmpvar_83;
    tmpvar_83.y = 0.0;
    tmpvar_83.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_83;
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (10 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    vec2 tmpvar_84;
    tmpvar_84.x = -(image_data_color_59.w);
    tmpvar_84.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_84;
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = !(tmpvar_82);
  if (tmpvar_81) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ADVANCED_BLEND", "ALPHA_PASS", "TEXTURE_RECT"]

#extension GL_KHR_blend_equation_advanced : enable
layout(blend_support_all_equations) out;
precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 texel_2;
  vec4 tmpvar_3;
  tmpvar_3 = texture (sColor0, min (max ((
    (v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x))
   + v_uv_bounds.xy), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  texel_2.w = tmpvar_3.w;
  texel_2.xyz = ((tmpvar_3.xyz * v_mask_swizzle.x) + (tmpvar_3.www * v_mask_swizzle.y));
  frag_color_1 = (v_color * texel_2);
  float tmpvar_4;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_4 = 1.0;
  } else {
    vec2 tmpvar_5;
    tmpvar_5 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_6;
    tmpvar_6.xy = greaterThanEqual (tmpvar_5, vClipMaskUvBounds.xy);
    tmpvar_6.zw = lessThan (tmpvar_5, vClipMaskUvBounds.zw);
    bool tmpvar_7;
    tmpvar_7 = (tmpvar_6 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_7)) {
      tmpvar_4 = 0.0;
    } else {
      tmpvar_4 = texelFetch (sClipMask, ivec2(tmpvar_5), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_4);
  oFragColor = frag_color_1;
}

brush_image_ALPHA_PASS_ANTIALIASING_DUAL_SOURCE_BLENDING_REPETITION_TEXTURE_2D#version 150
// brush_image
// features: ["ALPHA_PASS", "ANTIALIASING", "DUAL_SOURCE_BLENDING", "REPETITION", "TEXTURE_2D"]

#extension GL_ARB_explicit_attrib_location : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  vec2 tmpvar_64;
  tmpvar_64 = vec2(textureSize (sColor0, 0));
  ivec2 tmpvar_65;
  tmpvar_65.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_65.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_66;
  tmpvar_66 = texelFetchOffset (sGpuCache, tmpvar_65, 0, ivec2(0, 0));
  uv0_58 = tmpvar_66.xy;
  uv1_57 = tmpvar_66.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    vec2 tmpvar_67;
    tmpvar_67 = (segment_rect_p1_35 - segment_rect_p0_34);
    stretch_size_54 = tmpvar_67;
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_68;
      tmpvar_68 = (tmpvar_66.zw - tmpvar_66.xy);
      uv0_58 = (tmpvar_66.xy + (segment_data_36.xy * tmpvar_68));
      uv1_57 = (tmpvar_66.xy + (segment_data_36.zw * tmpvar_68));
    };
    if (((tmpvar_38 & 128) != 0)) {
      vec2 vertical_uv_size_69;
      vec2 horizontal_uv_size_70;
      vec2 repeated_stretch_size_71;
      repeated_stretch_size_71 = tmpvar_67;
      vec2 tmpvar_72;
      tmpvar_72 = (uv1_57 - uv0_58);
      horizontal_uv_size_70 = tmpvar_72;
      vec2 tmpvar_73;
      tmpvar_73 = (uv1_57 - uv0_58);
      vertical_uv_size_69 = tmpvar_73;
      if (((tmpvar_38 & 64) != 0)) {
        repeated_stretch_size_71 = (segment_rect_p0_34 - tmpvar_8.xy);
        vertical_uv_size_69.x = (uv0_58.x - tmpvar_66.x);
        if (((vertical_uv_size_69.x < 0.001) || (repeated_stretch_size_71.x < 0.001))) {
          vertical_uv_size_69.x = (tmpvar_66.z - uv1_57.x);
          repeated_stretch_size_71.x = (tmpvar_8.z - segment_rect_p1_35.x);
        };
        horizontal_uv_size_70.y = (uv0_58.y - tmpvar_66.y);
        if (((horizontal_uv_size_70.y < 0.001) || (repeated_stretch_size_71.y < 0.001))) {
          horizontal_uv_size_70.y = (tmpvar_66.w - uv1_57.y);
          repeated_stretch_size_71.y = (tmpvar_8.w - segment_rect_p1_35.y);
        };
      };
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (repeated_stretch_size_71.y * (tmpvar_72.x / horizontal_uv_size_70.y));
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (repeated_stretch_size_71.x * (tmpvar_73.y / vertical_uv_size_69.x));
      };
    } else {
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (segment_data_36.z - segment_data_36.x);
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (segment_data_36.w - segment_data_36.y);
      };
    };
    if (((tmpvar_38 & 16) != 0)) {
      float tmpvar_74;
      tmpvar_74 = (segment_rect_p1_35.x - segment_rect_p0_34.x);
      stretch_size_54.x = (tmpvar_74 / max (1.0, roundEven(
        (tmpvar_74 / stretch_size_54.x)
      )));
    };
    if (((tmpvar_38 & 32) != 0)) {
      float tmpvar_75;
      tmpvar_75 = (segment_rect_p1_35.y - segment_rect_p0_34.y);
      stretch_size_54.y = (tmpvar_75 / max (1.0, roundEven(
        (tmpvar_75 / stretch_size_54.y)
      )));
    };
  };
  float tmpvar_76;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_76 = 1.0;
  } else {
    tmpvar_76 = 0.0;
  };
  v_perspective.x = tmpvar_76;
  vec2 tmpvar_77;
  tmpvar_77 = min (uv0_58, uv1_57);
  vec2 tmpvar_78;
  tmpvar_78 = max (uv0_58, uv1_57);
  vec4 tmpvar_79;
  tmpvar_79.xy = (tmpvar_77 + vec2(0.5, 0.5));
  tmpvar_79.zw = (tmpvar_78 - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_79 / tmpvar_64.xyxy);
  vec2 tmpvar_80;
  tmpvar_80 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_80;
  int tmpvar_81;
  tmpvar_81 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_81;
  int tmpvar_82;
  tmpvar_82 = (tmpvar_16.x >> 16);
  if ((tmpvar_81 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_83;
    tmpvar_83 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_84;
    tmpvar_84.x = int((uint(tmpvar_83) % 1024u));
    tmpvar_84.y = int((uint(tmpvar_83) / 1024u));
    vec4 tmpvar_85;
    tmpvar_85 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(1, 0)), tmpvar_80.x), mix (texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(3, 0)), tmpvar_80.x), tmpvar_80.y);
    f_53 = (tmpvar_85.xy / tmpvar_85.w);
  };
  vec2 tmpvar_86;
  tmpvar_86 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_77);
  v_uv = (v_uv / tmpvar_64);
  v_uv = (v_uv * tmpvar_86);
  if ((tmpvar_76 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec4 tmpvar_87;
  tmpvar_87.xy = tmpvar_77;
  tmpvar_87.zw = tmpvar_78;
  v_uv_bounds = (tmpvar_87 / tmpvar_64.xyxy);
  v_uv = (v_uv / (v_uv_bounds.zw - v_uv_bounds.xy));
  v_tile_repeat = tmpvar_86;
  float tmpvar_88;
  tmpvar_88 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_89;
  bool tmpvar_90;
  tmpvar_90 = bool(0);
  tmpvar_89 = (0 == tmpvar_82);
  if (tmpvar_89) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_88);
    tmpvar_90 = bool(1);
  };
  tmpvar_89 = !(tmpvar_90);
  if (tmpvar_89) {
    image_data_color_59 = (image_data_color_59 * tmpvar_88);
    tmpvar_90 = bool(1);
  };
  bool tmpvar_91;
  bool tmpvar_92;
  tmpvar_92 = bool(0);
  tmpvar_91 = (1 == color_mode_52);
  tmpvar_91 = (tmpvar_91 || (7 == color_mode_52));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (5 == color_mode_52));
  tmpvar_91 = (tmpvar_91 || (9 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (2 == color_mode_52));
  tmpvar_91 = (tmpvar_91 || (3 == color_mode_52));
  tmpvar_91 = (tmpvar_91 || (8 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (4 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (6 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    vec2 tmpvar_93;
    tmpvar_93.y = 0.0;
    tmpvar_93.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_93;
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (10 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    vec2 tmpvar_94;
    tmpvar_94.x = -(image_data_color_59.w);
    tmpvar_94.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_94;
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = !(tmpvar_92);
  if (tmpvar_91) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ALPHA_PASS", "ANTIALIASING", "DUAL_SOURCE_BLENDING", "REPETITION", "TEXTURE_2D"]

#extension GL_ARB_explicit_attrib_location : enable
precision highp float;
layout(location=0, index=0) out vec4 oFragColor;
layout(location=0, index=1) out vec4 oFragBlend;
uniform sampler2D sColor0;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec2 v_tile_repeat;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 frag_blend_2;
  vec2 repeated_uv_3;
  vec2 tmpvar_4;
  tmpvar_4 = max ((v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x)), vec2(0.0, 0.0));
  repeated_uv_3 = ((fract(tmpvar_4) * (v_uv_bounds.zw - v_uv_bounds.xy)) + v_uv_bounds.xy);
  if ((tmpvar_4.x >= v_tile_repeat.x)) {
    repeated_uv_3.x = v_uv_bounds.z;
  };
  if ((tmpvar_4.y >= v_tile_repeat.y)) {
    repeated_uv_3.y = v_uv_bounds.w;
  };
  vec2 tmpvar_5;
  tmpvar_5 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  vec4 tmpvar_6;
  tmpvar_6 = (texture (sColor0, min (max (repeated_uv_3, v_uv_sample_bounds.xy), v_uv_sample_bounds.zw)) * min (max (
    (0.5 - max (tmpvar_5.x, tmpvar_5.y))
  , 0.0), 1.0));
  frag_color_1 = (v_color * tmpvar_6);
  frag_blend_2 = ((tmpvar_6 * v_mask_swizzle.x) + (tmpvar_6.wwww * v_mask_swizzle.y));
  float tmpvar_7;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_7 = 1.0;
  } else {
    vec2 tmpvar_8;
    tmpvar_8 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_9;
    tmpvar_9.xy = greaterThanEqual (tmpvar_8, vClipMaskUvBounds.xy);
    tmpvar_9.zw = lessThan (tmpvar_8, vClipMaskUvBounds.zw);
    bool tmpvar_10;
    tmpvar_10 = (tmpvar_9 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_10)) {
      tmpvar_7 = 0.0;
    } else {
      tmpvar_7 = texelFetch (sClipMask, ivec2(tmpvar_8), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_7);
  oFragBlend = (frag_blend_2 * tmpvar_7);
  oFragColor = frag_color_1;
}

brush_image_ALPHA_PASS_ANTIALIASING_DUAL_SOURCE_BLENDING_REPETITION_TEXTURE_RECT#version 150
// brush_image
// features: ["ALPHA_PASS", "ANTIALIASING", "DUAL_SOURCE_BLENDING", "REPETITION", "TEXTURE_RECT"]

#extension GL_ARB_explicit_attrib_location : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2DRect sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  ivec2 tmpvar_64;
  tmpvar_64.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_64.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_65;
  tmpvar_65 = texelFetchOffset (sGpuCache, tmpvar_64, 0, ivec2(0, 0));
  uv0_58 = tmpvar_65.xy;
  uv1_57 = tmpvar_65.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    vec2 tmpvar_66;
    tmpvar_66 = (segment_rect_p1_35 - segment_rect_p0_34);
    stretch_size_54 = tmpvar_66;
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_67;
      tmpvar_67 = (tmpvar_65.zw - tmpvar_65.xy);
      uv0_58 = (tmpvar_65.xy + (segment_data_36.xy * tmpvar_67));
      uv1_57 = (tmpvar_65.xy + (segment_data_36.zw * tmpvar_67));
    };
    if (((tmpvar_38 & 128) != 0)) {
      vec2 vertical_uv_size_68;
      vec2 horizontal_uv_size_69;
      vec2 repeated_stretch_size_70;
      repeated_stretch_size_70 = tmpvar_66;
      vec2 tmpvar_71;
      tmpvar_71 = (uv1_57 - uv0_58);
      horizontal_uv_size_69 = tmpvar_71;
      vec2 tmpvar_72;
      tmpvar_72 = (uv1_57 - uv0_58);
      vertical_uv_size_68 = tmpvar_72;
      if (((tmpvar_38 & 64) != 0)) {
        repeated_stretch_size_70 = (segment_rect_p0_34 - tmpvar_8.xy);
        vertical_uv_size_68.x = (uv0_58.x - tmpvar_65.x);
        if (((vertical_uv_size_68.x < 0.001) || (repeated_stretch_size_70.x < 0.001))) {
          vertical_uv_size_68.x = (tmpvar_65.z - uv1_57.x);
          repeated_stretch_size_70.x = (tmpvar_8.z - segment_rect_p1_35.x);
        };
        horizontal_uv_size_69.y = (uv0_58.y - tmpvar_65.y);
        if (((horizontal_uv_size_69.y < 0.001) || (repeated_stretch_size_70.y < 0.001))) {
          horizontal_uv_size_69.y = (tmpvar_65.w - uv1_57.y);
          repeated_stretch_size_70.y = (tmpvar_8.w - segment_rect_p1_35.y);
        };
      };
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (repeated_stretch_size_70.y * (tmpvar_71.x / horizontal_uv_size_69.y));
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (repeated_stretch_size_70.x * (tmpvar_72.y / vertical_uv_size_68.x));
      };
    } else {
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (segment_data_36.z - segment_data_36.x);
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (segment_data_36.w - segment_data_36.y);
      };
    };
    if (((tmpvar_38 & 16) != 0)) {
      float tmpvar_73;
      tmpvar_73 = (segment_rect_p1_35.x - segment_rect_p0_34.x);
      stretch_size_54.x = (tmpvar_73 / max (1.0, roundEven(
        (tmpvar_73 / stretch_size_54.x)
      )));
    };
    if (((tmpvar_38 & 32) != 0)) {
      float tmpvar_74;
      tmpvar_74 = (segment_rect_p1_35.y - segment_rect_p0_34.y);
      stretch_size_54.y = (tmpvar_74 / max (1.0, roundEven(
        (tmpvar_74 / stretch_size_54.y)
      )));
    };
  };
  float tmpvar_75;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_75 = 1.0;
  } else {
    tmpvar_75 = 0.0;
  };
  v_perspective.x = tmpvar_75;
  vec2 tmpvar_76;
  tmpvar_76 = min (uv0_58, uv1_57);
  vec4 tmpvar_77;
  tmpvar_77.xy = (tmpvar_76 + vec2(0.5, 0.5));
  tmpvar_77.zw = (max (uv0_58, uv1_57) - vec2(0.5, 0.5));
  v_uv_sample_bounds = tmpvar_77;
  vec2 tmpvar_78;
  tmpvar_78 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_78;
  int tmpvar_79;
  tmpvar_79 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_79;
  int tmpvar_80;
  tmpvar_80 = (tmpvar_16.x >> 16);
  if ((tmpvar_79 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_81;
    tmpvar_81 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_82;
    tmpvar_82.x = int((uint(tmpvar_81) % 1024u));
    tmpvar_82.y = int((uint(tmpvar_81) / 1024u));
    vec4 tmpvar_83;
    tmpvar_83 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(1, 0)), tmpvar_78.x), mix (texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(3, 0)), tmpvar_78.x), tmpvar_78.y);
    f_53 = (tmpvar_83.xy / tmpvar_83.w);
  };
  vec2 tmpvar_84;
  tmpvar_84 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_76);
  v_uv = (v_uv * tmpvar_84);
  if ((tmpvar_75 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec2 tmpvar_85;
  tmpvar_85 = vec2(textureSize (sColor0));
  vec4 tmpvar_86;
  tmpvar_86.xy = vec2(0.0, 0.0);
  tmpvar_86.zw = tmpvar_85;
  v_uv_bounds = tmpvar_86;
  v_uv = (v_uv / tmpvar_85);
  v_tile_repeat = tmpvar_84;
  float tmpvar_87;
  tmpvar_87 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_88;
  bool tmpvar_89;
  tmpvar_89 = bool(0);
  tmpvar_88 = (0 == tmpvar_80);
  if (tmpvar_88) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_87);
    tmpvar_89 = bool(1);
  };
  tmpvar_88 = !(tmpvar_89);
  if (tmpvar_88) {
    image_data_color_59 = (image_data_color_59 * tmpvar_87);
    tmpvar_89 = bool(1);
  };
  bool tmpvar_90;
  bool tmpvar_91;
  tmpvar_91 = bool(0);
  tmpvar_90 = (1 == color_mode_52);
  tmpvar_90 = (tmpvar_90 || (7 == color_mode_52));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (5 == color_mode_52));
  tmpvar_90 = (tmpvar_90 || (9 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (2 == color_mode_52));
  tmpvar_90 = (tmpvar_90 || (3 == color_mode_52));
  tmpvar_90 = (tmpvar_90 || (8 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (4 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (6 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    vec2 tmpvar_92;
    tmpvar_92.y = 0.0;
    tmpvar_92.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_92;
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (10 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    vec2 tmpvar_93;
    tmpvar_93.x = -(image_data_color_59.w);
    tmpvar_93.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_93;
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = !(tmpvar_91);
  if (tmpvar_90) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ALPHA_PASS", "ANTIALIASING", "DUAL_SOURCE_BLENDING", "REPETITION", "TEXTURE_RECT"]

#extension GL_ARB_explicit_attrib_location : enable
precision highp float;
layout(location=0, index=0) out vec4 oFragColor;
layout(location=0, index=1) out vec4 oFragBlend;
uniform sampler2DRect sColor0;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec2 v_tile_repeat;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 frag_blend_2;
  vec2 repeated_uv_3;
  vec2 tmpvar_4;
  tmpvar_4 = max ((v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x)), vec2(0.0, 0.0));
  repeated_uv_3 = ((fract(tmpvar_4) * (v_uv_bounds.zw - v_uv_bounds.xy)) + v_uv_bounds.xy);
  if ((tmpvar_4.x >= v_tile_repeat.x)) {
    repeated_uv_3.x = v_uv_bounds.z;
  };
  if ((tmpvar_4.y >= v_tile_repeat.y)) {
    repeated_uv_3.y = v_uv_bounds.w;
  };
  vec2 tmpvar_5;
  tmpvar_5 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  vec4 tmpvar_6;
  tmpvar_6 = (texture (sColor0, min (max (repeated_uv_3, v_uv_sample_bounds.xy), v_uv_sample_bounds.zw)) * min (max (
    (0.5 - max (tmpvar_5.x, tmpvar_5.y))
  , 0.0), 1.0));
  frag_color_1 = (v_color * tmpvar_6);
  frag_blend_2 = ((tmpvar_6 * v_mask_swizzle.x) + (tmpvar_6.wwww * v_mask_swizzle.y));
  float tmpvar_7;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_7 = 1.0;
  } else {
    vec2 tmpvar_8;
    tmpvar_8 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_9;
    tmpvar_9.xy = greaterThanEqual (tmpvar_8, vClipMaskUvBounds.xy);
    tmpvar_9.zw = lessThan (tmpvar_8, vClipMaskUvBounds.zw);
    bool tmpvar_10;
    tmpvar_10 = (tmpvar_9 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_10)) {
      tmpvar_7 = 0.0;
    } else {
      tmpvar_7 = texelFetch (sClipMask, ivec2(tmpvar_8), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_7);
  oFragBlend = (frag_blend_2 * tmpvar_7);
  oFragColor = frag_color_1;
}

brush_image_ALPHA_PASS_ANTIALIASING_REPETITION_TEXTURE_2D#version 150
// brush_image
// features: ["ALPHA_PASS", "ANTIALIASING", "REPETITION", "TEXTURE_2D"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  vec2 tmpvar_64;
  tmpvar_64 = vec2(textureSize (sColor0, 0));
  ivec2 tmpvar_65;
  tmpvar_65.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_65.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_66;
  tmpvar_66 = texelFetchOffset (sGpuCache, tmpvar_65, 0, ivec2(0, 0));
  uv0_58 = tmpvar_66.xy;
  uv1_57 = tmpvar_66.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    vec2 tmpvar_67;
    tmpvar_67 = (segment_rect_p1_35 - segment_rect_p0_34);
    stretch_size_54 = tmpvar_67;
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_68;
      tmpvar_68 = (tmpvar_66.zw - tmpvar_66.xy);
      uv0_58 = (tmpvar_66.xy + (segment_data_36.xy * tmpvar_68));
      uv1_57 = (tmpvar_66.xy + (segment_data_36.zw * tmpvar_68));
    };
    if (((tmpvar_38 & 128) != 0)) {
      vec2 vertical_uv_size_69;
      vec2 horizontal_uv_size_70;
      vec2 repeated_stretch_size_71;
      repeated_stretch_size_71 = tmpvar_67;
      vec2 tmpvar_72;
      tmpvar_72 = (uv1_57 - uv0_58);
      horizontal_uv_size_70 = tmpvar_72;
      vec2 tmpvar_73;
      tmpvar_73 = (uv1_57 - uv0_58);
      vertical_uv_size_69 = tmpvar_73;
      if (((tmpvar_38 & 64) != 0)) {
        repeated_stretch_size_71 = (segment_rect_p0_34 - tmpvar_8.xy);
        vertical_uv_size_69.x = (uv0_58.x - tmpvar_66.x);
        if (((vertical_uv_size_69.x < 0.001) || (repeated_stretch_size_71.x < 0.001))) {
          vertical_uv_size_69.x = (tmpvar_66.z - uv1_57.x);
          repeated_stretch_size_71.x = (tmpvar_8.z - segment_rect_p1_35.x);
        };
        horizontal_uv_size_70.y = (uv0_58.y - tmpvar_66.y);
        if (((horizontal_uv_size_70.y < 0.001) || (repeated_stretch_size_71.y < 0.001))) {
          horizontal_uv_size_70.y = (tmpvar_66.w - uv1_57.y);
          repeated_stretch_size_71.y = (tmpvar_8.w - segment_rect_p1_35.y);
        };
      };
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (repeated_stretch_size_71.y * (tmpvar_72.x / horizontal_uv_size_70.y));
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (repeated_stretch_size_71.x * (tmpvar_73.y / vertical_uv_size_69.x));
      };
    } else {
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (segment_data_36.z - segment_data_36.x);
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (segment_data_36.w - segment_data_36.y);
      };
    };
    if (((tmpvar_38 & 16) != 0)) {
      float tmpvar_74;
      tmpvar_74 = (segment_rect_p1_35.x - segment_rect_p0_34.x);
      stretch_size_54.x = (tmpvar_74 / max (1.0, roundEven(
        (tmpvar_74 / stretch_size_54.x)
      )));
    };
    if (((tmpvar_38 & 32) != 0)) {
      float tmpvar_75;
      tmpvar_75 = (segment_rect_p1_35.y - segment_rect_p0_34.y);
      stretch_size_54.y = (tmpvar_75 / max (1.0, roundEven(
        (tmpvar_75 / stretch_size_54.y)
      )));
    };
  };
  float tmpvar_76;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_76 = 1.0;
  } else {
    tmpvar_76 = 0.0;
  };
  v_perspective.x = tmpvar_76;
  vec2 tmpvar_77;
  tmpvar_77 = min (uv0_58, uv1_57);
  vec2 tmpvar_78;
  tmpvar_78 = max (uv0_58, uv1_57);
  vec4 tmpvar_79;
  tmpvar_79.xy = (tmpvar_77 + vec2(0.5, 0.5));
  tmpvar_79.zw = (tmpvar_78 - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_79 / tmpvar_64.xyxy);
  vec2 tmpvar_80;
  tmpvar_80 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_80;
  int tmpvar_81;
  tmpvar_81 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_81;
  int tmpvar_82;
  tmpvar_82 = (tmpvar_16.x >> 16);
  if ((tmpvar_81 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_83;
    tmpvar_83 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_84;
    tmpvar_84.x = int((uint(tmpvar_83) % 1024u));
    tmpvar_84.y = int((uint(tmpvar_83) / 1024u));
    vec4 tmpvar_85;
    tmpvar_85 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(1, 0)), tmpvar_80.x), mix (texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(3, 0)), tmpvar_80.x), tmpvar_80.y);
    f_53 = (tmpvar_85.xy / tmpvar_85.w);
  };
  vec2 tmpvar_86;
  tmpvar_86 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_77);
  v_uv = (v_uv / tmpvar_64);
  v_uv = (v_uv * tmpvar_86);
  if ((tmpvar_76 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec4 tmpvar_87;
  tmpvar_87.xy = tmpvar_77;
  tmpvar_87.zw = tmpvar_78;
  v_uv_bounds = (tmpvar_87 / tmpvar_64.xyxy);
  v_uv = (v_uv / (v_uv_bounds.zw - v_uv_bounds.xy));
  v_tile_repeat = tmpvar_86;
  float tmpvar_88;
  tmpvar_88 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_89;
  bool tmpvar_90;
  tmpvar_90 = bool(0);
  tmpvar_89 = (0 == tmpvar_82);
  if (tmpvar_89) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_88);
    tmpvar_90 = bool(1);
  };
  tmpvar_89 = !(tmpvar_90);
  if (tmpvar_89) {
    image_data_color_59 = (image_data_color_59 * tmpvar_88);
    tmpvar_90 = bool(1);
  };
  bool tmpvar_91;
  bool tmpvar_92;
  tmpvar_92 = bool(0);
  tmpvar_91 = (1 == color_mode_52);
  tmpvar_91 = (tmpvar_91 || (7 == color_mode_52));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (5 == color_mode_52));
  tmpvar_91 = (tmpvar_91 || (9 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (2 == color_mode_52));
  tmpvar_91 = (tmpvar_91 || (3 == color_mode_52));
  tmpvar_91 = (tmpvar_91 || (8 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (4 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (6 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    vec2 tmpvar_93;
    tmpvar_93.y = 0.0;
    tmpvar_93.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_93;
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = (tmpvar_91 || (10 == color_mode_52));
  tmpvar_91 = (tmpvar_91 && !(tmpvar_92));
  if (tmpvar_91) {
    vec2 tmpvar_94;
    tmpvar_94.x = -(image_data_color_59.w);
    tmpvar_94.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_94;
    v_color = image_data_color_59;
    tmpvar_92 = bool(1);
  };
  tmpvar_91 = !(tmpvar_92);
  if (tmpvar_91) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ALPHA_PASS", "ANTIALIASING", "REPETITION", "TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec2 v_tile_repeat;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 texel_2;
  vec2 repeated_uv_3;
  vec2 tmpvar_4;
  tmpvar_4 = max ((v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x)), vec2(0.0, 0.0));
  repeated_uv_3 = ((fract(tmpvar_4) * (v_uv_bounds.zw - v_uv_bounds.xy)) + v_uv_bounds.xy);
  if ((tmpvar_4.x >= v_tile_repeat.x)) {
    repeated_uv_3.x = v_uv_bounds.z;
  };
  if ((tmpvar_4.y >= v_tile_repeat.y)) {
    repeated_uv_3.y = v_uv_bounds.w;
  };
  vec4 tmpvar_5;
  tmpvar_5 = texture (sColor0, min (max (repeated_uv_3, v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  texel_2.w = tmpvar_5.w;
  vec2 tmpvar_6;
  tmpvar_6 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  texel_2.xyz = ((tmpvar_5.xyz * v_mask_swizzle.x) + (tmpvar_5.www * v_mask_swizzle.y));
  frag_color_1 = (v_color * (texel_2 * min (
    max ((0.5 - max (tmpvar_6.x, tmpvar_6.y)), 0.0)
  , 1.0)));
  float tmpvar_7;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_7 = 1.0;
  } else {
    vec2 tmpvar_8;
    tmpvar_8 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_9;
    tmpvar_9.xy = greaterThanEqual (tmpvar_8, vClipMaskUvBounds.xy);
    tmpvar_9.zw = lessThan (tmpvar_8, vClipMaskUvBounds.zw);
    bool tmpvar_10;
    tmpvar_10 = (tmpvar_9 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_10)) {
      tmpvar_7 = 0.0;
    } else {
      tmpvar_7 = texelFetch (sClipMask, ivec2(tmpvar_8), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_7);
  oFragColor = frag_color_1;
}

brush_image_ALPHA_PASS_ANTIALIASING_REPETITION_TEXTURE_RECT#version 150
// brush_image
// features: ["ALPHA_PASS", "ANTIALIASING", "REPETITION", "TEXTURE_RECT"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2DRect sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  ivec2 tmpvar_64;
  tmpvar_64.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_64.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_65;
  tmpvar_65 = texelFetchOffset (sGpuCache, tmpvar_64, 0, ivec2(0, 0));
  uv0_58 = tmpvar_65.xy;
  uv1_57 = tmpvar_65.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    vec2 tmpvar_66;
    tmpvar_66 = (segment_rect_p1_35 - segment_rect_p0_34);
    stretch_size_54 = tmpvar_66;
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_67;
      tmpvar_67 = (tmpvar_65.zw - tmpvar_65.xy);
      uv0_58 = (tmpvar_65.xy + (segment_data_36.xy * tmpvar_67));
      uv1_57 = (tmpvar_65.xy + (segment_data_36.zw * tmpvar_67));
    };
    if (((tmpvar_38 & 128) != 0)) {
      vec2 vertical_uv_size_68;
      vec2 horizontal_uv_size_69;
      vec2 repeated_stretch_size_70;
      repeated_stretch_size_70 = tmpvar_66;
      vec2 tmpvar_71;
      tmpvar_71 = (uv1_57 - uv0_58);
      horizontal_uv_size_69 = tmpvar_71;
      vec2 tmpvar_72;
      tmpvar_72 = (uv1_57 - uv0_58);
      vertical_uv_size_68 = tmpvar_72;
      if (((tmpvar_38 & 64) != 0)) {
        repeated_stretch_size_70 = (segment_rect_p0_34 - tmpvar_8.xy);
        vertical_uv_size_68.x = (uv0_58.x - tmpvar_65.x);
        if (((vertical_uv_size_68.x < 0.001) || (repeated_stretch_size_70.x < 0.001))) {
          vertical_uv_size_68.x = (tmpvar_65.z - uv1_57.x);
          repeated_stretch_size_70.x = (tmpvar_8.z - segment_rect_p1_35.x);
        };
        horizontal_uv_size_69.y = (uv0_58.y - tmpvar_65.y);
        if (((horizontal_uv_size_69.y < 0.001) || (repeated_stretch_size_70.y < 0.001))) {
          horizontal_uv_size_69.y = (tmpvar_65.w - uv1_57.y);
          repeated_stretch_size_70.y = (tmpvar_8.w - segment_rect_p1_35.y);
        };
      };
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (repeated_stretch_size_70.y * (tmpvar_71.x / horizontal_uv_size_69.y));
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (repeated_stretch_size_70.x * (tmpvar_72.y / vertical_uv_size_68.x));
      };
    } else {
      if (((tmpvar_38 & 4) != 0)) {
        stretch_size_54.x = (segment_data_36.z - segment_data_36.x);
      };
      if (((tmpvar_38 & 8) != 0)) {
        stretch_size_54.y = (segment_data_36.w - segment_data_36.y);
      };
    };
    if (((tmpvar_38 & 16) != 0)) {
      float tmpvar_73;
      tmpvar_73 = (segment_rect_p1_35.x - segment_rect_p0_34.x);
      stretch_size_54.x = (tmpvar_73 / max (1.0, roundEven(
        (tmpvar_73 / stretch_size_54.x)
      )));
    };
    if (((tmpvar_38 & 32) != 0)) {
      float tmpvar_74;
      tmpvar_74 = (segment_rect_p1_35.y - segment_rect_p0_34.y);
      stretch_size_54.y = (tmpvar_74 / max (1.0, roundEven(
        (tmpvar_74 / stretch_size_54.y)
      )));
    };
  };
  float tmpvar_75;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_75 = 1.0;
  } else {
    tmpvar_75 = 0.0;
  };
  v_perspective.x = tmpvar_75;
  vec2 tmpvar_76;
  tmpvar_76 = min (uv0_58, uv1_57);
  vec4 tmpvar_77;
  tmpvar_77.xy = (tmpvar_76 + vec2(0.5, 0.5));
  tmpvar_77.zw = (max (uv0_58, uv1_57) - vec2(0.5, 0.5));
  v_uv_sample_bounds = tmpvar_77;
  vec2 tmpvar_78;
  tmpvar_78 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_78;
  int tmpvar_79;
  tmpvar_79 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_79;
  int tmpvar_80;
  tmpvar_80 = (tmpvar_16.x >> 16);
  if ((tmpvar_79 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_81;
    tmpvar_81 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_82;
    tmpvar_82.x = int((uint(tmpvar_81) % 1024u));
    tmpvar_82.y = int((uint(tmpvar_81) / 1024u));
    vec4 tmpvar_83;
    tmpvar_83 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(1, 0)), tmpvar_78.x), mix (texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(3, 0)), tmpvar_78.x), tmpvar_78.y);
    f_53 = (tmpvar_83.xy / tmpvar_83.w);
  };
  vec2 tmpvar_84;
  tmpvar_84 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_76);
  v_uv = (v_uv * tmpvar_84);
  if ((tmpvar_75 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec2 tmpvar_85;
  tmpvar_85 = vec2(textureSize (sColor0));
  vec4 tmpvar_86;
  tmpvar_86.xy = vec2(0.0, 0.0);
  tmpvar_86.zw = tmpvar_85;
  v_uv_bounds = tmpvar_86;
  v_uv = (v_uv / tmpvar_85);
  v_tile_repeat = tmpvar_84;
  float tmpvar_87;
  tmpvar_87 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_88;
  bool tmpvar_89;
  tmpvar_89 = bool(0);
  tmpvar_88 = (0 == tmpvar_80);
  if (tmpvar_88) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_87);
    tmpvar_89 = bool(1);
  };
  tmpvar_88 = !(tmpvar_89);
  if (tmpvar_88) {
    image_data_color_59 = (image_data_color_59 * tmpvar_87);
    tmpvar_89 = bool(1);
  };
  bool tmpvar_90;
  bool tmpvar_91;
  tmpvar_91 = bool(0);
  tmpvar_90 = (1 == color_mode_52);
  tmpvar_90 = (tmpvar_90 || (7 == color_mode_52));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (5 == color_mode_52));
  tmpvar_90 = (tmpvar_90 || (9 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (2 == color_mode_52));
  tmpvar_90 = (tmpvar_90 || (3 == color_mode_52));
  tmpvar_90 = (tmpvar_90 || (8 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (4 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (6 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    vec2 tmpvar_92;
    tmpvar_92.y = 0.0;
    tmpvar_92.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_92;
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = (tmpvar_90 || (10 == color_mode_52));
  tmpvar_90 = (tmpvar_90 && !(tmpvar_91));
  if (tmpvar_90) {
    vec2 tmpvar_93;
    tmpvar_93.x = -(image_data_color_59.w);
    tmpvar_93.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_93;
    v_color = image_data_color_59;
    tmpvar_91 = bool(1);
  };
  tmpvar_90 = !(tmpvar_91);
  if (tmpvar_90) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ALPHA_PASS", "ANTIALIASING", "REPETITION", "TEXTURE_RECT"]

precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec2 v_tile_repeat;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 texel_2;
  vec2 repeated_uv_3;
  vec2 tmpvar_4;
  tmpvar_4 = max ((v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x)), vec2(0.0, 0.0));
  repeated_uv_3 = ((fract(tmpvar_4) * (v_uv_bounds.zw - v_uv_bounds.xy)) + v_uv_bounds.xy);
  if ((tmpvar_4.x >= v_tile_repeat.x)) {
    repeated_uv_3.x = v_uv_bounds.z;
  };
  if ((tmpvar_4.y >= v_tile_repeat.y)) {
    repeated_uv_3.y = v_uv_bounds.w;
  };
  vec4 tmpvar_5;
  tmpvar_5 = texture (sColor0, min (max (repeated_uv_3, v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  texel_2.w = tmpvar_5.w;
  vec2 tmpvar_6;
  tmpvar_6 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  texel_2.xyz = ((tmpvar_5.xyz * v_mask_swizzle.x) + (tmpvar_5.www * v_mask_swizzle.y));
  frag_color_1 = (v_color * (texel_2 * min (
    max ((0.5 - max (tmpvar_6.x, tmpvar_6.y)), 0.0)
  , 1.0)));
  float tmpvar_7;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_7 = 1.0;
  } else {
    vec2 tmpvar_8;
    tmpvar_8 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_9;
    tmpvar_9.xy = greaterThanEqual (tmpvar_8, vClipMaskUvBounds.xy);
    tmpvar_9.zw = lessThan (tmpvar_8, vClipMaskUvBounds.zw);
    bool tmpvar_10;
    tmpvar_10 = (tmpvar_9 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_10)) {
      tmpvar_7 = 0.0;
    } else {
      tmpvar_7 = texelFetch (sClipMask, ivec2(tmpvar_8), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_7);
  oFragColor = frag_color_1;
}

brush_image_ALPHA_PASS_DUAL_SOURCE_BLENDING_TEXTURE_2D#version 150
// brush_image
// features: ["ALPHA_PASS", "DUAL_SOURCE_BLENDING", "TEXTURE_2D"]

#extension GL_ARB_explicit_attrib_location : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  vec2 tmpvar_64;
  tmpvar_64 = vec2(textureSize (sColor0, 0));
  ivec2 tmpvar_65;
  tmpvar_65.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_65.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_66;
  tmpvar_66 = texelFetchOffset (sGpuCache, tmpvar_65, 0, ivec2(0, 0));
  uv0_58 = tmpvar_66.xy;
  uv1_57 = tmpvar_66.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    stretch_size_54 = (segment_rect_p1_35 - segment_rect_p0_34);
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_67;
      tmpvar_67 = (tmpvar_66.zw - tmpvar_66.xy);
      uv0_58 = (tmpvar_66.xy + (segment_data_36.xy * tmpvar_67));
      uv1_57 = (tmpvar_66.xy + (segment_data_36.zw * tmpvar_67));
    };
  };
  float tmpvar_68;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_68 = 1.0;
  } else {
    tmpvar_68 = 0.0;
  };
  v_perspective.x = tmpvar_68;
  vec2 tmpvar_69;
  tmpvar_69 = min (uv0_58, uv1_57);
  vec2 tmpvar_70;
  tmpvar_70 = max (uv0_58, uv1_57);
  vec4 tmpvar_71;
  tmpvar_71.xy = (tmpvar_69 + vec2(0.5, 0.5));
  tmpvar_71.zw = (tmpvar_70 - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_71 / tmpvar_64.xyxy);
  vec2 tmpvar_72;
  tmpvar_72 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_72;
  int tmpvar_73;
  tmpvar_73 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_73;
  int tmpvar_74;
  tmpvar_74 = (tmpvar_16.x >> 16);
  if ((tmpvar_73 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_75;
    tmpvar_75 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_76;
    tmpvar_76.x = int((uint(tmpvar_75) % 1024u));
    tmpvar_76.y = int((uint(tmpvar_75) / 1024u));
    vec4 tmpvar_77;
    tmpvar_77 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(1, 0)), tmpvar_72.x), mix (texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(3, 0)), tmpvar_72.x), tmpvar_72.y);
    f_53 = (tmpvar_77.xy / tmpvar_77.w);
  };
  vec2 tmpvar_78;
  tmpvar_78 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_69);
  v_uv = (v_uv / tmpvar_64);
  v_uv = (v_uv * tmpvar_78);
  if ((tmpvar_68 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec4 tmpvar_79;
  tmpvar_79.xy = tmpvar_69;
  tmpvar_79.zw = tmpvar_70;
  v_uv_bounds = (tmpvar_79 / tmpvar_64.xyxy);
  v_tile_repeat = tmpvar_78;
  float tmpvar_80;
  tmpvar_80 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_81;
  bool tmpvar_82;
  tmpvar_82 = bool(0);
  tmpvar_81 = (0 == tmpvar_74);
  if (tmpvar_81) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_80);
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = !(tmpvar_82);
  if (tmpvar_81) {
    image_data_color_59 = (image_data_color_59 * tmpvar_80);
    tmpvar_82 = bool(1);
  };
  bool tmpvar_83;
  bool tmpvar_84;
  tmpvar_84 = bool(0);
  tmpvar_83 = (1 == color_mode_52);
  tmpvar_83 = (tmpvar_83 || (7 == color_mode_52));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (5 == color_mode_52));
  tmpvar_83 = (tmpvar_83 || (9 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (2 == color_mode_52));
  tmpvar_83 = (tmpvar_83 || (3 == color_mode_52));
  tmpvar_83 = (tmpvar_83 || (8 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (4 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (6 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    vec2 tmpvar_85;
    tmpvar_85.y = 0.0;
    tmpvar_85.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_85;
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (10 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    vec2 tmpvar_86;
    tmpvar_86.x = -(image_data_color_59.w);
    tmpvar_86.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_86;
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = !(tmpvar_84);
  if (tmpvar_83) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ALPHA_PASS", "DUAL_SOURCE_BLENDING", "TEXTURE_2D"]

#extension GL_ARB_explicit_attrib_location : enable
precision highp float;
layout(location=0, index=0) out vec4 oFragColor;
layout(location=0, index=1) out vec4 oFragBlend;
uniform sampler2D sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 frag_blend_2;
  vec4 tmpvar_3;
  tmpvar_3 = texture (sColor0, min (max ((
    (v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x))
   + v_uv_bounds.xy), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  frag_color_1 = (v_color * tmpvar_3);
  frag_blend_2 = ((tmpvar_3 * v_mask_swizzle.x) + (tmpvar_3.wwww * v_mask_swizzle.y));
  float tmpvar_4;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_4 = 1.0;
  } else {
    vec2 tmpvar_5;
    tmpvar_5 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_6;
    tmpvar_6.xy = greaterThanEqual (tmpvar_5, vClipMaskUvBounds.xy);
    tmpvar_6.zw = lessThan (tmpvar_5, vClipMaskUvBounds.zw);
    bool tmpvar_7;
    tmpvar_7 = (tmpvar_6 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_7)) {
      tmpvar_4 = 0.0;
    } else {
      tmpvar_4 = texelFetch (sClipMask, ivec2(tmpvar_5), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_4);
  oFragBlend = (frag_blend_2 * tmpvar_4);
  oFragColor = frag_color_1;
}

feb46e4c4d37d2brush_image_ALPHA_PASS_DUAL_SOURCE_BLENDING_TEXTURE_RECT#version 150
// brush_image
// features: ["ALPHA_PASS", "DUAL_SOURCE_BLENDING", "TEXTURE_RECT"]

#extension GL_ARB_explicit_attrib_location : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2DRect sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  ivec2 tmpvar_64;
  tmpvar_64.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_64.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_65;
  tmpvar_65 = texelFetchOffset (sGpuCache, tmpvar_64, 0, ivec2(0, 0));
  uv0_58 = tmpvar_65.xy;
  uv1_57 = tmpvar_65.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    stretch_size_54 = (segment_rect_p1_35 - segment_rect_p0_34);
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_66;
      tmpvar_66 = (tmpvar_65.zw - tmpvar_65.xy);
      uv0_58 = (tmpvar_65.xy + (segment_data_36.xy * tmpvar_66));
      uv1_57 = (tmpvar_65.xy + (segment_data_36.zw * tmpvar_66));
    };
  };
  float tmpvar_67;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_67 = 1.0;
  } else {
    tmpvar_67 = 0.0;
  };
  v_perspective.x = tmpvar_67;
  vec2 tmpvar_68;
  tmpvar_68 = min (uv0_58, uv1_57);
  vec4 tmpvar_69;
  tmpvar_69.xy = (tmpvar_68 + vec2(0.5, 0.5));
  tmpvar_69.zw = (max (uv0_58, uv1_57) - vec2(0.5, 0.5));
  v_uv_sample_bounds = tmpvar_69;
  vec2 tmpvar_70;
  tmpvar_70 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_70;
  int tmpvar_71;
  tmpvar_71 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_71;
  int tmpvar_72;
  tmpvar_72 = (tmpvar_16.x >> 16);
  if ((tmpvar_71 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_73;
    tmpvar_73 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_74;
    tmpvar_74.x = int((uint(tmpvar_73) % 1024u));
    tmpvar_74.y = int((uint(tmpvar_73) / 1024u));
    vec4 tmpvar_75;
    tmpvar_75 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(1, 0)), tmpvar_70.x), mix (texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(3, 0)), tmpvar_70.x), tmpvar_70.y);
    f_53 = (tmpvar_75.xy / tmpvar_75.w);
  };
  vec2 tmpvar_76;
  tmpvar_76 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_68);
  v_uv = (v_uv * tmpvar_76);
  if ((tmpvar_67 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec4 tmpvar_77;
  tmpvar_77.xy = vec2(0.0, 0.0);
  tmpvar_77.zw = vec2(textureSize (sColor0));
  v_uv_bounds = tmpvar_77;
  v_tile_repeat = tmpvar_76;
  float tmpvar_78;
  tmpvar_78 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_79;
  bool tmpvar_80;
  tmpvar_80 = bool(0);
  tmpvar_79 = (0 == tmpvar_72);
  if (tmpvar_79) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_78);
    tmpvar_80 = bool(1);
  };
  tmpvar_79 = !(tmpvar_80);
  if (tmpvar_79) {
    image_data_color_59 = (image_data_color_59 * tmpvar_78);
    tmpvar_80 = bool(1);
  };
  bool tmpvar_81;
  bool tmpvar_82;
  tmpvar_82 = bool(0);
  tmpvar_81 = (1 == color_mode_52);
  tmpvar_81 = (tmpvar_81 || (7 == color_mode_52));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (5 == color_mode_52));
  tmpvar_81 = (tmpvar_81 || (9 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (2 == color_mode_52));
  tmpvar_81 = (tmpvar_81 || (3 == color_mode_52));
  tmpvar_81 = (tmpvar_81 || (8 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (4 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (6 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    vec2 tmpvar_83;
    tmpvar_83.y = 0.0;
    tmpvar_83.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_83;
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (10 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    vec2 tmpvar_84;
    tmpvar_84.x = -(image_data_color_59.w);
    tmpvar_84.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_84;
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = !(tmpvar_82);
  if (tmpvar_81) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ALPHA_PASS", "DUAL_SOURCE_BLENDING", "TEXTURE_RECT"]

#extension GL_ARB_explicit_attrib_location : enable
precision highp float;
layout(location=0, index=0) out vec4 oFragColor;
layout(location=0, index=1) out vec4 oFragBlend;
uniform sampler2DRect sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 frag_blend_2;
  vec4 tmpvar_3;
  tmpvar_3 = texture (sColor0, min (max ((
    (v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x))
   + v_uv_bounds.xy), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  frag_color_1 = (v_color * tmpvar_3);
  frag_blend_2 = ((tmpvar_3 * v_mask_swizzle.x) + (tmpvar_3.wwww * v_mask_swizzle.y));
  float tmpvar_4;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_4 = 1.0;
  } else {
    vec2 tmpvar_5;
    tmpvar_5 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_6;
    tmpvar_6.xy = greaterThanEqual (tmpvar_5, vClipMaskUvBounds.xy);
    tmpvar_6.zw = lessThan (tmpvar_5, vClipMaskUvBounds.zw);
    bool tmpvar_7;
    tmpvar_7 = (tmpvar_6 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_7)) {
      tmpvar_4 = 0.0;
    } else {
      tmpvar_4 = texelFetch (sClipMask, ivec2(tmpvar_5), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_4);
  oFragBlend = (frag_blend_2 * tmpvar_4);
  oFragColor = frag_color_1;
}

brush_image_ALPHA_PASS_TEXTURE_2D#version 150
// brush_image
// features: ["ALPHA_PASS", "TEXTURE_2D"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  vec2 tmpvar_64;
  tmpvar_64 = vec2(textureSize (sColor0, 0));
  ivec2 tmpvar_65;
  tmpvar_65.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_65.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_66;
  tmpvar_66 = texelFetchOffset (sGpuCache, tmpvar_65, 0, ivec2(0, 0));
  uv0_58 = tmpvar_66.xy;
  uv1_57 = tmpvar_66.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    stretch_size_54 = (segment_rect_p1_35 - segment_rect_p0_34);
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_67;
      tmpvar_67 = (tmpvar_66.zw - tmpvar_66.xy);
      uv0_58 = (tmpvar_66.xy + (segment_data_36.xy * tmpvar_67));
      uv1_57 = (tmpvar_66.xy + (segment_data_36.zw * tmpvar_67));
    };
  };
  float tmpvar_68;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_68 = 1.0;
  } else {
    tmpvar_68 = 0.0;
  };
  v_perspective.x = tmpvar_68;
  vec2 tmpvar_69;
  tmpvar_69 = min (uv0_58, uv1_57);
  vec2 tmpvar_70;
  tmpvar_70 = max (uv0_58, uv1_57);
  vec4 tmpvar_71;
  tmpvar_71.xy = (tmpvar_69 + vec2(0.5, 0.5));
  tmpvar_71.zw = (tmpvar_70 - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_71 / tmpvar_64.xyxy);
  vec2 tmpvar_72;
  tmpvar_72 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_72;
  int tmpvar_73;
  tmpvar_73 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_73;
  int tmpvar_74;
  tmpvar_74 = (tmpvar_16.x >> 16);
  if ((tmpvar_73 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_75;
    tmpvar_75 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_76;
    tmpvar_76.x = int((uint(tmpvar_75) % 1024u));
    tmpvar_76.y = int((uint(tmpvar_75) / 1024u));
    vec4 tmpvar_77;
    tmpvar_77 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(1, 0)), tmpvar_72.x), mix (texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(3, 0)), tmpvar_72.x), tmpvar_72.y);
    f_53 = (tmpvar_77.xy / tmpvar_77.w);
  };
  vec2 tmpvar_78;
  tmpvar_78 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_69);
  v_uv = (v_uv / tmpvar_64);
  v_uv = (v_uv * tmpvar_78);
  if ((tmpvar_68 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec4 tmpvar_79;
  tmpvar_79.xy = tmpvar_69;
  tmpvar_79.zw = tmpvar_70;
  v_uv_bounds = (tmpvar_79 / tmpvar_64.xyxy);
  v_tile_repeat = tmpvar_78;
  float tmpvar_80;
  tmpvar_80 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_81;
  bool tmpvar_82;
  tmpvar_82 = bool(0);
  tmpvar_81 = (0 == tmpvar_74);
  if (tmpvar_81) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_80);
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = !(tmpvar_82);
  if (tmpvar_81) {
    image_data_color_59 = (image_data_color_59 * tmpvar_80);
    tmpvar_82 = bool(1);
  };
  bool tmpvar_83;
  bool tmpvar_84;
  tmpvar_84 = bool(0);
  tmpvar_83 = (1 == color_mode_52);
  tmpvar_83 = (tmpvar_83 || (7 == color_mode_52));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (5 == color_mode_52));
  tmpvar_83 = (tmpvar_83 || (9 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (2 == color_mode_52));
  tmpvar_83 = (tmpvar_83 || (3 == color_mode_52));
  tmpvar_83 = (tmpvar_83 || (8 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (4 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (6 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    vec2 tmpvar_85;
    tmpvar_85.y = 0.0;
    tmpvar_85.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_85;
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = (tmpvar_83 || (10 == color_mode_52));
  tmpvar_83 = (tmpvar_83 && !(tmpvar_84));
  if (tmpvar_83) {
    vec2 tmpvar_86;
    tmpvar_86.x = -(image_data_color_59.w);
    tmpvar_86.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_86;
    v_color = image_data_color_59;
    tmpvar_84 = bool(1);
  };
  tmpvar_83 = !(tmpvar_84);
  if (tmpvar_83) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ALPHA_PASS", "TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 texel_2;
  vec4 tmpvar_3;
  tmpvar_3 = texture (sColor0, min (max ((
    (v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x))
   + v_uv_bounds.xy), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  texel_2.w = tmpvar_3.w;
  texel_2.xyz = ((tmpvar_3.xyz * v_mask_swizzle.x) + (tmpvar_3.www * v_mask_swizzle.y));
  frag_color_1 = (v_color * texel_2);
  float tmpvar_4;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_4 = 1.0;
  } else {
    vec2 tmpvar_5;
    tmpvar_5 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_6;
    tmpvar_6.xy = greaterThanEqual (tmpvar_5, vClipMaskUvBounds.xy);
    tmpvar_6.zw = lessThan (tmpvar_5, vClipMaskUvBounds.zw);
    bool tmpvar_7;
    tmpvar_7 = (tmpvar_6 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_7)) {
      tmpvar_4 = 0.0;
    } else {
      tmpvar_4 = texelFetch (sClipMask, ivec2(tmpvar_5), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_4);
  oFragColor = frag_color_1;
}

brush_image_ALPHA_PASS_TEXTURE_RECT#version 150
// brush_image
// features: ["ALPHA_PASS", "TEXTURE_RECT"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2DRect sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_color;
flat out vec2 v_mask_swizzle;
flat out vec2 v_tile_repeat;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  int instance_resource_address_5;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  instance_resource_address_5 = (aData.w & 16777215);
  float ph_z_6;
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(0, 0));
  vec4 tmpvar_9;
  tmpvar_9 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_7, 0, ivec2(1, 0));
  vec2 tmpvar_10;
  vec2 tmpvar_11;
  tmpvar_10 = tmpvar_8.xy;
  tmpvar_11 = tmpvar_8.zw;
  vec2 tmpvar_12;
  vec2 tmpvar_13;
  tmpvar_12 = tmpvar_9.xy;
  tmpvar_13 = tmpvar_9.zw;
  ivec2 tmpvar_14;
  tmpvar_14.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_14.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(0, 0));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_14, 0, ivec2(1, 0));
  ph_z_6 = float(tmpvar_15.x);
  mat4 transform_m_17;
  bool transform_is_axis_aligned_18;
  transform_is_axis_aligned_18 = ((tmpvar_15.z >> 24) == 0);
  int tmpvar_19;
  tmpvar_19 = (tmpvar_15.z & 16777215);
  ivec2 tmpvar_20;
  tmpvar_20.x = int((8u * (
    uint(tmpvar_19)
   % 128u)));
  tmpvar_20.y = int((uint(tmpvar_19) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_20, 0, ivec2(3, 0));
  ivec2 tmpvar_21;
  tmpvar_21.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_21.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(0, 0));
  vec4 tmpvar_23;
  tmpvar_23 = texelFetchOffset (sRenderTasks, tmpvar_21, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_24;
  float area_device_pixel_scale_25;
  vec2 area_screen_origin_26;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_24 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_25 = 0.0;
    area_screen_origin_26 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_27;
    tmpvar_27.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_27.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(0, 0));
    vec4 tmpvar_29;
    tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_27, 0, ivec2(1, 0));
    area_task_rect_24.p0 = tmpvar_28.xy;
    area_task_rect_24.p1 = tmpvar_28.zw;
    area_device_pixel_scale_25 = tmpvar_29.x;
    area_screen_origin_26 = tmpvar_29.yz;
  };
  vec2 tmpvar_30;
  vec2 tmpvar_31;
  tmpvar_30 = tmpvar_12;
  tmpvar_31 = tmpvar_13;
  vec2 adjusted_segment_rect_p0_32;
  vec2 adjusted_segment_rect_p1_33;
  vec2 segment_rect_p0_34;
  vec2 segment_rect_p1_35;
  vec4 segment_data_36;
  int tmpvar_37;
  tmpvar_37 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_38;
  tmpvar_38 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_34 = tmpvar_10;
    segment_rect_p1_35 = tmpvar_11;
    segment_data_36 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_39;
    tmpvar_39 = ((tmpvar_15.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_40;
    tmpvar_40.x = int((uint(tmpvar_39) % 1024u));
    tmpvar_40.y = int((uint(tmpvar_39) / 1024u));
    vec4 tmpvar_41;
    tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
    segment_rect_p0_34 = (tmpvar_41.xy + tmpvar_8.xy);
    segment_rect_p1_35 = (tmpvar_41.zw + tmpvar_8.xy);
    segment_data_36 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_32 = segment_rect_p0_34;
  adjusted_segment_rect_p1_33 = segment_rect_p1_35;
  if ((!(transform_is_axis_aligned_18) || ((tmpvar_38 & 256) != 0))) {
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p0_34, tmpvar_9.xy), tmpvar_9.zw);
    vec2 tmpvar_43;
    tmpvar_43 = min (max (segment_rect_p1_35, tmpvar_9.xy), tmpvar_9.zw);
    bvec4 tmpvar_44;
    tmpvar_44.x = bool((tmpvar_37 & 1));
    tmpvar_44.y = bool((tmpvar_37 & 2));
    tmpvar_44.z = bool((tmpvar_37 & 4));
    tmpvar_44.w = bool((tmpvar_37 & 8));
    vec4 tmpvar_45;
    tmpvar_45.xy = tmpvar_42;
    tmpvar_45.zw = tmpvar_43;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_45, bvec4(tmpvar_44));
    vec4 tmpvar_46;
    tmpvar_46 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_44));
    adjusted_segment_rect_p0_32 = (tmpvar_42 - tmpvar_46.xy);
    adjusted_segment_rect_p1_33 = (tmpvar_43 + tmpvar_46.zw);
    tmpvar_30 = vec2(-1e+16, -1e+16);
    tmpvar_31 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_47;
  tmpvar_47 = min (max (mix (adjusted_segment_rect_p0_32, adjusted_segment_rect_p1_33, aPosition), tmpvar_30), tmpvar_31);
  vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 1.0);
  tmpvar_48.xy = tmpvar_47;
  vec4 tmpvar_49;
  tmpvar_49 = (transform_m_17 * tmpvar_48);
  vec4 tmpvar_50;
  tmpvar_50.xy = ((tmpvar_49.xy * tmpvar_23.x) + ((
    -(tmpvar_23.yz)
   + tmpvar_22.xy) * tmpvar_49.w));
  tmpvar_50.z = (ph_z_6 * tmpvar_49.w);
  tmpvar_50.w = tmpvar_49.w;
  gl_Position = (uTransform * tmpvar_50);
  vec4 tmpvar_51;
  tmpvar_51.xy = area_task_rect_24.p0;
  tmpvar_51.zw = area_task_rect_24.p1;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_49.xy * area_device_pixel_scale_25) + (tmpvar_49.w * (area_task_rect_24.p0 - area_screen_origin_26)));
  int color_mode_52;
  vec2 f_53;
  vec2 stretch_size_54;
  vec2 local_rect_p0_55;
  vec2 local_rect_p1_56;
  vec2 uv1_57;
  vec2 uv0_58;
  vec4 image_data_color_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_61;
  vec4 tmpvar_62;
  vec4 tmpvar_63;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  tmpvar_62 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0));
  tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0));
  image_data_color_59 = tmpvar_61;
  ivec2 tmpvar_64;
  tmpvar_64.x = int((uint(instance_resource_address_5) % 1024u));
  tmpvar_64.y = int((uint(instance_resource_address_5) / 1024u));
  vec4 tmpvar_65;
  tmpvar_65 = texelFetchOffset (sGpuCache, tmpvar_64, 0, ivec2(0, 0));
  uv0_58 = tmpvar_65.xy;
  uv1_57 = tmpvar_65.zw;
  local_rect_p0_55 = tmpvar_10;
  local_rect_p1_56 = tmpvar_11;
  stretch_size_54 = tmpvar_63.xy;
  if ((tmpvar_63.x < 0.0)) {
    stretch_size_54 = (tmpvar_8.zw - tmpvar_8.xy);
  };
  if (((tmpvar_38 & 2) != 0)) {
    local_rect_p0_55 = segment_rect_p0_34;
    local_rect_p1_56 = segment_rect_p1_35;
    stretch_size_54 = (segment_rect_p1_35 - segment_rect_p0_34);
    if (((tmpvar_38 & 128) != 0)) {
      vec2 tmpvar_66;
      tmpvar_66 = (tmpvar_65.zw - tmpvar_65.xy);
      uv0_58 = (tmpvar_65.xy + (segment_data_36.xy * tmpvar_66));
      uv1_57 = (tmpvar_65.xy + (segment_data_36.zw * tmpvar_66));
    };
  };
  float tmpvar_67;
  if (((tmpvar_38 & 1) != 0)) {
    tmpvar_67 = 1.0;
  } else {
    tmpvar_67 = 0.0;
  };
  v_perspective.x = tmpvar_67;
  vec2 tmpvar_68;
  tmpvar_68 = min (uv0_58, uv1_57);
  vec4 tmpvar_69;
  tmpvar_69.xy = (tmpvar_68 + vec2(0.5, 0.5));
  tmpvar_69.zw = (max (uv0_58, uv1_57) - vec2(0.5, 0.5));
  v_uv_sample_bounds = tmpvar_69;
  vec2 tmpvar_70;
  tmpvar_70 = ((tmpvar_47 - local_rect_p0_55) / (local_rect_p1_56 - local_rect_p0_55));
  f_53 = tmpvar_70;
  int tmpvar_71;
  tmpvar_71 = (tmpvar_16.x & 65535);
  color_mode_52 = tmpvar_71;
  int tmpvar_72;
  tmpvar_72 = (tmpvar_16.x >> 16);
  if ((tmpvar_71 == 0)) {
    color_mode_52 = uMode;
  };
  if ((tmpvar_16.y == 1)) {
    int tmpvar_73;
    tmpvar_73 = (instance_resource_address_5 + 2);
    ivec2 tmpvar_74;
    tmpvar_74.x = int((uint(tmpvar_73) % 1024u));
    tmpvar_74.y = int((uint(tmpvar_73) / 1024u));
    vec4 tmpvar_75;
    tmpvar_75 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(1, 0)), tmpvar_70.x), mix (texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(3, 0)), tmpvar_70.x), tmpvar_70.y);
    f_53 = (tmpvar_75.xy / tmpvar_75.w);
  };
  vec2 tmpvar_76;
  tmpvar_76 = ((local_rect_p1_56 - local_rect_p0_55) / stretch_size_54);
  v_uv = (mix (uv0_58, uv1_57, f_53) - tmpvar_68);
  v_uv = (v_uv * tmpvar_76);
  if ((tmpvar_67 == 0.0)) {
    v_uv = (v_uv * tmpvar_49.w);
  };
  vec4 tmpvar_77;
  tmpvar_77.xy = vec2(0.0, 0.0);
  tmpvar_77.zw = vec2(textureSize (sColor0));
  v_uv_bounds = tmpvar_77;
  v_tile_repeat = tmpvar_76;
  float tmpvar_78;
  tmpvar_78 = (float(tmpvar_16.z) / 65535.0);
  bool tmpvar_79;
  bool tmpvar_80;
  tmpvar_80 = bool(0);
  tmpvar_79 = (0 == tmpvar_72);
  if (tmpvar_79) {
    image_data_color_59.w = (tmpvar_61.w * tmpvar_78);
    tmpvar_80 = bool(1);
  };
  tmpvar_79 = !(tmpvar_80);
  if (tmpvar_79) {
    image_data_color_59 = (image_data_color_59 * tmpvar_78);
    tmpvar_80 = bool(1);
  };
  bool tmpvar_81;
  bool tmpvar_82;
  tmpvar_82 = bool(0);
  tmpvar_81 = (1 == color_mode_52);
  tmpvar_81 = (tmpvar_81 || (7 == color_mode_52));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(0.0, 1.0);
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (5 == color_mode_52));
  tmpvar_81 = (tmpvar_81 || (9 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (2 == color_mode_52));
  tmpvar_81 = (tmpvar_81 || (3 == color_mode_52));
  tmpvar_81 = (tmpvar_81 || (8 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(1.0, 0.0);
    v_color = image_data_color_59.wwww;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (4 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    v_mask_swizzle = vec2(-1.0, 1.0);
    v_color = (image_data_color_59.wwww * tmpvar_62);
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (6 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    vec2 tmpvar_83;
    tmpvar_83.y = 0.0;
    tmpvar_83.x = image_data_color_59.w;
    v_mask_swizzle = tmpvar_83;
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = (tmpvar_81 || (10 == color_mode_52));
  tmpvar_81 = (tmpvar_81 && !(tmpvar_82));
  if (tmpvar_81) {
    vec2 tmpvar_84;
    tmpvar_84.x = -(image_data_color_59.w);
    tmpvar_84.y = image_data_color_59.w;
    v_mask_swizzle = tmpvar_84;
    v_color = image_data_color_59;
    tmpvar_82 = bool(1);
  };
  tmpvar_81 = !(tmpvar_82);
  if (tmpvar_81) {
    v_mask_swizzle = vec2(0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  v_local_pos = tmpvar_47;
}

#version 150
// brush_image
// features: ["ALPHA_PASS", "TEXTURE_RECT"]

precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_uv;
flat in vec4 v_color;
flat in vec2 v_mask_swizzle;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  vec4 frag_color_1;
  vec4 texel_2;
  vec4 tmpvar_3;
  tmpvar_3 = texture (sColor0, min (max ((
    (v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x))
   + v_uv_bounds.xy), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
  texel_2.w = tmpvar_3.w;
  texel_2.xyz = ((tmpvar_3.xyz * v_mask_swizzle.x) + (tmpvar_3.www * v_mask_swizzle.y));
  frag_color_1 = (v_color * texel_2);
  float tmpvar_4;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_4 = 1.0;
  } else {
    vec2 tmpvar_5;
    tmpvar_5 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_6;
    tmpvar_6.xy = greaterThanEqual (tmpvar_5, vClipMaskUvBounds.xy);
    tmpvar_6.zw = lessThan (tmpvar_5, vClipMaskUvBounds.zw);
    bool tmpvar_7;
    tmpvar_7 = (tmpvar_6 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_7)) {
      tmpvar_4 = 0.0;
    } else {
      tmpvar_4 = texelFetch (sClipMask, ivec2(tmpvar_5), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_4);
  oFragColor = frag_color_1;
}

brush_image_ANTIALIASING_DEBUG_OVERDRAW_REPETITION_TEXTURE_2D#version 150
// brush_image
// features: ["ANTIALIASING", "DEBUG_OVERDRAW", "REPETITION", "TEXTURE_2D"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  int instance_resource_address_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  instance_resource_address_4 = (aData.w & 16777215);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  ivec2 tmpvar_11;
  tmpvar_11.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_11.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(0, 0));
  ivec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_12.x);
  mat4 transform_m_14;
  bool transform_is_axis_aligned_15;
  transform_is_axis_aligned_15 = ((tmpvar_12.z >> 24) == 0);
  int tmpvar_16;
  tmpvar_16 = (tmpvar_12.z & 16777215);
  ivec2 tmpvar_17;
  tmpvar_17.x = int((8u * (
    uint(tmpvar_16)
   % 128u)));
  tmpvar_17.y = int((uint(tmpvar_16) / 128u));
  transform_m_14[0] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(0, 0));
  transform_m_14[1] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(1, 0));
  transform_m_14[2] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(2, 0));
  transform_m_14[3] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(3, 0));
  ivec2 tmpvar_18;
  tmpvar_18.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_18.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(0, 0));
  vec4 tmpvar_20;
  tmpvar_20 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(1, 0));
  vec2 tmpvar_21;
  vec2 tmpvar_22;
  tmpvar_21 = tmpvar_8.xy;
  tmpvar_22 = tmpvar_8.zw;
  vec2 adjusted_segment_rect_p0_23;
  vec2 adjusted_segment_rect_p1_24;
  vec2 segment_rect_p0_25;
  vec2 segment_rect_p1_26;
  vec4 segment_data_27;
  int tmpvar_28;
  tmpvar_28 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_29;
  tmpvar_29 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_25 = tmpvar_9;
    segment_rect_p1_26 = tmpvar_10;
    segment_data_27 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_30;
    tmpvar_30 = ((tmpvar_12.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_31;
    tmpvar_31.x = int((uint(tmpvar_30) % 1024u));
    tmpvar_31.y = int((uint(tmpvar_30) / 1024u));
    vec4 tmpvar_32;
    tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
    segment_rect_p0_25 = (tmpvar_32.xy + tmpvar_7.xy);
    segment_rect_p1_26 = (tmpvar_32.zw + tmpvar_7.xy);
    segment_data_27 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_23 = segment_rect_p0_25;
  adjusted_segment_rect_p1_24 = segment_rect_p1_26;
  if ((!(transform_is_axis_aligned_15) || ((tmpvar_29 & 256) != 0))) {
    vec2 tmpvar_33;
    tmpvar_33 = min (max (segment_rect_p0_25, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_34;
    tmpvar_34 = min (max (segment_rect_p1_26, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_35;
    tmpvar_35.x = bool((tmpvar_28 & 1));
    tmpvar_35.y = bool((tmpvar_28 & 2));
    tmpvar_35.z = bool((tmpvar_28 & 4));
    tmpvar_35.w = bool((tmpvar_28 & 8));
    vec4 tmpvar_36;
    tmpvar_36.xy = tmpvar_33;
    tmpvar_36.zw = tmpvar_34;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_36, bvec4(tmpvar_35));
    vec4 tmpvar_37;
    tmpvar_37 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_35));
    adjusted_segment_rect_p0_23 = (tmpvar_33 - tmpvar_37.xy);
    adjusted_segment_rect_p1_24 = (tmpvar_34 + tmpvar_37.zw);
    tmpvar_21 = vec2(-1e+16, -1e+16);
    tmpvar_22 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_38;
  tmpvar_38 = min (max (mix (adjusted_segment_rect_p0_23, adjusted_segment_rect_p1_24, aPosition), tmpvar_21), tmpvar_22);
  vec4 tmpvar_39;
  tmpvar_39.zw = vec2(0.0, 1.0);
  tmpvar_39.xy = tmpvar_38;
  vec4 tmpvar_40;
  tmpvar_40 = (transform_m_14 * tmpvar_39);
  vec4 tmpvar_41;
  tmpvar_41.xy = ((tmpvar_40.xy * tmpvar_20.x) + ((
    -(tmpvar_20.yz)
   + tmpvar_19.xy) * tmpvar_40.w));
  tmpvar_41.z = (ph_z_5 * tmpvar_40.w);
  tmpvar_41.w = tmpvar_40.w;
  gl_Position = (uTransform * tmpvar_41);
  vec2 f_42;
  vec2 stretch_size_43;
  vec2 local_rect_p0_44;
  vec2 local_rect_p1_45;
  vec2 uv1_46;
  vec2 uv0_47;
  ivec2 tmpvar_48;
  tmpvar_48.x = int((uint(tmpvar_12.y) % 1024u));
  tmpvar_48.y = int((uint(tmpvar_12.y) / 1024u));
  vec4 tmpvar_49;
  tmpvar_49 = texelFetchOffset (sGpuCache, tmpvar_48, 0, ivec2(2, 0));
  vec2 tmpvar_50;
  tmpvar_50 = vec2(textureSize (sColor0, 0));
  ivec2 tmpvar_51;
  tmpvar_51.x = int((uint(instance_resource_address_4) % 1024u));
  tmpvar_51.y = int((uint(instance_resource_address_4) / 1024u));
  vec4 tmpvar_52;
  tmpvar_52 = texelFetchOffset (sGpuCache, tmpvar_51, 0, ivec2(0, 0));
  uv0_47 = tmpvar_52.xy;
  uv1_46 = tmpvar_52.zw;
  local_rect_p0_44 = tmpvar_9;
  local_rect_p1_45 = tmpvar_10;
  stretch_size_43 = tmpvar_49.xy;
  if ((tmpvar_49.x < 0.0)) {
    stretch_size_43 = (tmpvar_7.zw - tmpvar_7.xy);
  };
  if (((tmpvar_29 & 2) != 0)) {
    local_rect_p0_44 = segment_rect_p0_25;
    local_rect_p1_45 = segment_rect_p1_26;
    vec2 tmpvar_53;
    tmpvar_53 = (segment_rect_p1_26 - segment_rect_p0_25);
    stretch_size_43 = tmpvar_53;
    if (((tmpvar_29 & 128) != 0)) {
      vec2 tmpvar_54;
      tmpvar_54 = (tmpvar_52.zw - tmpvar_52.xy);
      uv0_47 = (tmpvar_52.xy + (segment_data_27.xy * tmpvar_54));
      uv1_46 = (tmpvar_52.xy + (segment_data_27.zw * tmpvar_54));
    };
    if (((tmpvar_29 & 128) != 0)) {
      vec2 vertical_uv_size_55;
      vec2 horizontal_uv_size_56;
      vec2 repeated_stretch_size_57;
      repeated_stretch_size_57 = tmpvar_53;
      vec2 tmpvar_58;
      tmpvar_58 = (uv1_46 - uv0_47);
      horizontal_uv_size_56 = tmpvar_58;
      vec2 tmpvar_59;
      tmpvar_59 = (uv1_46 - uv0_47);
      vertical_uv_size_55 = tmpvar_59;
      if (((tmpvar_29 & 64) != 0)) {
        repeated_stretch_size_57 = (segment_rect_p0_25 - tmpvar_7.xy);
        vertical_uv_size_55.x = (uv0_47.x - tmpvar_52.x);
        if (((vertical_uv_size_55.x < 0.001) || (repeated_stretch_size_57.x < 0.001))) {
          vertical_uv_size_55.x = (tmpvar_52.z - uv1_46.x);
          repeated_stretch_size_57.x = (tmpvar_7.z - segment_rect_p1_26.x);
        };
        horizontal_uv_size_56.y = (uv0_47.y - tmpvar_52.y);
        if (((horizontal_uv_size_56.y < 0.001) || (repeated_stretch_size_57.y < 0.001))) {
          horizontal_uv_size_56.y = (tmpvar_52.w - uv1_46.y);
          repeated_stretch_size_57.y = (tmpvar_7.w - segment_rect_p1_26.y);
        };
      };
      if (((tmpvar_29 & 4) != 0)) {
        stretch_size_43.x = (repeated_stretch_size_57.y * (tmpvar_58.x / horizontal_uv_size_56.y));
      };
      if (((tmpvar_29 & 8) != 0)) {
        stretch_size_43.y = (repeated_stretch_size_57.x * (tmpvar_59.y / vertical_uv_size_55.x));
      };
    } else {
      if (((tmpvar_29 & 4) != 0)) {
        stretch_size_43.x = (segment_data_27.z - segment_data_27.x);
      };
      if (((tmpvar_29 & 8) != 0)) {
        stretch_size_43.y = (segment_data_27.w - segment_data_27.y);
      };
    };
    if (((tmpvar_29 & 16) != 0)) {
      float tmpvar_60;
      tmpvar_60 = (segment_rect_p1_26.x - segment_rect_p0_25.x);
      stretch_size_43.x = (tmpvar_60 / max (1.0, roundEven(
        (tmpvar_60 / stretch_size_43.x)
      )));
    };
    if (((tmpvar_29 & 32) != 0)) {
      float tmpvar_61;
      tmpvar_61 = (segment_rect_p1_26.y - segment_rect_p0_25.y);
      stretch_size_43.y = (tmpvar_61 / max (1.0, roundEven(
        (tmpvar_61 / stretch_size_43.y)
      )));
    };
  };
  float tmpvar_62;
  if (((tmpvar_29 & 1) != 0)) {
    tmpvar_62 = 1.0;
  } else {
    tmpvar_62 = 0.0;
  };
  v_perspective.x = tmpvar_62;
  vec2 tmpvar_63;
  tmpvar_63 = min (uv0_47, uv1_46);
  vec2 tmpvar_64;
  tmpvar_64 = max (uv0_47, uv1_46);
  vec4 tmpvar_65;
  tmpvar_65.xy = (tmpvar_63 + vec2(0.5, 0.5));
  tmpvar_65.zw = (tmpvar_64 - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_65 / tmpvar_50.xyxy);
  vec2 tmpvar_66;
  tmpvar_66 = ((tmpvar_38 - local_rect_p0_44) / (local_rect_p1_45 - local_rect_p0_44));
  f_42 = tmpvar_66;
  if ((tmpvar_13.y == 1)) {
    int tmpvar_67;
    tmpvar_67 = (instance_resource_address_4 + 2);
    ivec2 tmpvar_68;
    tmpvar_68.x = int((uint(tmpvar_67) % 1024u));
    tmpvar_68.y = int((uint(tmpvar_67) / 1024u));
    vec4 tmpvar_69;
    tmpvar_69 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_68, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_68, 0, ivec2(1, 0)), tmpvar_66.x), mix (texelFetchOffset (sGpuCache, tmpvar_68, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_68, 0, ivec2(3, 0)), tmpvar_66.x), tmpvar_66.y);
    f_42 = (tmpvar_69.xy / tmpvar_69.w);
  };
  v_uv = (mix (uv0_47, uv1_46, f_42) - tmpvar_63);
  v_uv = (v_uv / tmpvar_50);
  v_uv = (v_uv * ((local_rect_p1_45 - local_rect_p0_44) / stretch_size_43));
  if ((tmpvar_62 == 0.0)) {
    v_uv = (v_uv * tmpvar_40.w);
  };
  vec4 tmpvar_70;
  tmpvar_70.xy = tmpvar_63;
  tmpvar_70.zw = tmpvar_64;
  v_uv_bounds = (tmpvar_70 / tmpvar_50.xyxy);
  v_uv = (v_uv / (v_uv_bounds.zw - v_uv_bounds.xy));
  v_local_pos = tmpvar_38;
}

#version 150
// brush_image
// features: ["ANTIALIASING", "DEBUG_OVERDRAW", "REPETITION", "TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

92ad6894bcc4163brush_image_ANTIALIASING_DEBUG_OVERDRAW_REPETITION_TEXTURE_RECT#version 150
// brush_image
// features: ["ANTIALIASING", "DEBUG_OVERDRAW", "REPETITION", "TEXTURE_RECT"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2DRect sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  int instance_resource_address_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  instance_resource_address_4 = (aData.w & 16777215);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  ivec2 tmpvar_11;
  tmpvar_11.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_11.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(0, 0));
  ivec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_12.x);
  mat4 transform_m_14;
  bool transform_is_axis_aligned_15;
  transform_is_axis_aligned_15 = ((tmpvar_12.z >> 24) == 0);
  int tmpvar_16;
  tmpvar_16 = (tmpvar_12.z & 16777215);
  ivec2 tmpvar_17;
  tmpvar_17.x = int((8u * (
    uint(tmpvar_16)
   % 128u)));
  tmpvar_17.y = int((uint(tmpvar_16) / 128u));
  transform_m_14[0] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(0, 0));
  transform_m_14[1] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(1, 0));
  transform_m_14[2] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(2, 0));
  transform_m_14[3] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(3, 0));
  ivec2 tmpvar_18;
  tmpvar_18.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_18.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(0, 0));
  vec4 tmpvar_20;
  tmpvar_20 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(1, 0));
  vec2 tmpvar_21;
  vec2 tmpvar_22;
  tmpvar_21 = tmpvar_8.xy;
  tmpvar_22 = tmpvar_8.zw;
  vec2 adjusted_segment_rect_p0_23;
  vec2 adjusted_segment_rect_p1_24;
  vec2 segment_rect_p0_25;
  vec2 segment_rect_p1_26;
  vec4 segment_data_27;
  int tmpvar_28;
  tmpvar_28 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_29;
  tmpvar_29 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_25 = tmpvar_9;
    segment_rect_p1_26 = tmpvar_10;
    segment_data_27 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_30;
    tmpvar_30 = ((tmpvar_12.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_31;
    tmpvar_31.x = int((uint(tmpvar_30) % 1024u));
    tmpvar_31.y = int((uint(tmpvar_30) / 1024u));
    vec4 tmpvar_32;
    tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
    segment_rect_p0_25 = (tmpvar_32.xy + tmpvar_7.xy);
    segment_rect_p1_26 = (tmpvar_32.zw + tmpvar_7.xy);
    segment_data_27 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_23 = segment_rect_p0_25;
  adjusted_segment_rect_p1_24 = segment_rect_p1_26;
  if ((!(transform_is_axis_aligned_15) || ((tmpvar_29 & 256) != 0))) {
    vec2 tmpvar_33;
    tmpvar_33 = min (max (segment_rect_p0_25, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_34;
    tmpvar_34 = min (max (segment_rect_p1_26, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_35;
    tmpvar_35.x = bool((tmpvar_28 & 1));
    tmpvar_35.y = bool((tmpvar_28 & 2));
    tmpvar_35.z = bool((tmpvar_28 & 4));
    tmpvar_35.w = bool((tmpvar_28 & 8));
    vec4 tmpvar_36;
    tmpvar_36.xy = tmpvar_33;
    tmpvar_36.zw = tmpvar_34;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_36, bvec4(tmpvar_35));
    vec4 tmpvar_37;
    tmpvar_37 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_35));
    adjusted_segment_rect_p0_23 = (tmpvar_33 - tmpvar_37.xy);
    adjusted_segment_rect_p1_24 = (tmpvar_34 + tmpvar_37.zw);
    tmpvar_21 = vec2(-1e+16, -1e+16);
    tmpvar_22 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_38;
  tmpvar_38 = min (max (mix (adjusted_segment_rect_p0_23, adjusted_segment_rect_p1_24, aPosition), tmpvar_21), tmpvar_22);
  vec4 tmpvar_39;
  tmpvar_39.zw = vec2(0.0, 1.0);
  tmpvar_39.xy = tmpvar_38;
  vec4 tmpvar_40;
  tmpvar_40 = (transform_m_14 * tmpvar_39);
  vec4 tmpvar_41;
  tmpvar_41.xy = ((tmpvar_40.xy * tmpvar_20.x) + ((
    -(tmpvar_20.yz)
   + tmpvar_19.xy) * tmpvar_40.w));
  tmpvar_41.z = (ph_z_5 * tmpvar_40.w);
  tmpvar_41.w = tmpvar_40.w;
  gl_Position = (uTransform * tmpvar_41);
  vec2 f_42;
  vec2 stretch_size_43;
  vec2 local_rect_p0_44;
  vec2 local_rect_p1_45;
  vec2 uv1_46;
  vec2 uv0_47;
  ivec2 tmpvar_48;
  tmpvar_48.x = int((uint(tmpvar_12.y) % 1024u));
  tmpvar_48.y = int((uint(tmpvar_12.y) / 1024u));
  vec4 tmpvar_49;
  tmpvar_49 = texelFetchOffset (sGpuCache, tmpvar_48, 0, ivec2(2, 0));
  ivec2 tmpvar_50;
  tmpvar_50.x = int((uint(instance_resource_address_4) % 1024u));
  tmpvar_50.y = int((uint(instance_resource_address_4) / 1024u));
  vec4 tmpvar_51;
  tmpvar_51 = texelFetchOffset (sGpuCache, tmpvar_50, 0, ivec2(0, 0));
  uv0_47 = tmpvar_51.xy;
  uv1_46 = tmpvar_51.zw;
  local_rect_p0_44 = tmpvar_9;
  local_rect_p1_45 = tmpvar_10;
  stretch_size_43 = tmpvar_49.xy;
  if ((tmpvar_49.x < 0.0)) {
    stretch_size_43 = (tmpvar_7.zw - tmpvar_7.xy);
  };
  if (((tmpvar_29 & 2) != 0)) {
    local_rect_p0_44 = segment_rect_p0_25;
    local_rect_p1_45 = segment_rect_p1_26;
    vec2 tmpvar_52;
    tmpvar_52 = (segment_rect_p1_26 - segment_rect_p0_25);
    stretch_size_43 = tmpvar_52;
    if (((tmpvar_29 & 128) != 0)) {
      vec2 tmpvar_53;
      tmpvar_53 = (tmpvar_51.zw - tmpvar_51.xy);
      uv0_47 = (tmpvar_51.xy + (segment_data_27.xy * tmpvar_53));
      uv1_46 = (tmpvar_51.xy + (segment_data_27.zw * tmpvar_53));
    };
    if (((tmpvar_29 & 128) != 0)) {
      vec2 vertical_uv_size_54;
      vec2 horizontal_uv_size_55;
      vec2 repeated_stretch_size_56;
      repeated_stretch_size_56 = tmpvar_52;
      vec2 tmpvar_57;
      tmpvar_57 = (uv1_46 - uv0_47);
      horizontal_uv_size_55 = tmpvar_57;
      vec2 tmpvar_58;
      tmpvar_58 = (uv1_46 - uv0_47);
      vertical_uv_size_54 = tmpvar_58;
      if (((tmpvar_29 & 64) != 0)) {
        repeated_stretch_size_56 = (segment_rect_p0_25 - tmpvar_7.xy);
        vertical_uv_size_54.x = (uv0_47.x - tmpvar_51.x);
        if (((vertical_uv_size_54.x < 0.001) || (repeated_stretch_size_56.x < 0.001))) {
          vertical_uv_size_54.x = (tmpvar_51.z - uv1_46.x);
          repeated_stretch_size_56.x = (tmpvar_7.z - segment_rect_p1_26.x);
        };
        horizontal_uv_size_55.y = (uv0_47.y - tmpvar_51.y);
        if (((horizontal_uv_size_55.y < 0.001) || (repeated_stretch_size_56.y < 0.001))) {
          horizontal_uv_size_55.y = (tmpvar_51.w - uv1_46.y);
          repeated_stretch_size_56.y = (tmpvar_7.w - segment_rect_p1_26.y);
        };
      };
      if (((tmpvar_29 & 4) != 0)) {
        stretch_size_43.x = (repeated_stretch_size_56.y * (tmpvar_57.x / horizontal_uv_size_55.y));
      };
      if (((tmpvar_29 & 8) != 0)) {
        stretch_size_43.y = (repeated_stretch_size_56.x * (tmpvar_58.y / vertical_uv_size_54.x));
      };
    } else {
      if (((tmpvar_29 & 4) != 0)) {
        stretch_size_43.x = (segment_data_27.z - segment_data_27.x);
      };
      if (((tmpvar_29 & 8) != 0)) {
        stretch_size_43.y = (segment_data_27.w - segment_data_27.y);
      };
    };
    if (((tmpvar_29 & 16) != 0)) {
      float tmpvar_59;
      tmpvar_59 = (segment_rect_p1_26.x - segment_rect_p0_25.x);
      stretch_size_43.x = (tmpvar_59 / max (1.0, roundEven(
        (tmpvar_59 / stretch_size_43.x)
      )));
    };
    if (((tmpvar_29 & 32) != 0)) {
      float tmpvar_60;
      tmpvar_60 = (segment_rect_p1_26.y - segment_rect_p0_25.y);
      stretch_size_43.y = (tmpvar_60 / max (1.0, roundEven(
        (tmpvar_60 / stretch_size_43.y)
      )));
    };
  };
  float tmpvar_61;
  if (((tmpvar_29 & 1) != 0)) {
    tmpvar_61 = 1.0;
  } else {
    tmpvar_61 = 0.0;
  };
  v_perspective.x = tmpvar_61;
  vec2 tmpvar_62;
  tmpvar_62 = min (uv0_47, uv1_46);
  vec4 tmpvar_63;
  tmpvar_63.xy = (tmpvar_62 + vec2(0.5, 0.5));
  tmpvar_63.zw = (max (uv0_47, uv1_46) - vec2(0.5, 0.5));
  v_uv_sample_bounds = tmpvar_63;
  vec2 tmpvar_64;
  tmpvar_64 = ((tmpvar_38 - local_rect_p0_44) / (local_rect_p1_45 - local_rect_p0_44));
  f_42 = tmpvar_64;
  if ((tmpvar_13.y == 1)) {
    int tmpvar_65;
    tmpvar_65 = (instance_resource_address_4 + 2);
    ivec2 tmpvar_66;
    tmpvar_66.x = int((uint(tmpvar_65) % 1024u));
    tmpvar_66.y = int((uint(tmpvar_65) / 1024u));
    vec4 tmpvar_67;
    tmpvar_67 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(1, 0)), tmpvar_64.x), mix (texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(3, 0)), tmpvar_64.x), tmpvar_64.y);
    f_42 = (tmpvar_67.xy / tmpvar_67.w);
  };
  v_uv = (mix (uv0_47, uv1_46, f_42) - tmpvar_62);
  v_uv = (v_uv * ((local_rect_p1_45 - local_rect_p0_44) / stretch_size_43));
  if ((tmpvar_61 == 0.0)) {
    v_uv = (v_uv * tmpvar_40.w);
  };
  vec2 tmpvar_68;
  tmpvar_68 = vec2(textureSize (sColor0));
  vec4 tmpvar_69;
  tmpvar_69.xy = vec2(0.0, 0.0);
  tmpvar_69.zw = tmpvar_68;
  v_uv_bounds = tmpvar_69;
  v_uv = (v_uv / tmpvar_68);
  v_local_pos = tmpvar_38;
}

#version 150
// brush_image
// features: ["ANTIALIASING", "DEBUG_OVERDRAW", "REPETITION", "TEXTURE_RECT"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

brush_image_ANTIALIASING_REPETITION_TEXTURE_2D#version 150
// brush_image
// features: ["ANTIALIASING", "REPETITION", "TEXTURE_2D"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  int instance_resource_address_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  instance_resource_address_4 = (aData.w & 16777215);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  ivec2 tmpvar_11;
  tmpvar_11.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_11.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(0, 0));
  ivec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_12.x);
  mat4 transform_m_14;
  bool transform_is_axis_aligned_15;
  transform_is_axis_aligned_15 = ((tmpvar_12.z >> 24) == 0);
  int tmpvar_16;
  tmpvar_16 = (tmpvar_12.z & 16777215);
  ivec2 tmpvar_17;
  tmpvar_17.x = int((8u * (
    uint(tmpvar_16)
   % 128u)));
  tmpvar_17.y = int((uint(tmpvar_16) / 128u));
  transform_m_14[0] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(0, 0));
  transform_m_14[1] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(1, 0));
  transform_m_14[2] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(2, 0));
  transform_m_14[3] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(3, 0));
  ivec2 tmpvar_18;
  tmpvar_18.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_18.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(0, 0));
  vec4 tmpvar_20;
  tmpvar_20 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(1, 0));
  vec2 tmpvar_21;
  vec2 tmpvar_22;
  tmpvar_21 = tmpvar_8.xy;
  tmpvar_22 = tmpvar_8.zw;
  vec2 adjusted_segment_rect_p0_23;
  vec2 adjusted_segment_rect_p1_24;
  vec2 segment_rect_p0_25;
  vec2 segment_rect_p1_26;
  vec4 segment_data_27;
  int tmpvar_28;
  tmpvar_28 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_29;
  tmpvar_29 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_25 = tmpvar_9;
    segment_rect_p1_26 = tmpvar_10;
    segment_data_27 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_30;
    tmpvar_30 = ((tmpvar_12.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_31;
    tmpvar_31.x = int((uint(tmpvar_30) % 1024u));
    tmpvar_31.y = int((uint(tmpvar_30) / 1024u));
    vec4 tmpvar_32;
    tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
    segment_rect_p0_25 = (tmpvar_32.xy + tmpvar_7.xy);
    segment_rect_p1_26 = (tmpvar_32.zw + tmpvar_7.xy);
    segment_data_27 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_23 = segment_rect_p0_25;
  adjusted_segment_rect_p1_24 = segment_rect_p1_26;
  if ((!(transform_is_axis_aligned_15) || ((tmpvar_29 & 256) != 0))) {
    vec2 tmpvar_33;
    tmpvar_33 = min (max (segment_rect_p0_25, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_34;
    tmpvar_34 = min (max (segment_rect_p1_26, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_35;
    tmpvar_35.x = bool((tmpvar_28 & 1));
    tmpvar_35.y = bool((tmpvar_28 & 2));
    tmpvar_35.z = bool((tmpvar_28 & 4));
    tmpvar_35.w = bool((tmpvar_28 & 8));
    vec4 tmpvar_36;
    tmpvar_36.xy = tmpvar_33;
    tmpvar_36.zw = tmpvar_34;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_36, bvec4(tmpvar_35));
    vec4 tmpvar_37;
    tmpvar_37 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_35));
    adjusted_segment_rect_p0_23 = (tmpvar_33 - tmpvar_37.xy);
    adjusted_segment_rect_p1_24 = (tmpvar_34 + tmpvar_37.zw);
    tmpvar_21 = vec2(-1e+16, -1e+16);
    tmpvar_22 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_38;
  tmpvar_38 = min (max (mix (adjusted_segment_rect_p0_23, adjusted_segment_rect_p1_24, aPosition), tmpvar_21), tmpvar_22);
  vec4 tmpvar_39;
  tmpvar_39.zw = vec2(0.0, 1.0);
  tmpvar_39.xy = tmpvar_38;
  vec4 tmpvar_40;
  tmpvar_40 = (transform_m_14 * tmpvar_39);
  vec4 tmpvar_41;
  tmpvar_41.xy = ((tmpvar_40.xy * tmpvar_20.x) + ((
    -(tmpvar_20.yz)
   + tmpvar_19.xy) * tmpvar_40.w));
  tmpvar_41.z = (ph_z_5 * tmpvar_40.w);
  tmpvar_41.w = tmpvar_40.w;
  gl_Position = (uTransform * tmpvar_41);
  vec2 f_42;
  vec2 stretch_size_43;
  vec2 local_rect_p0_44;
  vec2 local_rect_p1_45;
  vec2 uv1_46;
  vec2 uv0_47;
  ivec2 tmpvar_48;
  tmpvar_48.x = int((uint(tmpvar_12.y) % 1024u));
  tmpvar_48.y = int((uint(tmpvar_12.y) / 1024u));
  vec4 tmpvar_49;
  tmpvar_49 = texelFetchOffset (sGpuCache, tmpvar_48, 0, ivec2(2, 0));
  vec2 tmpvar_50;
  tmpvar_50 = vec2(textureSize (sColor0, 0));
  ivec2 tmpvar_51;
  tmpvar_51.x = int((uint(instance_resource_address_4) % 1024u));
  tmpvar_51.y = int((uint(instance_resource_address_4) / 1024u));
  vec4 tmpvar_52;
  tmpvar_52 = texelFetchOffset (sGpuCache, tmpvar_51, 0, ivec2(0, 0));
  uv0_47 = tmpvar_52.xy;
  uv1_46 = tmpvar_52.zw;
  local_rect_p0_44 = tmpvar_9;
  local_rect_p1_45 = tmpvar_10;
  stretch_size_43 = tmpvar_49.xy;
  if ((tmpvar_49.x < 0.0)) {
    stretch_size_43 = (tmpvar_7.zw - tmpvar_7.xy);
  };
  if (((tmpvar_29 & 2) != 0)) {
    local_rect_p0_44 = segment_rect_p0_25;
    local_rect_p1_45 = segment_rect_p1_26;
    vec2 tmpvar_53;
    tmpvar_53 = (segment_rect_p1_26 - segment_rect_p0_25);
    stretch_size_43 = tmpvar_53;
    if (((tmpvar_29 & 128) != 0)) {
      vec2 tmpvar_54;
      tmpvar_54 = (tmpvar_52.zw - tmpvar_52.xy);
      uv0_47 = (tmpvar_52.xy + (segment_data_27.xy * tmpvar_54));
      uv1_46 = (tmpvar_52.xy + (segment_data_27.zw * tmpvar_54));
    };
    if (((tmpvar_29 & 128) != 0)) {
      vec2 vertical_uv_size_55;
      vec2 horizontal_uv_size_56;
      vec2 repeated_stretch_size_57;
      repeated_stretch_size_57 = tmpvar_53;
      vec2 tmpvar_58;
      tmpvar_58 = (uv1_46 - uv0_47);
      horizontal_uv_size_56 = tmpvar_58;
      vec2 tmpvar_59;
      tmpvar_59 = (uv1_46 - uv0_47);
      vertical_uv_size_55 = tmpvar_59;
      if (((tmpvar_29 & 64) != 0)) {
        repeated_stretch_size_57 = (segment_rect_p0_25 - tmpvar_7.xy);
        vertical_uv_size_55.x = (uv0_47.x - tmpvar_52.x);
        if (((vertical_uv_size_55.x < 0.001) || (repeated_stretch_size_57.x < 0.001))) {
          vertical_uv_size_55.x = (tmpvar_52.z - uv1_46.x);
          repeated_stretch_size_57.x = (tmpvar_7.z - segment_rect_p1_26.x);
        };
        horizontal_uv_size_56.y = (uv0_47.y - tmpvar_52.y);
        if (((horizontal_uv_size_56.y < 0.001) || (repeated_stretch_size_57.y < 0.001))) {
          horizontal_uv_size_56.y = (tmpvar_52.w - uv1_46.y);
          repeated_stretch_size_57.y = (tmpvar_7.w - segment_rect_p1_26.y);
        };
      };
      if (((tmpvar_29 & 4) != 0)) {
        stretch_size_43.x = (repeated_stretch_size_57.y * (tmpvar_58.x / horizontal_uv_size_56.y));
      };
      if (((tmpvar_29 & 8) != 0)) {
        stretch_size_43.y = (repeated_stretch_size_57.x * (tmpvar_59.y / vertical_uv_size_55.x));
      };
    } else {
      if (((tmpvar_29 & 4) != 0)) {
        stretch_size_43.x = (segment_data_27.z - segment_data_27.x);
      };
      if (((tmpvar_29 & 8) != 0)) {
        stretch_size_43.y = (segment_data_27.w - segment_data_27.y);
      };
    };
    if (((tmpvar_29 & 16) != 0)) {
      float tmpvar_60;
      tmpvar_60 = (segment_rect_p1_26.x - segment_rect_p0_25.x);
      stretch_size_43.x = (tmpvar_60 / max (1.0, roundEven(
        (tmpvar_60 / stretch_size_43.x)
      )));
    };
    if (((tmpvar_29 & 32) != 0)) {
      float tmpvar_61;
      tmpvar_61 = (segment_rect_p1_26.y - segment_rect_p0_25.y);
      stretch_size_43.y = (tmpvar_61 / max (1.0, roundEven(
        (tmpvar_61 / stretch_size_43.y)
      )));
    };
  };
  float tmpvar_62;
  if (((tmpvar_29 & 1) != 0)) {
    tmpvar_62 = 1.0;
  } else {
    tmpvar_62 = 0.0;
  };
  v_perspective.x = tmpvar_62;
  vec2 tmpvar_63;
  tmpvar_63 = min (uv0_47, uv1_46);
  vec2 tmpvar_64;
  tmpvar_64 = max (uv0_47, uv1_46);
  vec4 tmpvar_65;
  tmpvar_65.xy = (tmpvar_63 + vec2(0.5, 0.5));
  tmpvar_65.zw = (tmpvar_64 - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_65 / tmpvar_50.xyxy);
  vec2 tmpvar_66;
  tmpvar_66 = ((tmpvar_38 - local_rect_p0_44) / (local_rect_p1_45 - local_rect_p0_44));
  f_42 = tmpvar_66;
  if ((tmpvar_13.y == 1)) {
    int tmpvar_67;
    tmpvar_67 = (instance_resource_address_4 + 2);
    ivec2 tmpvar_68;
    tmpvar_68.x = int((uint(tmpvar_67) % 1024u));
    tmpvar_68.y = int((uint(tmpvar_67) / 1024u));
    vec4 tmpvar_69;
    tmpvar_69 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_68, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_68, 0, ivec2(1, 0)), tmpvar_66.x), mix (texelFetchOffset (sGpuCache, tmpvar_68, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_68, 0, ivec2(3, 0)), tmpvar_66.x), tmpvar_66.y);
    f_42 = (tmpvar_69.xy / tmpvar_69.w);
  };
  v_uv = (mix (uv0_47, uv1_46, f_42) - tmpvar_63);
  v_uv = (v_uv / tmpvar_50);
  v_uv = (v_uv * ((local_rect_p1_45 - local_rect_p0_44) / stretch_size_43));
  if ((tmpvar_62 == 0.0)) {
    v_uv = (v_uv * tmpvar_40.w);
  };
  vec4 tmpvar_70;
  tmpvar_70.xy = tmpvar_63;
  tmpvar_70.zw = tmpvar_64;
  v_uv_bounds = (tmpvar_70 / tmpvar_50.xyxy);
  v_uv = (v_uv / (v_uv_bounds.zw - v_uv_bounds.xy));
  v_local_pos = tmpvar_38;
}

#version 150
// brush_image
// features: ["ANTIALIASING", "REPETITION", "TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
in vec2 v_uv;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  oFragColor = texture (sColor0, min (max ((
    (fract((v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x))) * (v_uv_bounds.zw - v_uv_bounds.xy))
   + v_uv_bounds.xy), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
}

brush_image_ANTIALIASING_REPETITION_TEXTURE_RECT#version 150
// brush_image
// features: ["ANTIALIASING", "REPETITION", "TEXTURE_RECT"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2DRect sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  int instance_resource_address_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  instance_resource_address_4 = (aData.w & 16777215);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  ivec2 tmpvar_11;
  tmpvar_11.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_11.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(0, 0));
  ivec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_12.x);
  mat4 transform_m_14;
  bool transform_is_axis_aligned_15;
  transform_is_axis_aligned_15 = ((tmpvar_12.z >> 24) == 0);
  int tmpvar_16;
  tmpvar_16 = (tmpvar_12.z & 16777215);
  ivec2 tmpvar_17;
  tmpvar_17.x = int((8u * (
    uint(tmpvar_16)
   % 128u)));
  tmpvar_17.y = int((uint(tmpvar_16) / 128u));
  transform_m_14[0] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(0, 0));
  transform_m_14[1] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(1, 0));
  transform_m_14[2] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(2, 0));
  transform_m_14[3] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(3, 0));
  ivec2 tmpvar_18;
  tmpvar_18.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_18.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(0, 0));
  vec4 tmpvar_20;
  tmpvar_20 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(1, 0));
  vec2 tmpvar_21;
  vec2 tmpvar_22;
  tmpvar_21 = tmpvar_8.xy;
  tmpvar_22 = tmpvar_8.zw;
  vec2 adjusted_segment_rect_p0_23;
  vec2 adjusted_segment_rect_p1_24;
  vec2 segment_rect_p0_25;
  vec2 segment_rect_p1_26;
  vec4 segment_data_27;
  int tmpvar_28;
  tmpvar_28 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_29;
  tmpvar_29 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_25 = tmpvar_9;
    segment_rect_p1_26 = tmpvar_10;
    segment_data_27 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_30;
    tmpvar_30 = ((tmpvar_12.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_31;
    tmpvar_31.x = int((uint(tmpvar_30) % 1024u));
    tmpvar_31.y = int((uint(tmpvar_30) / 1024u));
    vec4 tmpvar_32;
    tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
    segment_rect_p0_25 = (tmpvar_32.xy + tmpvar_7.xy);
    segment_rect_p1_26 = (tmpvar_32.zw + tmpvar_7.xy);
    segment_data_27 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_23 = segment_rect_p0_25;
  adjusted_segment_rect_p1_24 = segment_rect_p1_26;
  if ((!(transform_is_axis_aligned_15) || ((tmpvar_29 & 256) != 0))) {
    vec2 tmpvar_33;
    tmpvar_33 = min (max (segment_rect_p0_25, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_34;
    tmpvar_34 = min (max (segment_rect_p1_26, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_35;
    tmpvar_35.x = bool((tmpvar_28 & 1));
    tmpvar_35.y = bool((tmpvar_28 & 2));
    tmpvar_35.z = bool((tmpvar_28 & 4));
    tmpvar_35.w = bool((tmpvar_28 & 8));
    vec4 tmpvar_36;
    tmpvar_36.xy = tmpvar_33;
    tmpvar_36.zw = tmpvar_34;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_36, bvec4(tmpvar_35));
    vec4 tmpvar_37;
    tmpvar_37 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_35));
    adjusted_segment_rect_p0_23 = (tmpvar_33 - tmpvar_37.xy);
    adjusted_segment_rect_p1_24 = (tmpvar_34 + tmpvar_37.zw);
    tmpvar_21 = vec2(-1e+16, -1e+16);
    tmpvar_22 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_38;
  tmpvar_38 = min (max (mix (adjusted_segment_rect_p0_23, adjusted_segment_rect_p1_24, aPosition), tmpvar_21), tmpvar_22);
  vec4 tmpvar_39;
  tmpvar_39.zw = vec2(0.0, 1.0);
  tmpvar_39.xy = tmpvar_38;
  vec4 tmpvar_40;
  tmpvar_40 = (transform_m_14 * tmpvar_39);
  vec4 tmpvar_41;
  tmpvar_41.xy = ((tmpvar_40.xy * tmpvar_20.x) + ((
    -(tmpvar_20.yz)
   + tmpvar_19.xy) * tmpvar_40.w));
  tmpvar_41.z = (ph_z_5 * tmpvar_40.w);
  tmpvar_41.w = tmpvar_40.w;
  gl_Position = (uTransform * tmpvar_41);
  vec2 f_42;
  vec2 stretch_size_43;
  vec2 local_rect_p0_44;
  vec2 local_rect_p1_45;
  vec2 uv1_46;
  vec2 uv0_47;
  ivec2 tmpvar_48;
  tmpvar_48.x = int((uint(tmpvar_12.y) % 1024u));
  tmpvar_48.y = int((uint(tmpvar_12.y) / 1024u));
  vec4 tmpvar_49;
  tmpvar_49 = texelFetchOffset (sGpuCache, tmpvar_48, 0, ivec2(2, 0));
  ivec2 tmpvar_50;
  tmpvar_50.x = int((uint(instance_resource_address_4) % 1024u));
  tmpvar_50.y = int((uint(instance_resource_address_4) / 1024u));
  vec4 tmpvar_51;
  tmpvar_51 = texelFetchOffset (sGpuCache, tmpvar_50, 0, ivec2(0, 0));
  uv0_47 = tmpvar_51.xy;
  uv1_46 = tmpvar_51.zw;
  local_rect_p0_44 = tmpvar_9;
  local_rect_p1_45 = tmpvar_10;
  stretch_size_43 = tmpvar_49.xy;
  if ((tmpvar_49.x < 0.0)) {
    stretch_size_43 = (tmpvar_7.zw - tmpvar_7.xy);
  };
  if (((tmpvar_29 & 2) != 0)) {
    local_rect_p0_44 = segment_rect_p0_25;
    local_rect_p1_45 = segment_rect_p1_26;
    vec2 tmpvar_52;
    tmpvar_52 = (segment_rect_p1_26 - segment_rect_p0_25);
    stretch_size_43 = tmpvar_52;
    if (((tmpvar_29 & 128) != 0)) {
      vec2 tmpvar_53;
      tmpvar_53 = (tmpvar_51.zw - tmpvar_51.xy);
      uv0_47 = (tmpvar_51.xy + (segment_data_27.xy * tmpvar_53));
      uv1_46 = (tmpvar_51.xy + (segment_data_27.zw * tmpvar_53));
    };
    if (((tmpvar_29 & 128) != 0)) {
      vec2 vertical_uv_size_54;
      vec2 horizontal_uv_size_55;
      vec2 repeated_stretch_size_56;
      repeated_stretch_size_56 = tmpvar_52;
      vec2 tmpvar_57;
      tmpvar_57 = (uv1_46 - uv0_47);
      horizontal_uv_size_55 = tmpvar_57;
      vec2 tmpvar_58;
      tmpvar_58 = (uv1_46 - uv0_47);
      vertical_uv_size_54 = tmpvar_58;
      if (((tmpvar_29 & 64) != 0)) {
        repeated_stretch_size_56 = (segment_rect_p0_25 - tmpvar_7.xy);
        vertical_uv_size_54.x = (uv0_47.x - tmpvar_51.x);
        if (((vertical_uv_size_54.x < 0.001) || (repeated_stretch_size_56.x < 0.001))) {
          vertical_uv_size_54.x = (tmpvar_51.z - uv1_46.x);
          repeated_stretch_size_56.x = (tmpvar_7.z - segment_rect_p1_26.x);
        };
        horizontal_uv_size_55.y = (uv0_47.y - tmpvar_51.y);
        if (((horizontal_uv_size_55.y < 0.001) || (repeated_stretch_size_56.y < 0.001))) {
          horizontal_uv_size_55.y = (tmpvar_51.w - uv1_46.y);
          repeated_stretch_size_56.y = (tmpvar_7.w - segment_rect_p1_26.y);
        };
      };
      if (((tmpvar_29 & 4) != 0)) {
        stretch_size_43.x = (repeated_stretch_size_56.y * (tmpvar_57.x / horizontal_uv_size_55.y));
      };
      if (((tmpvar_29 & 8) != 0)) {
        stretch_size_43.y = (repeated_stretch_size_56.x * (tmpvar_58.y / vertical_uv_size_54.x));
      };
    } else {
      if (((tmpvar_29 & 4) != 0)) {
        stretch_size_43.x = (segment_data_27.z - segment_data_27.x);
      };
      if (((tmpvar_29 & 8) != 0)) {
        stretch_size_43.y = (segment_data_27.w - segment_data_27.y);
      };
    };
    if (((tmpvar_29 & 16) != 0)) {
      float tmpvar_59;
      tmpvar_59 = (segment_rect_p1_26.x - segment_rect_p0_25.x);
      stretch_size_43.x = (tmpvar_59 / max (1.0, roundEven(
        (tmpvar_59 / stretch_size_43.x)
      )));
    };
    if (((tmpvar_29 & 32) != 0)) {
      float tmpvar_60;
      tmpvar_60 = (segment_rect_p1_26.y - segment_rect_p0_25.y);
      stretch_size_43.y = (tmpvar_60 / max (1.0, roundEven(
        (tmpvar_60 / stretch_size_43.y)
      )));
    };
  };
  float tmpvar_61;
  if (((tmpvar_29 & 1) != 0)) {
    tmpvar_61 = 1.0;
  } else {
    tmpvar_61 = 0.0;
  };
  v_perspective.x = tmpvar_61;
  vec2 tmpvar_62;
  tmpvar_62 = min (uv0_47, uv1_46);
  vec4 tmpvar_63;
  tmpvar_63.xy = (tmpvar_62 + vec2(0.5, 0.5));
  tmpvar_63.zw = (max (uv0_47, uv1_46) - vec2(0.5, 0.5));
  v_uv_sample_bounds = tmpvar_63;
  vec2 tmpvar_64;
  tmpvar_64 = ((tmpvar_38 - local_rect_p0_44) / (local_rect_p1_45 - local_rect_p0_44));
  f_42 = tmpvar_64;
  if ((tmpvar_13.y == 1)) {
    int tmpvar_65;
    tmpvar_65 = (instance_resource_address_4 + 2);
    ivec2 tmpvar_66;
    tmpvar_66.x = int((uint(tmpvar_65) % 1024u));
    tmpvar_66.y = int((uint(tmpvar_65) / 1024u));
    vec4 tmpvar_67;
    tmpvar_67 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(1, 0)), tmpvar_64.x), mix (texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(3, 0)), tmpvar_64.x), tmpvar_64.y);
    f_42 = (tmpvar_67.xy / tmpvar_67.w);
  };
  v_uv = (mix (uv0_47, uv1_46, f_42) - tmpvar_62);
  v_uv = (v_uv * ((local_rect_p1_45 - local_rect_p0_44) / stretch_size_43));
  if ((tmpvar_61 == 0.0)) {
    v_uv = (v_uv * tmpvar_40.w);
  };
  vec2 tmpvar_68;
  tmpvar_68 = vec2(textureSize (sColor0));
  vec4 tmpvar_69;
  tmpvar_69.xy = vec2(0.0, 0.0);
  tmpvar_69.zw = tmpvar_68;
  v_uv_bounds = tmpvar_69;
  v_uv = (v_uv / tmpvar_68);
  v_local_pos = tmpvar_38;
}

#version 150
// brush_image
// features: ["ANTIALIASING", "REPETITION", "TEXTURE_RECT"]

precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
in vec2 v_uv;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  oFragColor = texture (sColor0, min (max ((
    (fract((v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x))) * (v_uv_bounds.zw - v_uv_bounds.xy))
   + v_uv_bounds.xy), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
}

brush_image_DEBUG_OVERDRAW_TEXTURE_2D#version 150
// brush_image
// features: ["DEBUG_OVERDRAW", "TEXTURE_2D"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_uv;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  int instance_resource_address_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  instance_resource_address_4 = (aData.w & 16777215);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  ivec2 tmpvar_11;
  tmpvar_11.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_11.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(0, 0));
  ivec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_12.x);
  mat4 transform_m_14;
  bool transform_is_axis_aligned_15;
  transform_is_axis_aligned_15 = ((tmpvar_12.z >> 24) == 0);
  int tmpvar_16;
  tmpvar_16 = (tmpvar_12.z & 16777215);
  ivec2 tmpvar_17;
  tmpvar_17.x = int((8u * (
    uint(tmpvar_16)
   % 128u)));
  tmpvar_17.y = int((uint(tmpvar_16) / 128u));
  transform_m_14[0] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(0, 0));
  transform_m_14[1] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(1, 0));
  transform_m_14[2] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(2, 0));
  transform_m_14[3] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(3, 0));
  ivec2 tmpvar_18;
  tmpvar_18.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_18.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(0, 0));
  vec4 tmpvar_20;
  tmpvar_20 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(1, 0));
  vec2 tmpvar_21;
  vec2 tmpvar_22;
  tmpvar_21 = tmpvar_8.xy;
  tmpvar_22 = tmpvar_8.zw;
  vec2 adjusted_segment_rect_p0_23;
  vec2 adjusted_segment_rect_p1_24;
  vec2 segment_rect_p0_25;
  vec2 segment_rect_p1_26;
  vec4 segment_data_27;
  int tmpvar_28;
  tmpvar_28 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_29;
  tmpvar_29 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_25 = tmpvar_9;
    segment_rect_p1_26 = tmpvar_10;
    segment_data_27 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_30;
    tmpvar_30 = ((tmpvar_12.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_31;
    tmpvar_31.x = int((uint(tmpvar_30) % 1024u));
    tmpvar_31.y = int((uint(tmpvar_30) / 1024u));
    vec4 tmpvar_32;
    tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
    segment_rect_p0_25 = (tmpvar_32.xy + tmpvar_7.xy);
    segment_rect_p1_26 = (tmpvar_32.zw + tmpvar_7.xy);
    segment_data_27 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_23 = segment_rect_p0_25;
  adjusted_segment_rect_p1_24 = segment_rect_p1_26;
  if ((!(transform_is_axis_aligned_15) || ((tmpvar_29 & 256) != 0))) {
    vec2 tmpvar_33;
    tmpvar_33 = min (max (segment_rect_p0_25, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_34;
    tmpvar_34 = min (max (segment_rect_p1_26, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_35;
    tmpvar_35.x = bool((tmpvar_28 & 1));
    tmpvar_35.y = bool((tmpvar_28 & 2));
    tmpvar_35.z = bool((tmpvar_28 & 4));
    tmpvar_35.w = bool((tmpvar_28 & 8));
    vec4 tmpvar_36;
    tmpvar_36.xy = tmpvar_33;
    tmpvar_36.zw = tmpvar_34;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_36, bvec4(tmpvar_35));
    vec4 tmpvar_37;
    tmpvar_37 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_35));
    adjusted_segment_rect_p0_23 = (tmpvar_33 - tmpvar_37.xy);
    adjusted_segment_rect_p1_24 = (tmpvar_34 + tmpvar_37.zw);
    tmpvar_21 = vec2(-1e+16, -1e+16);
    tmpvar_22 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_38;
  tmpvar_38 = min (max (mix (adjusted_segment_rect_p0_23, adjusted_segment_rect_p1_24, aPosition), tmpvar_21), tmpvar_22);
  vec4 tmpvar_39;
  tmpvar_39.zw = vec2(0.0, 1.0);
  tmpvar_39.xy = tmpvar_38;
  vec4 tmpvar_40;
  tmpvar_40 = (transform_m_14 * tmpvar_39);
  vec4 tmpvar_41;
  tmpvar_41.xy = ((tmpvar_40.xy * tmpvar_20.x) + ((
    -(tmpvar_20.yz)
   + tmpvar_19.xy) * tmpvar_40.w));
  tmpvar_41.z = (ph_z_5 * tmpvar_40.w);
  tmpvar_41.w = tmpvar_40.w;
  gl_Position = (uTransform * tmpvar_41);
  vec2 f_42;
  vec2 stretch_size_43;
  vec2 local_rect_p0_44;
  vec2 local_rect_p1_45;
  vec2 uv1_46;
  vec2 uv0_47;
  ivec2 tmpvar_48;
  tmpvar_48.x = int((uint(tmpvar_12.y) % 1024u));
  tmpvar_48.y = int((uint(tmpvar_12.y) / 1024u));
  vec4 tmpvar_49;
  tmpvar_49 = texelFetchOffset (sGpuCache, tmpvar_48, 0, ivec2(2, 0));
  vec2 tmpvar_50;
  tmpvar_50 = vec2(textureSize (sColor0, 0));
  ivec2 tmpvar_51;
  tmpvar_51.x = int((uint(instance_resource_address_4) % 1024u));
  tmpvar_51.y = int((uint(instance_resource_address_4) / 1024u));
  vec4 tmpvar_52;
  tmpvar_52 = texelFetchOffset (sGpuCache, tmpvar_51, 0, ivec2(0, 0));
  uv0_47 = tmpvar_52.xy;
  uv1_46 = tmpvar_52.zw;
  local_rect_p0_44 = tmpvar_9;
  local_rect_p1_45 = tmpvar_10;
  stretch_size_43 = tmpvar_49.xy;
  if ((tmpvar_49.x < 0.0)) {
    stretch_size_43 = (tmpvar_7.zw - tmpvar_7.xy);
  };
  if (((tmpvar_29 & 2) != 0)) {
    local_rect_p0_44 = segment_rect_p0_25;
    local_rect_p1_45 = segment_rect_p1_26;
    stretch_size_43 = (segment_rect_p1_26 - segment_rect_p0_25);
    if (((tmpvar_29 & 128) != 0)) {
      vec2 tmpvar_53;
      tmpvar_53 = (tmpvar_52.zw - tmpvar_52.xy);
      uv0_47 = (tmpvar_52.xy + (segment_data_27.xy * tmpvar_53));
      uv1_46 = (tmpvar_52.xy + (segment_data_27.zw * tmpvar_53));
    };
  };
  float tmpvar_54;
  if (((tmpvar_29 & 1) != 0)) {
    tmpvar_54 = 1.0;
  } else {
    tmpvar_54 = 0.0;
  };
  v_perspective.x = tmpvar_54;
  vec2 tmpvar_55;
  tmpvar_55 = min (uv0_47, uv1_46);
  vec2 tmpvar_56;
  tmpvar_56 = max (uv0_47, uv1_46);
  vec4 tmpvar_57;
  tmpvar_57.xy = (tmpvar_55 + vec2(0.5, 0.5));
  tmpvar_57.zw = (tmpvar_56 - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_57 / tmpvar_50.xyxy);
  vec2 tmpvar_58;
  tmpvar_58 = ((tmpvar_38 - local_rect_p0_44) / (local_rect_p1_45 - local_rect_p0_44));
  f_42 = tmpvar_58;
  if ((tmpvar_13.y == 1)) {
    int tmpvar_59;
    tmpvar_59 = (instance_resource_address_4 + 2);
    ivec2 tmpvar_60;
    tmpvar_60.x = int((uint(tmpvar_59) % 1024u));
    tmpvar_60.y = int((uint(tmpvar_59) / 1024u));
    vec4 tmpvar_61;
    tmpvar_61 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0)), tmpvar_58.x), mix (texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(3, 0)), tmpvar_58.x), tmpvar_58.y);
    f_42 = (tmpvar_61.xy / tmpvar_61.w);
  };
  v_uv = (mix (uv0_47, uv1_46, f_42) - tmpvar_55);
  v_uv = (v_uv / tmpvar_50);
  v_uv = (v_uv * ((local_rect_p1_45 - local_rect_p0_44) / stretch_size_43));
  if ((tmpvar_54 == 0.0)) {
    v_uv = (v_uv * tmpvar_40.w);
  };
  vec4 tmpvar_62;
  tmpvar_62.xy = tmpvar_55;
  tmpvar_62.zw = tmpvar_56;
  v_uv_bounds = (tmpvar_62 / tmpvar_50.xyxy);
}

#version 150
// brush_image
// features: ["DEBUG_OVERDRAW", "TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

brush_image_DEBUG_OVERDRAW_TEXTURE_RECT#version 150
// brush_image
// features: ["DEBUG_OVERDRAW", "TEXTURE_RECT"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2DRect sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_uv;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  int instance_resource_address_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  instance_resource_address_4 = (aData.w & 16777215);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  ivec2 tmpvar_11;
  tmpvar_11.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_11.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(0, 0));
  ivec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_12.x);
  mat4 transform_m_14;
  bool transform_is_axis_aligned_15;
  transform_is_axis_aligned_15 = ((tmpvar_12.z >> 24) == 0);
  int tmpvar_16;
  tmpvar_16 = (tmpvar_12.z & 16777215);
  ivec2 tmpvar_17;
  tmpvar_17.x = int((8u * (
    uint(tmpvar_16)
   % 128u)));
  tmpvar_17.y = int((uint(tmpvar_16) / 128u));
  transform_m_14[0] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(0, 0));
  transform_m_14[1] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(1, 0));
  transform_m_14[2] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(2, 0));
  transform_m_14[3] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(3, 0));
  ivec2 tmpvar_18;
  tmpvar_18.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_18.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(0, 0));
  vec4 tmpvar_20;
  tmpvar_20 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(1, 0));
  vec2 tmpvar_21;
  vec2 tmpvar_22;
  tmpvar_21 = tmpvar_8.xy;
  tmpvar_22 = tmpvar_8.zw;
  vec2 adjusted_segment_rect_p0_23;
  vec2 adjusted_segment_rect_p1_24;
  vec2 segment_rect_p0_25;
  vec2 segment_rect_p1_26;
  vec4 segment_data_27;
  int tmpvar_28;
  tmpvar_28 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_29;
  tmpvar_29 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_25 = tmpvar_9;
    segment_rect_p1_26 = tmpvar_10;
    segment_data_27 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_30;
    tmpvar_30 = ((tmpvar_12.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_31;
    tmpvar_31.x = int((uint(tmpvar_30) % 1024u));
    tmpvar_31.y = int((uint(tmpvar_30) / 1024u));
    vec4 tmpvar_32;
    tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
    segment_rect_p0_25 = (tmpvar_32.xy + tmpvar_7.xy);
    segment_rect_p1_26 = (tmpvar_32.zw + tmpvar_7.xy);
    segment_data_27 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_23 = segment_rect_p0_25;
  adjusted_segment_rect_p1_24 = segment_rect_p1_26;
  if ((!(transform_is_axis_aligned_15) || ((tmpvar_29 & 256) != 0))) {
    vec2 tmpvar_33;
    tmpvar_33 = min (max (segment_rect_p0_25, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_34;
    tmpvar_34 = min (max (segment_rect_p1_26, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_35;
    tmpvar_35.x = bool((tmpvar_28 & 1));
    tmpvar_35.y = bool((tmpvar_28 & 2));
    tmpvar_35.z = bool((tmpvar_28 & 4));
    tmpvar_35.w = bool((tmpvar_28 & 8));
    vec4 tmpvar_36;
    tmpvar_36.xy = tmpvar_33;
    tmpvar_36.zw = tmpvar_34;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_36, bvec4(tmpvar_35));
    vec4 tmpvar_37;
    tmpvar_37 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_35));
    adjusted_segment_rect_p0_23 = (tmpvar_33 - tmpvar_37.xy);
    adjusted_segment_rect_p1_24 = (tmpvar_34 + tmpvar_37.zw);
    tmpvar_21 = vec2(-1e+16, -1e+16);
    tmpvar_22 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_38;
  tmpvar_38 = min (max (mix (adjusted_segment_rect_p0_23, adjusted_segment_rect_p1_24, aPosition), tmpvar_21), tmpvar_22);
  vec4 tmpvar_39;
  tmpvar_39.zw = vec2(0.0, 1.0);
  tmpvar_39.xy = tmpvar_38;
  vec4 tmpvar_40;
  tmpvar_40 = (transform_m_14 * tmpvar_39);
  vec4 tmpvar_41;
  tmpvar_41.xy = ((tmpvar_40.xy * tmpvar_20.x) + ((
    -(tmpvar_20.yz)
   + tmpvar_19.xy) * tmpvar_40.w));
  tmpvar_41.z = (ph_z_5 * tmpvar_40.w);
  tmpvar_41.w = tmpvar_40.w;
  gl_Position = (uTransform * tmpvar_41);
  vec2 f_42;
  vec2 stretch_size_43;
  vec2 local_rect_p0_44;
  vec2 local_rect_p1_45;
  vec2 uv1_46;
  vec2 uv0_47;
  ivec2 tmpvar_48;
  tmpvar_48.x = int((uint(tmpvar_12.y) % 1024u));
  tmpvar_48.y = int((uint(tmpvar_12.y) / 1024u));
  vec4 tmpvar_49;
  tmpvar_49 = texelFetchOffset (sGpuCache, tmpvar_48, 0, ivec2(2, 0));
  ivec2 tmpvar_50;
  tmpvar_50.x = int((uint(instance_resource_address_4) % 1024u));
  tmpvar_50.y = int((uint(instance_resource_address_4) / 1024u));
  vec4 tmpvar_51;
  tmpvar_51 = texelFetchOffset (sGpuCache, tmpvar_50, 0, ivec2(0, 0));
  uv0_47 = tmpvar_51.xy;
  uv1_46 = tmpvar_51.zw;
  local_rect_p0_44 = tmpvar_9;
  local_rect_p1_45 = tmpvar_10;
  stretch_size_43 = tmpvar_49.xy;
  if ((tmpvar_49.x < 0.0)) {
    stretch_size_43 = (tmpvar_7.zw - tmpvar_7.xy);
  };
  if (((tmpvar_29 & 2) != 0)) {
    local_rect_p0_44 = segment_rect_p0_25;
    local_rect_p1_45 = segment_rect_p1_26;
    stretch_size_43 = (segment_rect_p1_26 - segment_rect_p0_25);
    if (((tmpvar_29 & 128) != 0)) {
      vec2 tmpvar_52;
      tmpvar_52 = (tmpvar_51.zw - tmpvar_51.xy);
      uv0_47 = (tmpvar_51.xy + (segment_data_27.xy * tmpvar_52));
      uv1_46 = (tmpvar_51.xy + (segment_data_27.zw * tmpvar_52));
    };
  };
  float tmpvar_53;
  if (((tmpvar_29 & 1) != 0)) {
    tmpvar_53 = 1.0;
  } else {
    tmpvar_53 = 0.0;
  };
  v_perspective.x = tmpvar_53;
  vec2 tmpvar_54;
  tmpvar_54 = min (uv0_47, uv1_46);
  vec4 tmpvar_55;
  tmpvar_55.xy = (tmpvar_54 + vec2(0.5, 0.5));
  tmpvar_55.zw = (max (uv0_47, uv1_46) - vec2(0.5, 0.5));
  v_uv_sample_bounds = tmpvar_55;
  vec2 tmpvar_56;
  tmpvar_56 = ((tmpvar_38 - local_rect_p0_44) / (local_rect_p1_45 - local_rect_p0_44));
  f_42 = tmpvar_56;
  if ((tmpvar_13.y == 1)) {
    int tmpvar_57;
    tmpvar_57 = (instance_resource_address_4 + 2);
    ivec2 tmpvar_58;
    tmpvar_58.x = int((uint(tmpvar_57) % 1024u));
    tmpvar_58.y = int((uint(tmpvar_57) / 1024u));
    vec4 tmpvar_59;
    tmpvar_59 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_58, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_58, 0, ivec2(1, 0)), tmpvar_56.x), mix (texelFetchOffset (sGpuCache, tmpvar_58, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_58, 0, ivec2(3, 0)), tmpvar_56.x), tmpvar_56.y);
    f_42 = (tmpvar_59.xy / tmpvar_59.w);
  };
  v_uv = (mix (uv0_47, uv1_46, f_42) - tmpvar_54);
  v_uv = (v_uv * ((local_rect_p1_45 - local_rect_p0_44) / stretch_size_43));
  if ((tmpvar_53 == 0.0)) {
    v_uv = (v_uv * tmpvar_40.w);
  };
  vec4 tmpvar_60;
  tmpvar_60.xy = vec2(0.0, 0.0);
  tmpvar_60.zw = vec2(textureSize (sColor0));
  v_uv_bounds = tmpvar_60;
}

#version 150
// brush_image
// features: ["DEBUG_OVERDRAW", "TEXTURE_RECT"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

brush_image_TEXTURE_2D#version 150
// brush_image
// features: ["TEXTURE_2D"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_uv;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  int instance_resource_address_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  instance_resource_address_4 = (aData.w & 16777215);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  ivec2 tmpvar_11;
  tmpvar_11.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_11.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(0, 0));
  ivec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_12.x);
  mat4 transform_m_14;
  bool transform_is_axis_aligned_15;
  transform_is_axis_aligned_15 = ((tmpvar_12.z >> 24) == 0);
  int tmpvar_16;
  tmpvar_16 = (tmpvar_12.z & 16777215);
  ivec2 tmpvar_17;
  tmpvar_17.x = int((8u * (
    uint(tmpvar_16)
   % 128u)));
  tmpvar_17.y = int((uint(tmpvar_16) / 128u));
  transform_m_14[0] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(0, 0));
  transform_m_14[1] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(1, 0));
  transform_m_14[2] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(2, 0));
  transform_m_14[3] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(3, 0));
  ivec2 tmpvar_18;
  tmpvar_18.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_18.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(0, 0));
  vec4 tmpvar_20;
  tmpvar_20 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(1, 0));
  vec2 tmpvar_21;
  vec2 tmpvar_22;
  tmpvar_21 = tmpvar_8.xy;
  tmpvar_22 = tmpvar_8.zw;
  vec2 adjusted_segment_rect_p0_23;
  vec2 adjusted_segment_rect_p1_24;
  vec2 segment_rect_p0_25;
  vec2 segment_rect_p1_26;
  vec4 segment_data_27;
  int tmpvar_28;
  tmpvar_28 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_29;
  tmpvar_29 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_25 = tmpvar_9;
    segment_rect_p1_26 = tmpvar_10;
    segment_data_27 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_30;
    tmpvar_30 = ((tmpvar_12.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_31;
    tmpvar_31.x = int((uint(tmpvar_30) % 1024u));
    tmpvar_31.y = int((uint(tmpvar_30) / 1024u));
    vec4 tmpvar_32;
    tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
    segment_rect_p0_25 = (tmpvar_32.xy + tmpvar_7.xy);
    segment_rect_p1_26 = (tmpvar_32.zw + tmpvar_7.xy);
    segment_data_27 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_23 = segment_rect_p0_25;
  adjusted_segment_rect_p1_24 = segment_rect_p1_26;
  if ((!(transform_is_axis_aligned_15) || ((tmpvar_29 & 256) != 0))) {
    vec2 tmpvar_33;
    tmpvar_33 = min (max (segment_rect_p0_25, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_34;
    tmpvar_34 = min (max (segment_rect_p1_26, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_35;
    tmpvar_35.x = bool((tmpvar_28 & 1));
    tmpvar_35.y = bool((tmpvar_28 & 2));
    tmpvar_35.z = bool((tmpvar_28 & 4));
    tmpvar_35.w = bool((tmpvar_28 & 8));
    vec4 tmpvar_36;
    tmpvar_36.xy = tmpvar_33;
    tmpvar_36.zw = tmpvar_34;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_36, bvec4(tmpvar_35));
    vec4 tmpvar_37;
    tmpvar_37 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_35));
    adjusted_segment_rect_p0_23 = (tmpvar_33 - tmpvar_37.xy);
    adjusted_segment_rect_p1_24 = (tmpvar_34 + tmpvar_37.zw);
    tmpvar_21 = vec2(-1e+16, -1e+16);
    tmpvar_22 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_38;
  tmpvar_38 = min (max (mix (adjusted_segment_rect_p0_23, adjusted_segment_rect_p1_24, aPosition), tmpvar_21), tmpvar_22);
  vec4 tmpvar_39;
  tmpvar_39.zw = vec2(0.0, 1.0);
  tmpvar_39.xy = tmpvar_38;
  vec4 tmpvar_40;
  tmpvar_40 = (transform_m_14 * tmpvar_39);
  vec4 tmpvar_41;
  tmpvar_41.xy = ((tmpvar_40.xy * tmpvar_20.x) + ((
    -(tmpvar_20.yz)
   + tmpvar_19.xy) * tmpvar_40.w));
  tmpvar_41.z = (ph_z_5 * tmpvar_40.w);
  tmpvar_41.w = tmpvar_40.w;
  gl_Position = (uTransform * tmpvar_41);
  vec2 f_42;
  vec2 stretch_size_43;
  vec2 local_rect_p0_44;
  vec2 local_rect_p1_45;
  vec2 uv1_46;
  vec2 uv0_47;
  ivec2 tmpvar_48;
  tmpvar_48.x = int((uint(tmpvar_12.y) % 1024u));
  tmpvar_48.y = int((uint(tmpvar_12.y) / 1024u));
  vec4 tmpvar_49;
  tmpvar_49 = texelFetchOffset (sGpuCache, tmpvar_48, 0, ivec2(2, 0));
  vec2 tmpvar_50;
  tmpvar_50 = vec2(textureSize (sColor0, 0));
  ivec2 tmpvar_51;
  tmpvar_51.x = int((uint(instance_resource_address_4) % 1024u));
  tmpvar_51.y = int((uint(instance_resource_address_4) / 1024u));
  vec4 tmpvar_52;
  tmpvar_52 = texelFetchOffset (sGpuCache, tmpvar_51, 0, ivec2(0, 0));
  uv0_47 = tmpvar_52.xy;
  uv1_46 = tmpvar_52.zw;
  local_rect_p0_44 = tmpvar_9;
  local_rect_p1_45 = tmpvar_10;
  stretch_size_43 = tmpvar_49.xy;
  if ((tmpvar_49.x < 0.0)) {
    stretch_size_43 = (tmpvar_7.zw - tmpvar_7.xy);
  };
  if (((tmpvar_29 & 2) != 0)) {
    local_rect_p0_44 = segment_rect_p0_25;
    local_rect_p1_45 = segment_rect_p1_26;
    stretch_size_43 = (segment_rect_p1_26 - segment_rect_p0_25);
    if (((tmpvar_29 & 128) != 0)) {
      vec2 tmpvar_53;
      tmpvar_53 = (tmpvar_52.zw - tmpvar_52.xy);
      uv0_47 = (tmpvar_52.xy + (segment_data_27.xy * tmpvar_53));
      uv1_46 = (tmpvar_52.xy + (segment_data_27.zw * tmpvar_53));
    };
  };
  float tmpvar_54;
  if (((tmpvar_29 & 1) != 0)) {
    tmpvar_54 = 1.0;
  } else {
    tmpvar_54 = 0.0;
  };
  v_perspective.x = tmpvar_54;
  vec2 tmpvar_55;
  tmpvar_55 = min (uv0_47, uv1_46);
  vec2 tmpvar_56;
  tmpvar_56 = max (uv0_47, uv1_46);
  vec4 tmpvar_57;
  tmpvar_57.xy = (tmpvar_55 + vec2(0.5, 0.5));
  tmpvar_57.zw = (tmpvar_56 - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_57 / tmpvar_50.xyxy);
  vec2 tmpvar_58;
  tmpvar_58 = ((tmpvar_38 - local_rect_p0_44) / (local_rect_p1_45 - local_rect_p0_44));
  f_42 = tmpvar_58;
  if ((tmpvar_13.y == 1)) {
    int tmpvar_59;
    tmpvar_59 = (instance_resource_address_4 + 2);
    ivec2 tmpvar_60;
    tmpvar_60.x = int((uint(tmpvar_59) % 1024u));
    tmpvar_60.y = int((uint(tmpvar_59) / 1024u));
    vec4 tmpvar_61;
    tmpvar_61 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(1, 0)), tmpvar_58.x), mix (texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(3, 0)), tmpvar_58.x), tmpvar_58.y);
    f_42 = (tmpvar_61.xy / tmpvar_61.w);
  };
  v_uv = (mix (uv0_47, uv1_46, f_42) - tmpvar_55);
  v_uv = (v_uv / tmpvar_50);
  v_uv = (v_uv * ((local_rect_p1_45 - local_rect_p0_44) / stretch_size_43));
  if ((tmpvar_54 == 0.0)) {
    v_uv = (v_uv * tmpvar_40.w);
  };
  vec4 tmpvar_62;
  tmpvar_62.xy = tmpvar_55;
  tmpvar_62.zw = tmpvar_56;
  v_uv_bounds = (tmpvar_62 / tmpvar_50.xyxy);
}

#version 150
// brush_image
// features: ["TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
in vec2 v_uv;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  oFragColor = texture (sColor0, min (max ((
    (v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x))
   + v_uv_bounds.xy), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
}

brush_image_TEXTURE_RECT#version 150
// brush_image
// features: ["TEXTURE_RECT"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2DRect sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_uv;
flat out vec4 v_uv_bounds;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_perspective;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  int instance_resource_address_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  instance_resource_address_4 = (aData.w & 16777215);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  ivec2 tmpvar_11;
  tmpvar_11.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_11.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(0, 0));
  ivec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_11, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_12.x);
  mat4 transform_m_14;
  bool transform_is_axis_aligned_15;
  transform_is_axis_aligned_15 = ((tmpvar_12.z >> 24) == 0);
  int tmpvar_16;
  tmpvar_16 = (tmpvar_12.z & 16777215);
  ivec2 tmpvar_17;
  tmpvar_17.x = int((8u * (
    uint(tmpvar_16)
   % 128u)));
  tmpvar_17.y = int((uint(tmpvar_16) / 128u));
  transform_m_14[0] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(0, 0));
  transform_m_14[1] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(1, 0));
  transform_m_14[2] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(2, 0));
  transform_m_14[3] = texelFetchOffset (sTransformPalette, tmpvar_17, 0, ivec2(3, 0));
  ivec2 tmpvar_18;
  tmpvar_18.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_18.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(0, 0));
  vec4 tmpvar_20;
  tmpvar_20 = texelFetchOffset (sRenderTasks, tmpvar_18, 0, ivec2(1, 0));
  vec2 tmpvar_21;
  vec2 tmpvar_22;
  tmpvar_21 = tmpvar_8.xy;
  tmpvar_22 = tmpvar_8.zw;
  vec2 adjusted_segment_rect_p0_23;
  vec2 adjusted_segment_rect_p1_24;
  vec2 segment_rect_p0_25;
  vec2 segment_rect_p1_26;
  vec4 segment_data_27;
  int tmpvar_28;
  tmpvar_28 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_29;
  tmpvar_29 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_25 = tmpvar_9;
    segment_rect_p1_26 = tmpvar_10;
    segment_data_27 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_30;
    tmpvar_30 = ((tmpvar_12.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_31;
    tmpvar_31.x = int((uint(tmpvar_30) % 1024u));
    tmpvar_31.y = int((uint(tmpvar_30) / 1024u));
    vec4 tmpvar_32;
    tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
    segment_rect_p0_25 = (tmpvar_32.xy + tmpvar_7.xy);
    segment_rect_p1_26 = (tmpvar_32.zw + tmpvar_7.xy);
    segment_data_27 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_23 = segment_rect_p0_25;
  adjusted_segment_rect_p1_24 = segment_rect_p1_26;
  if ((!(transform_is_axis_aligned_15) || ((tmpvar_29 & 256) != 0))) {
    vec2 tmpvar_33;
    tmpvar_33 = min (max (segment_rect_p0_25, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_34;
    tmpvar_34 = min (max (segment_rect_p1_26, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_35;
    tmpvar_35.x = bool((tmpvar_28 & 1));
    tmpvar_35.y = bool((tmpvar_28 & 2));
    tmpvar_35.z = bool((tmpvar_28 & 4));
    tmpvar_35.w = bool((tmpvar_28 & 8));
    vec4 tmpvar_36;
    tmpvar_36.xy = tmpvar_33;
    tmpvar_36.zw = tmpvar_34;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_36, bvec4(tmpvar_35));
    vec4 tmpvar_37;
    tmpvar_37 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_35));
    adjusted_segment_rect_p0_23 = (tmpvar_33 - tmpvar_37.xy);
    adjusted_segment_rect_p1_24 = (tmpvar_34 + tmpvar_37.zw);
    tmpvar_21 = vec2(-1e+16, -1e+16);
    tmpvar_22 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_38;
  tmpvar_38 = min (max (mix (adjusted_segment_rect_p0_23, adjusted_segment_rect_p1_24, aPosition), tmpvar_21), tmpvar_22);
  vec4 tmpvar_39;
  tmpvar_39.zw = vec2(0.0, 1.0);
  tmpvar_39.xy = tmpvar_38;
  vec4 tmpvar_40;
  tmpvar_40 = (transform_m_14 * tmpvar_39);
  vec4 tmpvar_41;
  tmpvar_41.xy = ((tmpvar_40.xy * tmpvar_20.x) + ((
    -(tmpvar_20.yz)
   + tmpvar_19.xy) * tmpvar_40.w));
  tmpvar_41.z = (ph_z_5 * tmpvar_40.w);
  tmpvar_41.w = tmpvar_40.w;
  gl_Position = (uTransform * tmpvar_41);
  vec2 f_42;
  vec2 stretch_size_43;
  vec2 local_rect_p0_44;
  vec2 local_rect_p1_45;
  vec2 uv1_46;
  vec2 uv0_47;
  ivec2 tmpvar_48;
  tmpvar_48.x = int((uint(tmpvar_12.y) % 1024u));
  tmpvar_48.y = int((uint(tmpvar_12.y) / 1024u));
  vec4 tmpvar_49;
  tmpvar_49 = texelFetchOffset (sGpuCache, tmpvar_48, 0, ivec2(2, 0));
  ivec2 tmpvar_50;
  tmpvar_50.x = int((uint(instance_resource_address_4) % 1024u));
  tmpvar_50.y = int((uint(instance_resource_address_4) / 1024u));
  vec4 tmpvar_51;
  tmpvar_51 = texelFetchOffset (sGpuCache, tmpvar_50, 0, ivec2(0, 0));
  uv0_47 = tmpvar_51.xy;
  uv1_46 = tmpvar_51.zw;
  local_rect_p0_44 = tmpvar_9;
  local_rect_p1_45 = tmpvar_10;
  stretch_size_43 = tmpvar_49.xy;
  if ((tmpvar_49.x < 0.0)) {
    stretch_size_43 = (tmpvar_7.zw - tmpvar_7.xy);
  };
  if (((tmpvar_29 & 2) != 0)) {
    local_rect_p0_44 = segment_rect_p0_25;
    local_rect_p1_45 = segment_rect_p1_26;
    stretch_size_43 = (segment_rect_p1_26 - segment_rect_p0_25);
    if (((tmpvar_29 & 128) != 0)) {
      vec2 tmpvar_52;
      tmpvar_52 = (tmpvar_51.zw - tmpvar_51.xy);
      uv0_47 = (tmpvar_51.xy + (segment_data_27.xy * tmpvar_52));
      uv1_46 = (tmpvar_51.xy + (segment_data_27.zw * tmpvar_52));
    };
  };
  float tmpvar_53;
  if (((tmpvar_29 & 1) != 0)) {
    tmpvar_53 = 1.0;
  } else {
    tmpvar_53 = 0.0;
  };
  v_perspective.x = tmpvar_53;
  vec2 tmpvar_54;
  tmpvar_54 = min (uv0_47, uv1_46);
  vec4 tmpvar_55;
  tmpvar_55.xy = (tmpvar_54 + vec2(0.5, 0.5));
  tmpvar_55.zw = (max (uv0_47, uv1_46) - vec2(0.5, 0.5));
  v_uv_sample_bounds = tmpvar_55;
  vec2 tmpvar_56;
  tmpvar_56 = ((tmpvar_38 - local_rect_p0_44) / (local_rect_p1_45 - local_rect_p0_44));
  f_42 = tmpvar_56;
  if ((tmpvar_13.y == 1)) {
    int tmpvar_57;
    tmpvar_57 = (instance_resource_address_4 + 2);
    ivec2 tmpvar_58;
    tmpvar_58.x = int((uint(tmpvar_57) % 1024u));
    tmpvar_58.y = int((uint(tmpvar_57) / 1024u));
    vec4 tmpvar_59;
    tmpvar_59 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_58, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_58, 0, ivec2(1, 0)), tmpvar_56.x), mix (texelFetchOffset (sGpuCache, tmpvar_58, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_58, 0, ivec2(3, 0)), tmpvar_56.x), tmpvar_56.y);
    f_42 = (tmpvar_59.xy / tmpvar_59.w);
  };
  v_uv = (mix (uv0_47, uv1_46, f_42) - tmpvar_54);
  v_uv = (v_uv * ((local_rect_p1_45 - local_rect_p0_44) / stretch_size_43));
  if ((tmpvar_53 == 0.0)) {
    v_uv = (v_uv * tmpvar_40.w);
  };
  vec4 tmpvar_60;
  tmpvar_60.xy = vec2(0.0, 0.0);
  tmpvar_60.zw = vec2(textureSize (sColor0));
  v_uv_bounds = tmpvar_60;
}

#version 150
// brush_image
// features: ["TEXTURE_RECT"]

precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
in vec2 v_uv;
flat in vec4 v_uv_bounds;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_perspective;
void main ()
{
  oFragColor = texture (sColor0, min (max ((
    (v_uv * mix (gl_FragCoord.w, 1.0, v_perspective.x))
   + v_uv_bounds.xy), v_uv_sample_bounds.xy), v_uv_sample_bounds.zw));
}

#version 150
// brush_linear_gradient
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
flat out ivec2 v_gradient_address;
flat out vec2 v_gradient_repeat;
flat out vec2 v_repeated_size;
out vec2 v_pos;
flat out vec2 v_start_offset;
flat out vec2 v_scale_dir;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  vec4 segment_data_26;
  int tmpvar_27;
  tmpvar_27 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_28;
  tmpvar_28 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
    segment_data_26 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_29;
    tmpvar_29 = ((tmpvar_11.y + 2) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_30;
    tmpvar_30.x = int((uint(tmpvar_29) % 1024u));
    tmpvar_30.y = int((uint(tmpvar_29) / 1024u));
    vec4 tmpvar_31;
    tmpvar_31 = texelFetchOffset (sGpuCache, tmpvar_30, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_31.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_31.zw + tmpvar_6.xy);
    segment_data_26 = texelFetchOffset (sGpuCache, tmpvar_30, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_28 & 256) != 0))) {
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_33;
    tmpvar_33 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_34;
    tmpvar_34.x = bool((tmpvar_27 & 1));
    tmpvar_34.y = bool((tmpvar_27 & 2));
    tmpvar_34.z = bool((tmpvar_27 & 4));
    tmpvar_34.w = bool((tmpvar_27 & 8));
    vec4 tmpvar_35;
    tmpvar_35.xy = tmpvar_32;
    tmpvar_35.zw = tmpvar_33;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_35, bvec4(tmpvar_34));
    vec4 tmpvar_36;
    tmpvar_36 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_34));
    adjusted_segment_rect_p0_22 = (tmpvar_32 - tmpvar_36.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_33 + tmpvar_36.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_37;
  tmpvar_37 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_38;
  tmpvar_38.zw = vec2(0.0, 1.0);
  tmpvar_38.xy = tmpvar_37;
  vec4 tmpvar_39;
  tmpvar_39 = (transform_m_13 * tmpvar_38);
  vec4 tmpvar_40;
  tmpvar_40.xy = ((tmpvar_39.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_39.w));
  tmpvar_40.z = (ph_z_4 * tmpvar_39.w);
  tmpvar_40.w = tmpvar_39.w;
  gl_Position = (uTransform * tmpvar_40);
  ivec2 tmpvar_41;
  tmpvar_41.x = int((uint(tmpvar_11.y) % 1024u));
  tmpvar_41.y = int((uint(tmpvar_11.y) / 1024u));
  vec4 tmpvar_42;
  vec4 tmpvar_43;
  tmpvar_42 = texelFetchOffset (sGpuCache, tmpvar_41, 0, ivec2(0, 0));
  tmpvar_43 = texelFetchOffset (sGpuCache, tmpvar_41, 0, ivec2(1, 0));
  int tmpvar_44;
  tmpvar_44 = int(tmpvar_43.x);
  vec2 tmpvar_45;
  tmpvar_45 = tmpvar_43.yz;
  if (((tmpvar_28 & 2) != 0)) {
    v_pos = ((tmpvar_37 - segment_rect_p0_24) / (segment_rect_p1_25 - segment_rect_p0_24));
    v_pos = ((v_pos * (segment_data_26.zw - segment_data_26.xy)) + segment_data_26.xy);
    v_pos = (v_pos * (tmpvar_6.zw - tmpvar_6.xy));
  } else {
    v_pos = (tmpvar_37 - tmpvar_6.xy);
  };
  v_repeated_size = tmpvar_45;
  v_pos = (v_pos / tmpvar_43.yz);
  v_gradient_address.x = tmpvar_12.x;
  v_gradient_repeat.x = float((tmpvar_44 == 1));
  vec2 tmpvar_46;
  tmpvar_46 = (tmpvar_42.zw - tmpvar_42.xy);
  v_scale_dir = (tmpvar_46 / dot (tmpvar_46, tmpvar_46));
  v_start_offset.x = dot (tmpvar_42.xy, v_scale_dir);
  v_scale_dir = (v_scale_dir * tmpvar_43.yz);
}

#version 150
// brush_linear_gradient
// features: []

precision highp float;
out vec4 oFragColor;
uniform sampler2D sGpuCache;
flat in ivec2 v_gradient_address;
flat in vec2 v_gradient_repeat;
in vec2 v_pos;
flat in vec2 v_start_offset;
flat in vec2 v_scale_dir;
void main ()
{
  float tmpvar_1;
  tmpvar_1 = (dot (fract(v_pos), v_scale_dir) - v_start_offset.x);
  float tmpvar_2;
  tmpvar_2 = min (max ((1.0 + 
    ((tmpvar_1 - (floor(tmpvar_1) * v_gradient_repeat.x)) * 128.0)
  ), 0.0), 129.0);
  float tmpvar_3;
  tmpvar_3 = floor(tmpvar_2);
  int tmpvar_4;
  tmpvar_4 = (v_gradient_address.x + (2 * int(tmpvar_3)));
  ivec2 tmpvar_5;
  tmpvar_5.x = int((uint(tmpvar_4) % 1024u));
  tmpvar_5.y = int((uint(tmpvar_4) / 1024u));
  oFragColor = (texelFetchOffset (sGpuCache, tmpvar_5, 0, ivec2(0, 0)) + (texelFetchOffset (sGpuCache, tmpvar_5, 0, ivec2(1, 0)) * (tmpvar_2 - tmpvar_3)));
}

#version 150
// brush_linear_gradient
// features: ["ALPHA_PASS"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
flat out ivec2 v_gradient_address;
flat out vec2 v_gradient_repeat;
flat out vec2 v_repeated_size;
out vec2 v_pos;
flat out vec2 v_tile_repeat;
flat out vec2 v_start_offset;
flat out vec2 v_scale_dir;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  vec2 tmpvar_11;
  vec2 tmpvar_12;
  tmpvar_11 = tmpvar_8.xy;
  tmpvar_12 = tmpvar_8.zw;
  ivec2 tmpvar_13;
  tmpvar_13.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_13.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(0, 0));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_14.x);
  mat4 transform_m_16;
  bool transform_is_axis_aligned_17;
  transform_is_axis_aligned_17 = ((tmpvar_14.z >> 24) == 0);
  int tmpvar_18;
  tmpvar_18 = (tmpvar_14.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_16[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_16[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_16[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_16[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  ivec2 tmpvar_20;
  tmpvar_20.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_20.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_21;
  tmpvar_21 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(0, 0));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_23;
  float area_device_pixel_scale_24;
  vec2 area_screen_origin_25;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_23 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_24 = 0.0;
    area_screen_origin_25 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_26;
    tmpvar_26.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_26.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_27;
    tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
    area_task_rect_23.p0 = tmpvar_27.xy;
    area_task_rect_23.p1 = tmpvar_27.zw;
    area_device_pixel_scale_24 = tmpvar_28.x;
    area_screen_origin_25 = tmpvar_28.yz;
  };
  vec2 tmpvar_29;
  vec2 tmpvar_30;
  tmpvar_29 = tmpvar_11;
  tmpvar_30 = tmpvar_12;
  vec2 adjusted_segment_rect_p0_31;
  vec2 adjusted_segment_rect_p1_32;
  vec2 segment_rect_p0_33;
  vec2 segment_rect_p1_34;
  vec4 segment_data_35;
  int tmpvar_36;
  tmpvar_36 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_37;
  tmpvar_37 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_33 = tmpvar_9;
    segment_rect_p1_34 = tmpvar_10;
    segment_data_35 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_38;
    tmpvar_38 = ((tmpvar_14.y + 2) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_39;
    tmpvar_39.x = int((uint(tmpvar_38) % 1024u));
    tmpvar_39.y = int((uint(tmpvar_38) / 1024u));
    vec4 tmpvar_40;
    tmpvar_40 = texelFetchOffset (sGpuCache, tmpvar_39, 0, ivec2(0, 0));
    segment_rect_p0_33 = (tmpvar_40.xy + tmpvar_7.xy);
    segment_rect_p1_34 = (tmpvar_40.zw + tmpvar_7.xy);
    segment_data_35 = texelFetchOffset (sGpuCache, tmpvar_39, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_31 = segment_rect_p0_33;
  adjusted_segment_rect_p1_32 = segment_rect_p1_34;
  if ((!(transform_is_axis_aligned_17) || ((tmpvar_37 & 256) != 0))) {
    vec2 tmpvar_41;
    tmpvar_41 = min (max (segment_rect_p0_33, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_42;
    tmpvar_42 = min (max (segment_rect_p1_34, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_43;
    tmpvar_43.x = bool((tmpvar_36 & 1));
    tmpvar_43.y = bool((tmpvar_36 & 2));
    tmpvar_43.z = bool((tmpvar_36 & 4));
    tmpvar_43.w = bool((tmpvar_36 & 8));
    vec4 tmpvar_44;
    tmpvar_44.xy = tmpvar_41;
    tmpvar_44.zw = tmpvar_42;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_44, bvec4(tmpvar_43));
    vec4 tmpvar_45;
    tmpvar_45 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_43));
    adjusted_segment_rect_p0_31 = (tmpvar_41 - tmpvar_45.xy);
    adjusted_segment_rect_p1_32 = (tmpvar_42 + tmpvar_45.zw);
    tmpvar_29 = vec2(-1e+16, -1e+16);
    tmpvar_30 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_46;
  tmpvar_46 = min (max (mix (adjusted_segment_rect_p0_31, adjusted_segment_rect_p1_32, aPosition), tmpvar_29), tmpvar_30);
  vec4 tmpvar_47;
  tmpvar_47.zw = vec2(0.0, 1.0);
  tmpvar_47.xy = tmpvar_46;
  vec4 tmpvar_48;
  tmpvar_48 = (transform_m_16 * tmpvar_47);
  vec4 tmpvar_49;
  tmpvar_49.xy = ((tmpvar_48.xy * tmpvar_22.x) + ((
    -(tmpvar_22.yz)
   + tmpvar_21.xy) * tmpvar_48.w));
  tmpvar_49.z = (ph_z_5 * tmpvar_48.w);
  tmpvar_49.w = tmpvar_48.w;
  gl_Position = (uTransform * tmpvar_49);
  vec4 tmpvar_50;
  tmpvar_50.xy = area_task_rect_23.p0;
  tmpvar_50.zw = area_task_rect_23.p1;
  vClipMaskUvBounds = tmpvar_50;
  vClipMaskUv = ((tmpvar_48.xy * area_device_pixel_scale_24) + (tmpvar_48.w * (area_task_rect_23.p0 - area_screen_origin_25)));
  ivec2 tmpvar_51;
  tmpvar_51.x = int((uint(tmpvar_14.y) % 1024u));
  tmpvar_51.y = int((uint(tmpvar_14.y) / 1024u));
  vec4 tmpvar_52;
  vec4 tmpvar_53;
  tmpvar_52 = texelFetchOffset (sGpuCache, tmpvar_51, 0, ivec2(0, 0));
  tmpvar_53 = texelFetchOffset (sGpuCache, tmpvar_51, 0, ivec2(1, 0));
  int tmpvar_54;
  tmpvar_54 = int(tmpvar_53.x);
  vec2 tmpvar_55;
  tmpvar_55 = tmpvar_53.yz;
  if (((tmpvar_37 & 2) != 0)) {
    v_pos = ((tmpvar_46 - segment_rect_p0_33) / (segment_rect_p1_34 - segment_rect_p0_33));
    v_pos = ((v_pos * (segment_data_35.zw - segment_data_35.xy)) + segment_data_35.xy);
    v_pos = (v_pos * (tmpvar_7.zw - tmpvar_7.xy));
  } else {
    v_pos = (tmpvar_46 - tmpvar_7.xy);
  };
  v_repeated_size = tmpvar_55;
  v_pos = (v_pos / tmpvar_53.yz);
  v_gradient_address.x = tmpvar_15.x;
  v_gradient_repeat.x = float((tmpvar_54 == 1));
  v_tile_repeat = ((tmpvar_7.zw - tmpvar_7.xy) / tmpvar_53.yz);
  vec2 tmpvar_56;
  tmpvar_56 = (tmpvar_52.zw - tmpvar_52.xy);
  v_scale_dir = (tmpvar_56 / dot (tmpvar_56, tmpvar_56));
  v_start_offset.x = dot (tmpvar_52.xy, v_scale_dir);
  v_scale_dir = (v_scale_dir * tmpvar_53.yz);
  v_local_pos = tmpvar_46;
}

#version 150
// brush_linear_gradient
// features: ["ALPHA_PASS"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sGpuCache;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
flat in ivec2 v_gradient_address;
flat in vec2 v_gradient_repeat;
in vec2 v_pos;
flat in vec2 v_tile_repeat;
flat in vec2 v_start_offset;
flat in vec2 v_scale_dir;
void main ()
{
  vec4 frag_color_1;
  vec2 pos_2;
  vec2 tmpvar_3;
  tmpvar_3 = max (v_pos, vec2(0.0, 0.0));
  pos_2 = fract(tmpvar_3);
  if ((tmpvar_3.x >= v_tile_repeat.x)) {
    pos_2.x = 1.0;
  };
  if ((tmpvar_3.y >= v_tile_repeat.y)) {
    pos_2.y = 1.0;
  };
  float tmpvar_4;
  tmpvar_4 = (dot (pos_2, v_scale_dir) - v_start_offset.x);
  float tmpvar_5;
  tmpvar_5 = min (max ((1.0 + 
    ((tmpvar_4 - (floor(tmpvar_4) * v_gradient_repeat.x)) * 128.0)
  ), 0.0), 129.0);
  float tmpvar_6;
  tmpvar_6 = floor(tmpvar_5);
  int tmpvar_7;
  tmpvar_7 = (v_gradient_address.x + (2 * int(tmpvar_6)));
  ivec2 tmpvar_8;
  tmpvar_8.x = int((uint(tmpvar_7) % 1024u));
  tmpvar_8.y = int((uint(tmpvar_7) / 1024u));
  vec2 tmpvar_9;
  tmpvar_9 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  frag_color_1 = ((texelFetchOffset (sGpuCache, tmpvar_8, 0, ivec2(0, 0)) + (texelFetchOffset (sGpuCache, tmpvar_8, 0, ivec2(1, 0)) * 
    (tmpvar_5 - tmpvar_6)
  )) * min (max (
    (0.5 - max (tmpvar_9.x, tmpvar_9.y))
  , 0.0), 1.0));
  float tmpvar_10;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_10 = 1.0;
  } else {
    vec2 tmpvar_11;
    tmpvar_11 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_12;
    tmpvar_12.xy = greaterThanEqual (tmpvar_11, vClipMaskUvBounds.xy);
    tmpvar_12.zw = lessThan (tmpvar_11, vClipMaskUvBounds.zw);
    bool tmpvar_13;
    tmpvar_13 = (tmpvar_12 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_13)) {
      tmpvar_10 = 0.0;
    } else {
      tmpvar_10 = texelFetch (sClipMask, ivec2(tmpvar_11), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_10);
  oFragColor = frag_color_1;
}

brush_linear_gradient_DEBUG_OVERDRAW#version 150
// brush_linear_gradient
// features: ["DEBUG_OVERDRAW"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
flat out ivec2 v_gradient_address;
flat out vec2 v_gradient_repeat;
flat out vec2 v_repeated_size;
out vec2 v_pos;
flat out vec2 v_start_offset;
flat out vec2 v_scale_dir;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  vec4 segment_data_26;
  int tmpvar_27;
  tmpvar_27 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_28;
  tmpvar_28 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
    segment_data_26 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    int tmpvar_29;
    tmpvar_29 = ((tmpvar_11.y + 2) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_30;
    tmpvar_30.x = int((uint(tmpvar_29) % 1024u));
    tmpvar_30.y = int((uint(tmpvar_29) / 1024u));
    vec4 tmpvar_31;
    tmpvar_31 = texelFetchOffset (sGpuCache, tmpvar_30, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_31.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_31.zw + tmpvar_6.xy);
    segment_data_26 = texelFetchOffset (sGpuCache, tmpvar_30, 0, ivec2(1, 0));
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_28 & 256) != 0))) {
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_33;
    tmpvar_33 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_34;
    tmpvar_34.x = bool((tmpvar_27 & 1));
    tmpvar_34.y = bool((tmpvar_27 & 2));
    tmpvar_34.z = bool((tmpvar_27 & 4));
    tmpvar_34.w = bool((tmpvar_27 & 8));
    vec4 tmpvar_35;
    tmpvar_35.xy = tmpvar_32;
    tmpvar_35.zw = tmpvar_33;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_35, bvec4(tmpvar_34));
    vec4 tmpvar_36;
    tmpvar_36 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_34));
    adjusted_segment_rect_p0_22 = (tmpvar_32 - tmpvar_36.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_33 + tmpvar_36.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_37;
  tmpvar_37 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_38;
  tmpvar_38.zw = vec2(0.0, 1.0);
  tmpvar_38.xy = tmpvar_37;
  vec4 tmpvar_39;
  tmpvar_39 = (transform_m_13 * tmpvar_38);
  vec4 tmpvar_40;
  tmpvar_40.xy = ((tmpvar_39.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_39.w));
  tmpvar_40.z = (ph_z_4 * tmpvar_39.w);
  tmpvar_40.w = tmpvar_39.w;
  gl_Position = (uTransform * tmpvar_40);
  ivec2 tmpvar_41;
  tmpvar_41.x = int((uint(tmpvar_11.y) % 1024u));
  tmpvar_41.y = int((uint(tmpvar_11.y) / 1024u));
  vec4 tmpvar_42;
  vec4 tmpvar_43;
  tmpvar_42 = texelFetchOffset (sGpuCache, tmpvar_41, 0, ivec2(0, 0));
  tmpvar_43 = texelFetchOffset (sGpuCache, tmpvar_41, 0, ivec2(1, 0));
  int tmpvar_44;
  tmpvar_44 = int(tmpvar_43.x);
  vec2 tmpvar_45;
  tmpvar_45 = tmpvar_43.yz;
  if (((tmpvar_28 & 2) != 0)) {
    v_pos = ((tmpvar_37 - segment_rect_p0_24) / (segment_rect_p1_25 - segment_rect_p0_24));
    v_pos = ((v_pos * (segment_data_26.zw - segment_data_26.xy)) + segment_data_26.xy);
    v_pos = (v_pos * (tmpvar_6.zw - tmpvar_6.xy));
  } else {
    v_pos = (tmpvar_37 - tmpvar_6.xy);
  };
  v_repeated_size = tmpvar_45;
  v_pos = (v_pos / tmpvar_43.yz);
  v_gradient_address.x = tmpvar_12.x;
  v_gradient_repeat.x = float((tmpvar_44 == 1));
  vec2 tmpvar_46;
  tmpvar_46 = (tmpvar_42.zw - tmpvar_42.xy);
  v_scale_dir = (tmpvar_46 / dot (tmpvar_46, tmpvar_46));
  v_start_offset.x = dot (tmpvar_42.xy, v_scale_dir);
  v_scale_dir = (v_scale_dir * tmpvar_43.yz);
}

#version 150
// brush_linear_gradient
// features: ["DEBUG_OVERDRAW"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

2a001148bf4266b#version 150
// brush_mix_blend
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_src_uv;
flat out vec4 v_src_uv_sample_bounds;
out vec2 v_backdrop_uv;
flat out vec4 v_backdrop_uv_sample_bounds;
flat out vec2 v_perspective;
flat out ivec2 v_op;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  vec2 tmpvar_40;
  tmpvar_40 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  float tmpvar_41;
  if (((tmpvar_27 & 1) != 0)) {
    tmpvar_41 = 1.0;
  } else {
    tmpvar_41 = 0.0;
  };
  v_perspective.x = tmpvar_41;
  v_op.x = tmpvar_12.x;
  vec2 inv_texture_size_42;
  ivec2 tmpvar_43;
  tmpvar_43.x = int((uint(tmpvar_12.y) % 1024u));
  tmpvar_43.y = int((uint(tmpvar_12.y) / 1024u));
  vec4 tmpvar_44;
  tmpvar_44 = texelFetchOffset (sGpuCache, tmpvar_43, 0, ivec2(0, 0));
  inv_texture_size_42 = (1.0/(vec2(textureSize (sColor0, 0))));
  int tmpvar_45;
  tmpvar_45 = (tmpvar_12.y + 2);
  ivec2 tmpvar_46;
  tmpvar_46.x = int((uint(tmpvar_45) % 1024u));
  tmpvar_46.y = int((uint(tmpvar_45) / 1024u));
  vec4 tmpvar_47;
  tmpvar_47 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_46, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_46, 0, ivec2(1, 0)), tmpvar_40.x), mix (texelFetchOffset (sGpuCache, tmpvar_46, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_46, 0, ivec2(3, 0)), tmpvar_40.x), tmpvar_40.y);
  vec4 tmpvar_48;
  tmpvar_48.xy = (tmpvar_44.xy + vec2(0.5, 0.5));
  tmpvar_48.zw = (tmpvar_44.zw - vec2(0.5, 0.5));
  v_backdrop_uv = (mix (tmpvar_44.xy, tmpvar_44.zw, (tmpvar_47.xy / tmpvar_47.w)) * inv_texture_size_42);
  v_backdrop_uv_sample_bounds = (tmpvar_48 * inv_texture_size_42.xyxy);
  vec2 inv_texture_size_49;
  ivec2 tmpvar_50;
  tmpvar_50.x = int((uint(tmpvar_12.z) % 1024u));
  tmpvar_50.y = int((uint(tmpvar_12.z) / 1024u));
  vec4 tmpvar_51;
  tmpvar_51 = texelFetchOffset (sGpuCache, tmpvar_50, 0, ivec2(0, 0));
  inv_texture_size_49 = (1.0/(vec2(textureSize (sColor1, 0))));
  int tmpvar_52;
  tmpvar_52 = (tmpvar_12.z + 2);
  ivec2 tmpvar_53;
  tmpvar_53.x = int((uint(tmpvar_52) % 1024u));
  tmpvar_53.y = int((uint(tmpvar_52) / 1024u));
  vec4 tmpvar_54;
  tmpvar_54 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_53, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_53, 0, ivec2(1, 0)), tmpvar_40.x), mix (texelFetchOffset (sGpuCache, tmpvar_53, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_53, 0, ivec2(3, 0)), tmpvar_40.x), tmpvar_40.y);
  vec4 tmpvar_55;
  tmpvar_55.xy = (tmpvar_51.xy + vec2(0.5, 0.5));
  tmpvar_55.zw = (tmpvar_51.zw - vec2(0.5, 0.5));
  v_src_uv = ((mix (tmpvar_51.xy, tmpvar_51.zw, 
    (tmpvar_54.xy / tmpvar_54.w)
  ) * inv_texture_size_49) * mix (tmpvar_38.w, 1.0, tmpvar_41));
  v_src_uv_sample_bounds = (tmpvar_55 * inv_texture_size_49.xyxy);
}

#version 150
// brush_mix_blend
// features: []

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
in vec2 v_src_uv;
flat in vec4 v_src_uv_sample_bounds;
in vec2 v_backdrop_uv;
flat in vec4 v_backdrop_uv_sample_bounds;
flat in vec2 v_perspective;
flat in ivec2 v_op;
void main ()
{
  vec4 result_1;
  vec4 Cs_2;
  vec4 Cb_3;
  vec4 tmpvar_4;
  tmpvar_4 = texture (sColor0, min (max (v_backdrop_uv, v_backdrop_uv_sample_bounds.xy), v_backdrop_uv_sample_bounds.zw));
  Cb_3 = tmpvar_4;
  vec4 tmpvar_5;
  tmpvar_5 = texture (sColor1, min (max ((v_src_uv * 
    mix (gl_FragCoord.w, 1.0, v_perspective.x)
  ), v_src_uv_sample_bounds.xy), v_src_uv_sample_bounds.zw));
  Cs_2 = tmpvar_5;
  if ((tmpvar_4.w != 0.0)) {
    Cb_3.xyz = (tmpvar_4.xyz / tmpvar_4.w);
  };
  if ((tmpvar_5.w != 0.0)) {
    Cs_2.xyz = (tmpvar_5.xyz / tmpvar_5.w);
  };
  result_1 = vec4(1.0, 1.0, 0.0, 1.0);
  bool tmpvar_6;
  bool tmpvar_7;
  tmpvar_7 = bool(0);
  int tmpvar_8;
  tmpvar_8 = (v_op.x & 255);
  tmpvar_6 = (1 == tmpvar_8);
  if (tmpvar_6) {
    result_1.xyz = (Cb_3.xyz * Cs_2.xyz);
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (3 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    vec3 tmpvar_9;
    tmpvar_9 = ((2.0 * Cb_3.xyz) - 1.0);
    result_1.xyz = mix ((Cs_2.xyz * (2.0 * Cb_3.xyz)), ((Cs_2.xyz + tmpvar_9) - (Cs_2.xyz * tmpvar_9)), vec3(greaterThanEqual (Cb_3.xyz, vec3(0.5, 0.5, 0.5))));
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (4 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    result_1.xyz = min (Cs_2.xyz, Cb_3.xyz);
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (5 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    result_1.xyz = max (Cs_2.xyz, Cb_3.xyz);
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (6 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    float tmpvar_10;
    if ((Cb_3.x == 0.0)) {
      tmpvar_10 = 0.0;
    } else {
      if ((Cs_2.x == 1.0)) {
        tmpvar_10 = 1.0;
      } else {
        tmpvar_10 = min (1.0, (Cb_3.x / (1.0 - Cs_2.x)));
      };
    };
    result_1.x = tmpvar_10;
    float tmpvar_11;
    if ((Cb_3.y == 0.0)) {
      tmpvar_11 = 0.0;
    } else {
      if ((Cs_2.y == 1.0)) {
        tmpvar_11 = 1.0;
      } else {
        tmpvar_11 = min (1.0, (Cb_3.y / (1.0 - Cs_2.y)));
      };
    };
    result_1.y = tmpvar_11;
    float tmpvar_12;
    if ((Cb_3.z == 0.0)) {
      tmpvar_12 = 0.0;
    } else {
      if ((Cs_2.z == 1.0)) {
        tmpvar_12 = 1.0;
      } else {
        tmpvar_12 = min (1.0, (Cb_3.z / (1.0 - Cs_2.z)));
      };
    };
    result_1.z = tmpvar_12;
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (7 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    float tmpvar_13;
    if ((Cb_3.x == 1.0)) {
      tmpvar_13 = 1.0;
    } else {
      if ((Cs_2.x == 0.0)) {
        tmpvar_13 = 0.0;
      } else {
        tmpvar_13 = (1.0 - min (1.0, (
          (1.0 - Cb_3.x)
         / Cs_2.x)));
      };
    };
    result_1.x = tmpvar_13;
    float tmpvar_14;
    if ((Cb_3.y == 1.0)) {
      tmpvar_14 = 1.0;
    } else {
      if ((Cs_2.y == 0.0)) {
        tmpvar_14 = 0.0;
      } else {
        tmpvar_14 = (1.0 - min (1.0, (
          (1.0 - Cb_3.y)
         / Cs_2.y)));
      };
    };
    result_1.y = tmpvar_14;
    float tmpvar_15;
    if ((Cb_3.z == 1.0)) {
      tmpvar_15 = 1.0;
    } else {
      if ((Cs_2.z == 0.0)) {
        tmpvar_15 = 0.0;
      } else {
        tmpvar_15 = (1.0 - min (1.0, (
          (1.0 - Cb_3.z)
         / Cs_2.z)));
      };
    };
    result_1.z = tmpvar_15;
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (8 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    vec3 tmpvar_16;
    tmpvar_16 = ((2.0 * Cs_2.xyz) - 1.0);
    result_1.xyz = mix ((Cb_3.xyz * (2.0 * Cs_2.xyz)), ((Cb_3.xyz + tmpvar_16) - (Cb_3.xyz * tmpvar_16)), vec3(greaterThanEqual (Cs_2.xyz, vec3(0.5, 0.5, 0.5))));
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (9 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    float tmpvar_17;
    if ((0.5 >= Cs_2.x)) {
      tmpvar_17 = (Cb_3.x - ((
        (1.0 - (2.0 * Cs_2.x))
       * Cb_3.x) * (1.0 - Cb_3.x)));
    } else {
      float D_18;
      if ((0.25 >= Cb_3.x)) {
        D_18 = (((
          ((16.0 * Cb_3.x) - 12.0)
         * Cb_3.x) + 4.0) * Cb_3.x);
      } else {
        D_18 = sqrt(Cb_3.x);
      };
      tmpvar_17 = (Cb_3.x + ((
        (2.0 * Cs_2.x)
       - 1.0) * (D_18 - Cb_3.x)));
    };
    result_1.x = tmpvar_17;
    float tmpvar_19;
    if ((0.5 >= Cs_2.y)) {
      tmpvar_19 = (Cb_3.y - ((
        (1.0 - (2.0 * Cs_2.y))
       * Cb_3.y) * (1.0 - Cb_3.y)));
    } else {
      float D_20;
      if ((0.25 >= Cb_3.y)) {
        D_20 = (((
          ((16.0 * Cb_3.y) - 12.0)
         * Cb_3.y) + 4.0) * Cb_3.y);
      } else {
        D_20 = sqrt(Cb_3.y);
      };
      tmpvar_19 = (Cb_3.y + ((
        (2.0 * Cs_2.y)
       - 1.0) * (D_20 - Cb_3.y)));
    };
    result_1.y = tmpvar_19;
    float tmpvar_21;
    if ((0.5 >= Cs_2.z)) {
      tmpvar_21 = (Cb_3.z - ((
        (1.0 - (2.0 * Cs_2.z))
       * Cb_3.z) * (1.0 - Cb_3.z)));
    } else {
      float D_22;
      if ((0.25 >= Cb_3.z)) {
        D_22 = (((
          ((16.0 * Cb_3.z) - 12.0)
         * Cb_3.z) + 4.0) * Cb_3.z);
      } else {
        D_22 = sqrt(Cb_3.z);
      };
      tmpvar_21 = (Cb_3.z + ((
        (2.0 * Cs_2.z)
       - 1.0) * (D_22 - Cb_3.z)));
    };
    result_1.z = tmpvar_21;
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (10 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    result_1.xyz = abs((Cb_3.xyz - Cs_2.xyz));
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (12 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    vec3 tmpvar_23;
    tmpvar_23 = Cs_2.xyz;
    float tmpvar_24;
    tmpvar_24 = (max (Cb_3.x, max (Cb_3.y, Cb_3.z)) - min (Cb_3.x, min (Cb_3.y, Cb_3.z)));
    vec3 tmpvar_25;
    tmpvar_25 = tmpvar_23;
    if ((Cs_2.y >= Cs_2.x)) {
      if ((Cs_2.z >= Cs_2.y)) {
        float tmpvar_26;
        tmpvar_26 = tmpvar_23.x;
        float tmpvar_27;
        tmpvar_27 = tmpvar_23.y;
        float tmpvar_28;
        tmpvar_28 = tmpvar_23.z;
        float tmpvar_29;
        tmpvar_29 = tmpvar_26;
        float tmpvar_30;
        tmpvar_30 = tmpvar_27;
        float tmpvar_31;
        tmpvar_31 = tmpvar_28;
        if ((Cs_2.x < Cs_2.z)) {
          tmpvar_30 = (((Cs_2.y - Cs_2.x) * tmpvar_24) / (Cs_2.z - Cs_2.x));
          tmpvar_31 = tmpvar_24;
        } else {
          tmpvar_30 = 0.0;
          tmpvar_31 = 0.0;
        };
        tmpvar_29 = 0.0;
        tmpvar_26 = tmpvar_29;
        tmpvar_27 = tmpvar_30;
        tmpvar_28 = tmpvar_31;
        tmpvar_25.x = 0.0;
        tmpvar_25.y = tmpvar_30;
        tmpvar_25.z = tmpvar_31;
      } else {
        if ((Cs_2.z >= Cs_2.x)) {
          float tmpvar_32;
          tmpvar_32 = tmpvar_23.x;
          float tmpvar_33;
          tmpvar_33 = tmpvar_23.z;
          float tmpvar_34;
          tmpvar_34 = tmpvar_23.y;
          float tmpvar_35;
          tmpvar_35 = tmpvar_32;
          float tmpvar_36;
          tmpvar_36 = tmpvar_33;
          float tmpvar_37;
          tmpvar_37 = tmpvar_34;
          if ((Cs_2.x < Cs_2.y)) {
            tmpvar_36 = (((Cs_2.z - Cs_2.x) * tmpvar_24) / (Cs_2.y - Cs_2.x));
            tmpvar_37 = tmpvar_24;
          } else {
            tmpvar_36 = 0.0;
            tmpvar_37 = 0.0;
          };
          tmpvar_35 = 0.0;
          tmpvar_32 = tmpvar_35;
          tmpvar_33 = tmpvar_36;
          tmpvar_34 = tmpvar_37;
          tmpvar_25.x = 0.0;
          tmpvar_25.z = tmpvar_36;
          tmpvar_25.y = tmpvar_37;
        } else {
          float tmpvar_38;
          tmpvar_38 = tmpvar_23.z;
          float tmpvar_39;
          tmpvar_39 = tmpvar_23.x;
          float tmpvar_40;
          tmpvar_40 = tmpvar_23.y;
          float tmpvar_41;
          tmpvar_41 = tmpvar_38;
          float tmpvar_42;
          tmpvar_42 = tmpvar_39;
          float tmpvar_43;
          tmpvar_43 = tmpvar_40;
          if ((Cs_2.z < Cs_2.y)) {
            tmpvar_42 = (((Cs_2.x - Cs_2.z) * tmpvar_24) / (Cs_2.y - Cs_2.z));
            tmpvar_43 = tmpvar_24;
          } else {
            tmpvar_42 = 0.0;
            tmpvar_43 = 0.0;
          };
          tmpvar_41 = 0.0;
          tmpvar_38 = tmpvar_41;
          tmpvar_39 = tmpvar_42;
          tmpvar_40 = tmpvar_43;
          tmpvar_25.z = 0.0;
          tmpvar_25.x = tmpvar_42;
          tmpvar_25.y = tmpvar_43;
        };
      };
    } else {
      if ((Cs_2.z >= Cs_2.x)) {
        float tmpvar_44;
        tmpvar_44 = tmpvar_23.y;
        float tmpvar_45;
        tmpvar_45 = tmpvar_23.x;
        float tmpvar_46;
        tmpvar_46 = tmpvar_23.z;
        float tmpvar_47;
        tmpvar_47 = tmpvar_44;
        float tmpvar_48;
        tmpvar_48 = tmpvar_45;
        float tmpvar_49;
        tmpvar_49 = tmpvar_46;
        if ((Cs_2.y < Cs_2.z)) {
          tmpvar_48 = (((Cs_2.x - Cs_2.y) * tmpvar_24) / (Cs_2.z - Cs_2.y));
          tmpvar_49 = tmpvar_24;
        } else {
          tmpvar_48 = 0.0;
          tmpvar_49 = 0.0;
        };
        tmpvar_47 = 0.0;
        tmpvar_44 = tmpvar_47;
        tmpvar_45 = tmpvar_48;
        tmpvar_46 = tmpvar_49;
        tmpvar_25.y = 0.0;
        tmpvar_25.x = tmpvar_48;
        tmpvar_25.z = tmpvar_49;
      } else {
        if ((Cs_2.z >= Cs_2.y)) {
          float tmpvar_50;
          tmpvar_50 = tmpvar_23.y;
          float tmpvar_51;
          tmpvar_51 = tmpvar_23.z;
          float tmpvar_52;
          tmpvar_52 = tmpvar_23.x;
          float tmpvar_53;
          tmpvar_53 = tmpvar_50;
          float tmpvar_54;
          tmpvar_54 = tmpvar_51;
          float tmpvar_55;
          tmpvar_55 = tmpvar_52;
          if ((Cs_2.y < Cs_2.x)) {
            tmpvar_54 = (((Cs_2.z - Cs_2.y) * tmpvar_24) / (Cs_2.x - Cs_2.y));
            tmpvar_55 = tmpvar_24;
          } else {
            tmpvar_54 = 0.0;
            tmpvar_55 = 0.0;
          };
          tmpvar_53 = 0.0;
          tmpvar_50 = tmpvar_53;
          tmpvar_51 = tmpvar_54;
          tmpvar_52 = tmpvar_55;
          tmpvar_25.y = 0.0;
          tmpvar_25.z = tmpvar_54;
          tmpvar_25.x = tmpvar_55;
        } else {
          float tmpvar_56;
          tmpvar_56 = tmpvar_23.z;
          float tmpvar_57;
          tmpvar_57 = tmpvar_23.y;
          float tmpvar_58;
          tmpvar_58 = tmpvar_23.x;
          float tmpvar_59;
          tmpvar_59 = tmpvar_56;
          float tmpvar_60;
          tmpvar_60 = tmpvar_57;
          float tmpvar_61;
          tmpvar_61 = tmpvar_58;
          if ((Cs_2.z < Cs_2.x)) {
            tmpvar_60 = (((Cs_2.y - Cs_2.z) * tmpvar_24) / (Cs_2.x - Cs_2.z));
            tmpvar_61 = tmpvar_24;
          } else {
            tmpvar_60 = 0.0;
            tmpvar_61 = 0.0;
          };
          tmpvar_59 = 0.0;
          tmpvar_56 = tmpvar_59;
          tmpvar_57 = tmpvar_60;
          tmpvar_58 = tmpvar_61;
          tmpvar_25.z = 0.0;
          tmpvar_25.y = tmpvar_60;
          tmpvar_25.x = tmpvar_61;
        };
      };
    };
    vec3 tmpvar_62;
    tmpvar_62 = (tmpvar_25 + (dot (Cb_3.xyz, vec3(0.3, 0.59, 0.11)) - dot (tmpvar_25, vec3(0.3, 0.59, 0.11))));
    float tmpvar_63;
    tmpvar_63 = dot (tmpvar_62, vec3(0.3, 0.59, 0.11));
    float tmpvar_64;
    tmpvar_64 = min (tmpvar_62.x, min (tmpvar_62.y, tmpvar_62.z));
    float tmpvar_65;
    tmpvar_65 = max (tmpvar_62.x, max (tmpvar_62.y, tmpvar_62.z));
    if ((tmpvar_64 < 0.0)) {
      tmpvar_62 = (tmpvar_63 + ((
        (tmpvar_62 - tmpvar_63)
       * tmpvar_63) / (tmpvar_63 - tmpvar_64)));
    };
    if ((1.0 < tmpvar_65)) {
      tmpvar_62 = (tmpvar_63 + ((
        (tmpvar_62 - tmpvar_63)
       * 
        (1.0 - tmpvar_63)
      ) / (tmpvar_65 - tmpvar_63)));
    };
    result_1.xyz = tmpvar_62;
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (13 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    vec3 tmpvar_66;
    tmpvar_66 = Cb_3.xyz;
    float tmpvar_67;
    tmpvar_67 = (max (Cs_2.x, max (Cs_2.y, Cs_2.z)) - min (Cs_2.x, min (Cs_2.y, Cs_2.z)));
    vec3 tmpvar_68;
    tmpvar_68 = tmpvar_66;
    if ((Cb_3.y >= Cb_3.x)) {
      if ((Cb_3.z >= Cb_3.y)) {
        float tmpvar_69;
        tmpvar_69 = tmpvar_66.x;
        float tmpvar_70;
        tmpvar_70 = tmpvar_66.y;
        float tmpvar_71;
        tmpvar_71 = tmpvar_66.z;
        float tmpvar_72;
        tmpvar_72 = tmpvar_69;
        float tmpvar_73;
        tmpvar_73 = tmpvar_70;
        float tmpvar_74;
        tmpvar_74 = tmpvar_71;
        if ((Cb_3.x < Cb_3.z)) {
          tmpvar_73 = (((Cb_3.y - Cb_3.x) * tmpvar_67) / (Cb_3.z - Cb_3.x));
          tmpvar_74 = tmpvar_67;
        } else {
          tmpvar_73 = 0.0;
          tmpvar_74 = 0.0;
        };
        tmpvar_72 = 0.0;
        tmpvar_69 = tmpvar_72;
        tmpvar_70 = tmpvar_73;
        tmpvar_71 = tmpvar_74;
        tmpvar_68.x = 0.0;
        tmpvar_68.y = tmpvar_73;
        tmpvar_68.z = tmpvar_74;
      } else {
        if ((Cb_3.z >= Cb_3.x)) {
          float tmpvar_75;
          tmpvar_75 = tmpvar_66.x;
          float tmpvar_76;
          tmpvar_76 = tmpvar_66.z;
          float tmpvar_77;
          tmpvar_77 = tmpvar_66.y;
          float tmpvar_78;
          tmpvar_78 = tmpvar_75;
          float tmpvar_79;
          tmpvar_79 = tmpvar_76;
          float tmpvar_80;
          tmpvar_80 = tmpvar_77;
          if ((Cb_3.x < Cb_3.y)) {
            tmpvar_79 = (((Cb_3.z - Cb_3.x) * tmpvar_67) / (Cb_3.y - Cb_3.x));
            tmpvar_80 = tmpvar_67;
          } else {
            tmpvar_79 = 0.0;
            tmpvar_80 = 0.0;
          };
          tmpvar_78 = 0.0;
          tmpvar_75 = tmpvar_78;
          tmpvar_76 = tmpvar_79;
          tmpvar_77 = tmpvar_80;
          tmpvar_68.x = 0.0;
          tmpvar_68.z = tmpvar_79;
          tmpvar_68.y = tmpvar_80;
        } else {
          float tmpvar_81;
          tmpvar_81 = tmpvar_66.z;
          float tmpvar_82;
          tmpvar_82 = tmpvar_66.x;
          float tmpvar_83;
          tmpvar_83 = tmpvar_66.y;
          float tmpvar_84;
          tmpvar_84 = tmpvar_81;
          float tmpvar_85;
          tmpvar_85 = tmpvar_82;
          float tmpvar_86;
          tmpvar_86 = tmpvar_83;
          if ((Cb_3.z < Cb_3.y)) {
            tmpvar_85 = (((Cb_3.x - Cb_3.z) * tmpvar_67) / (Cb_3.y - Cb_3.z));
            tmpvar_86 = tmpvar_67;
          } else {
            tmpvar_85 = 0.0;
            tmpvar_86 = 0.0;
          };
          tmpvar_84 = 0.0;
          tmpvar_81 = tmpvar_84;
          tmpvar_82 = tmpvar_85;
          tmpvar_83 = tmpvar_86;
          tmpvar_68.z = 0.0;
          tmpvar_68.x = tmpvar_85;
          tmpvar_68.y = tmpvar_86;
        };
      };
    } else {
      if ((Cb_3.z >= Cb_3.x)) {
        float tmpvar_87;
        tmpvar_87 = tmpvar_66.y;
        float tmpvar_88;
        tmpvar_88 = tmpvar_66.x;
        float tmpvar_89;
        tmpvar_89 = tmpvar_66.z;
        float tmpvar_90;
        tmpvar_90 = tmpvar_87;
        float tmpvar_91;
        tmpvar_91 = tmpvar_88;
        float tmpvar_92;
        tmpvar_92 = tmpvar_89;
        if ((Cb_3.y < Cb_3.z)) {
          tmpvar_91 = (((Cb_3.x - Cb_3.y) * tmpvar_67) / (Cb_3.z - Cb_3.y));
          tmpvar_92 = tmpvar_67;
        } else {
          tmpvar_91 = 0.0;
          tmpvar_92 = 0.0;
        };
        tmpvar_90 = 0.0;
        tmpvar_87 = tmpvar_90;
        tmpvar_88 = tmpvar_91;
        tmpvar_89 = tmpvar_92;
        tmpvar_68.y = 0.0;
        tmpvar_68.x = tmpvar_91;
        tmpvar_68.z = tmpvar_92;
      } else {
        if ((Cb_3.z >= Cb_3.y)) {
          float tmpvar_93;
          tmpvar_93 = tmpvar_66.y;
          float tmpvar_94;
          tmpvar_94 = tmpvar_66.z;
          float tmpvar_95;
          tmpvar_95 = tmpvar_66.x;
          float tmpvar_96;
          tmpvar_96 = tmpvar_93;
          float tmpvar_97;
          tmpvar_97 = tmpvar_94;
          float tmpvar_98;
          tmpvar_98 = tmpvar_95;
          if ((Cb_3.y < Cb_3.x)) {
            tmpvar_97 = (((Cb_3.z - Cb_3.y) * tmpvar_67) / (Cb_3.x - Cb_3.y));
            tmpvar_98 = tmpvar_67;
          } else {
            tmpvar_97 = 0.0;
            tmpvar_98 = 0.0;
          };
          tmpvar_96 = 0.0;
          tmpvar_93 = tmpvar_96;
          tmpvar_94 = tmpvar_97;
          tmpvar_95 = tmpvar_98;
          tmpvar_68.y = 0.0;
          tmpvar_68.z = tmpvar_97;
          tmpvar_68.x = tmpvar_98;
        } else {
          float tmpvar_99;
          tmpvar_99 = tmpvar_66.z;
          float tmpvar_100;
          tmpvar_100 = tmpvar_66.y;
          float tmpvar_101;
          tmpvar_101 = tmpvar_66.x;
          float tmpvar_102;
          tmpvar_102 = tmpvar_99;
          float tmpvar_103;
          tmpvar_103 = tmpvar_100;
          float tmpvar_104;
          tmpvar_104 = tmpvar_101;
          if ((Cb_3.z < Cb_3.x)) {
            tmpvar_103 = (((Cb_3.y - Cb_3.z) * tmpvar_67) / (Cb_3.x - Cb_3.z));
            tmpvar_104 = tmpvar_67;
          } else {
            tmpvar_103 = 0.0;
            tmpvar_104 = 0.0;
          };
          tmpvar_102 = 0.0;
          tmpvar_99 = tmpvar_102;
          tmpvar_100 = tmpvar_103;
          tmpvar_101 = tmpvar_104;
          tmpvar_68.z = 0.0;
          tmpvar_68.y = tmpvar_103;
          tmpvar_68.x = tmpvar_104;
        };
      };
    };
    vec3 tmpvar_105;
    tmpvar_105 = (tmpvar_68 + (dot (Cb_3.xyz, vec3(0.3, 0.59, 0.11)) - dot (tmpvar_68, vec3(0.3, 0.59, 0.11))));
    float tmpvar_106;
    tmpvar_106 = dot (tmpvar_105, vec3(0.3, 0.59, 0.11));
    float tmpvar_107;
    tmpvar_107 = min (tmpvar_105.x, min (tmpvar_105.y, tmpvar_105.z));
    float tmpvar_108;
    tmpvar_108 = max (tmpvar_105.x, max (tmpvar_105.y, tmpvar_105.z));
    if ((tmpvar_107 < 0.0)) {
      tmpvar_105 = (tmpvar_106 + ((
        (tmpvar_105 - tmpvar_106)
       * tmpvar_106) / (tmpvar_106 - tmpvar_107)));
    };
    if ((1.0 < tmpvar_108)) {
      tmpvar_105 = (tmpvar_106 + ((
        (tmpvar_105 - tmpvar_106)
       * 
        (1.0 - tmpvar_106)
      ) / (tmpvar_108 - tmpvar_106)));
    };
    result_1.xyz = tmpvar_105;
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (14 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    vec3 tmpvar_109;
    tmpvar_109 = (Cs_2.xyz + (dot (Cb_3.xyz, vec3(0.3, 0.59, 0.11)) - dot (Cs_2.xyz, vec3(0.3, 0.59, 0.11))));
    float tmpvar_110;
    tmpvar_110 = dot (tmpvar_109, vec3(0.3, 0.59, 0.11));
    float tmpvar_111;
    tmpvar_111 = min (tmpvar_109.x, min (tmpvar_109.y, tmpvar_109.z));
    float tmpvar_112;
    tmpvar_112 = max (tmpvar_109.x, max (tmpvar_109.y, tmpvar_109.z));
    if ((tmpvar_111 < 0.0)) {
      tmpvar_109 = (tmpvar_110 + ((
        (tmpvar_109 - tmpvar_110)
       * tmpvar_110) / (tmpvar_110 - tmpvar_111)));
    };
    if ((1.0 < tmpvar_112)) {
      tmpvar_109 = (tmpvar_110 + ((
        (tmpvar_109 - tmpvar_110)
       * 
        (1.0 - tmpvar_110)
      ) / (tmpvar_112 - tmpvar_110)));
    };
    result_1.xyz = tmpvar_109;
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (15 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    vec3 tmpvar_113;
    tmpvar_113 = (Cb_3.xyz + (dot (Cs_2.xyz, vec3(0.3, 0.59, 0.11)) - dot (Cb_3.xyz, vec3(0.3, 0.59, 0.11))));
    float tmpvar_114;
    tmpvar_114 = dot (tmpvar_113, vec3(0.3, 0.59, 0.11));
    float tmpvar_115;
    tmpvar_115 = min (tmpvar_113.x, min (tmpvar_113.y, tmpvar_113.z));
    float tmpvar_116;
    tmpvar_116 = max (tmpvar_113.x, max (tmpvar_113.y, tmpvar_113.z));
    if ((tmpvar_115 < 0.0)) {
      tmpvar_113 = (tmpvar_114 + ((
        (tmpvar_113 - tmpvar_114)
       * tmpvar_114) / (tmpvar_114 - tmpvar_115)));
    };
    if ((1.0 < tmpvar_116)) {
      tmpvar_113 = (tmpvar_114 + ((
        (tmpvar_113 - tmpvar_114)
       * 
        (1.0 - tmpvar_114)
      ) / (tmpvar_116 - tmpvar_114)));
    };
    result_1.xyz = tmpvar_113;
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = (tmpvar_6 || (2 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 || (11 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 || (16 == tmpvar_8));
  tmpvar_6 = (tmpvar_6 && !(tmpvar_7));
  if (tmpvar_6) {
    tmpvar_7 = bool(1);
  };
  tmpvar_6 = !(tmpvar_7);
  if (tmpvar_6) {
    tmpvar_7 = bool(1);
  };
  result_1.xyz = (((1.0 - tmpvar_4.w) * Cs_2.xyz) + (tmpvar_4.w * result_1.xyz));
  result_1.w = Cs_2.w;
  result_1.xyz = (result_1.xyz * tmpvar_5.w);
  oFragColor = result_1;
}

brush_mix_blend_ALPHA_PASS#version 150
// brush_mix_blend
// features: ["ALPHA_PASS"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_src_uv;
flat out vec4 v_src_uv_sample_bounds;
out vec2 v_backdrop_uv;
flat out vec4 v_backdrop_uv_sample_bounds;
flat out vec2 v_perspective;
flat out ivec2 v_op;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  vec2 tmpvar_11;
  vec2 tmpvar_12;
  tmpvar_11 = tmpvar_8.xy;
  tmpvar_12 = tmpvar_8.zw;
  ivec2 tmpvar_13;
  tmpvar_13.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_13.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(0, 0));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_14.x);
  mat4 transform_m_16;
  bool transform_is_axis_aligned_17;
  transform_is_axis_aligned_17 = ((tmpvar_14.z >> 24) == 0);
  int tmpvar_18;
  tmpvar_18 = (tmpvar_14.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_16[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_16[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_16[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_16[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  ivec2 tmpvar_20;
  tmpvar_20.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_20.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_21;
  tmpvar_21 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(0, 0));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_23;
  float area_device_pixel_scale_24;
  vec2 area_screen_origin_25;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_23 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_24 = 0.0;
    area_screen_origin_25 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_26;
    tmpvar_26.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_26.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_27;
    tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
    area_task_rect_23.p0 = tmpvar_27.xy;
    area_task_rect_23.p1 = tmpvar_27.zw;
    area_device_pixel_scale_24 = tmpvar_28.x;
    area_screen_origin_25 = tmpvar_28.yz;
  };
  vec2 tmpvar_29;
  vec2 tmpvar_30;
  tmpvar_29 = tmpvar_11;
  tmpvar_30 = tmpvar_12;
  vec2 adjusted_segment_rect_p0_31;
  vec2 adjusted_segment_rect_p1_32;
  vec2 segment_rect_p0_33;
  vec2 segment_rect_p1_34;
  int tmpvar_35;
  tmpvar_35 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_36;
  tmpvar_36 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_33 = tmpvar_9;
    segment_rect_p1_34 = tmpvar_10;
  } else {
    int tmpvar_37;
    tmpvar_37 = ((tmpvar_14.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_38;
    tmpvar_38.x = int((uint(tmpvar_37) % 1024u));
    tmpvar_38.y = int((uint(tmpvar_37) / 1024u));
    vec4 tmpvar_39;
    tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_38, 0, ivec2(0, 0));
    segment_rect_p0_33 = (tmpvar_39.xy + tmpvar_7.xy);
    segment_rect_p1_34 = (tmpvar_39.zw + tmpvar_7.xy);
  };
  adjusted_segment_rect_p0_31 = segment_rect_p0_33;
  adjusted_segment_rect_p1_32 = segment_rect_p1_34;
  if ((!(transform_is_axis_aligned_17) || ((tmpvar_36 & 256) != 0))) {
    vec2 tmpvar_40;
    tmpvar_40 = min (max (segment_rect_p0_33, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_41;
    tmpvar_41 = min (max (segment_rect_p1_34, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_42;
    tmpvar_42.x = bool((tmpvar_35 & 1));
    tmpvar_42.y = bool((tmpvar_35 & 2));
    tmpvar_42.z = bool((tmpvar_35 & 4));
    tmpvar_42.w = bool((tmpvar_35 & 8));
    vec4 tmpvar_43;
    tmpvar_43.xy = tmpvar_40;
    tmpvar_43.zw = tmpvar_41;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_43, bvec4(tmpvar_42));
    vec4 tmpvar_44;
    tmpvar_44 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_42));
    adjusted_segment_rect_p0_31 = (tmpvar_40 - tmpvar_44.xy);
    adjusted_segment_rect_p1_32 = (tmpvar_41 + tmpvar_44.zw);
    tmpvar_29 = vec2(-1e+16, -1e+16);
    tmpvar_30 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_45;
  tmpvar_45 = min (max (mix (adjusted_segment_rect_p0_31, adjusted_segment_rect_p1_32, aPosition), tmpvar_29), tmpvar_30);
  vec4 tmpvar_46;
  tmpvar_46.zw = vec2(0.0, 1.0);
  tmpvar_46.xy = tmpvar_45;
  vec4 tmpvar_47;
  tmpvar_47 = (transform_m_16 * tmpvar_46);
  vec4 tmpvar_48;
  tmpvar_48.xy = ((tmpvar_47.xy * tmpvar_22.x) + ((
    -(tmpvar_22.yz)
   + tmpvar_21.xy) * tmpvar_47.w));
  tmpvar_48.z = (ph_z_5 * tmpvar_47.w);
  tmpvar_48.w = tmpvar_47.w;
  gl_Position = (uTransform * tmpvar_48);
  vec4 tmpvar_49;
  tmpvar_49.xy = area_task_rect_23.p0;
  tmpvar_49.zw = area_task_rect_23.p1;
  vClipMaskUvBounds = tmpvar_49;
  vClipMaskUv = ((tmpvar_47.xy * area_device_pixel_scale_24) + (tmpvar_47.w * (area_task_rect_23.p0 - area_screen_origin_25)));
  vec2 tmpvar_50;
  tmpvar_50 = ((tmpvar_45 - tmpvar_7.xy) / (tmpvar_7.zw - tmpvar_7.xy));
  float tmpvar_51;
  if (((tmpvar_36 & 1) != 0)) {
    tmpvar_51 = 1.0;
  } else {
    tmpvar_51 = 0.0;
  };
  v_perspective.x = tmpvar_51;
  v_op.x = tmpvar_15.x;
  vec2 inv_texture_size_52;
  ivec2 tmpvar_53;
  tmpvar_53.x = int((uint(tmpvar_15.y) % 1024u));
  tmpvar_53.y = int((uint(tmpvar_15.y) / 1024u));
  vec4 tmpvar_54;
  tmpvar_54 = texelFetchOffset (sGpuCache, tmpvar_53, 0, ivec2(0, 0));
  inv_texture_size_52 = (1.0/(vec2(textureSize (sColor0, 0))));
  int tmpvar_55;
  tmpvar_55 = (tmpvar_15.y + 2);
  ivec2 tmpvar_56;
  tmpvar_56.x = int((uint(tmpvar_55) % 1024u));
  tmpvar_56.y = int((uint(tmpvar_55) / 1024u));
  vec4 tmpvar_57;
  tmpvar_57 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_56, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_56, 0, ivec2(1, 0)), tmpvar_50.x), mix (texelFetchOffset (sGpuCache, tmpvar_56, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_56, 0, ivec2(3, 0)), tmpvar_50.x), tmpvar_50.y);
  vec4 tmpvar_58;
  tmpvar_58.xy = (tmpvar_54.xy + vec2(0.5, 0.5));
  tmpvar_58.zw = (tmpvar_54.zw - vec2(0.5, 0.5));
  v_backdrop_uv = (mix (tmpvar_54.xy, tmpvar_54.zw, (tmpvar_57.xy / tmpvar_57.w)) * inv_texture_size_52);
  v_backdrop_uv_sample_bounds = (tmpvar_58 * inv_texture_size_52.xyxy);
  vec2 inv_texture_size_59;
  ivec2 tmpvar_60;
  tmpvar_60.x = int((uint(tmpvar_15.z) % 1024u));
  tmpvar_60.y = int((uint(tmpvar_15.z) / 1024u));
  vec4 tmpvar_61;
  tmpvar_61 = texelFetchOffset (sGpuCache, tmpvar_60, 0, ivec2(0, 0));
  inv_texture_size_59 = (1.0/(vec2(textureSize (sColor1, 0))));
  int tmpvar_62;
  tmpvar_62 = (tmpvar_15.z + 2);
  ivec2 tmpvar_63;
  tmpvar_63.x = int((uint(tmpvar_62) % 1024u));
  tmpvar_63.y = int((uint(tmpvar_62) / 1024u));
  vec4 tmpvar_64;
  tmpvar_64 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_63, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_63, 0, ivec2(1, 0)), tmpvar_50.x), mix (texelFetchOffset (sGpuCache, tmpvar_63, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_63, 0, ivec2(3, 0)), tmpvar_50.x), tmpvar_50.y);
  vec4 tmpvar_65;
  tmpvar_65.xy = (tmpvar_61.xy + vec2(0.5, 0.5));
  tmpvar_65.zw = (tmpvar_61.zw - vec2(0.5, 0.5));
  v_src_uv = ((mix (tmpvar_61.xy, tmpvar_61.zw, 
    (tmpvar_64.xy / tmpvar_64.w)
  ) * inv_texture_size_59) * mix (tmpvar_47.w, 1.0, tmpvar_51));
  v_src_uv_sample_bounds = (tmpvar_65 * inv_texture_size_59.xyxy);
  v_local_pos = tmpvar_45;
}

#version 150
// brush_mix_blend
// features: ["ALPHA_PASS"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_src_uv;
flat in vec4 v_src_uv_sample_bounds;
in vec2 v_backdrop_uv;
flat in vec4 v_backdrop_uv_sample_bounds;
flat in vec2 v_perspective;
flat in ivec2 v_op;
void main ()
{
  vec4 frag_color_1;
  vec4 result_2;
  vec4 Cs_3;
  vec4 Cb_4;
  vec4 tmpvar_5;
  tmpvar_5 = texture (sColor0, min (max (v_backdrop_uv, v_backdrop_uv_sample_bounds.xy), v_backdrop_uv_sample_bounds.zw));
  Cb_4 = tmpvar_5;
  vec4 tmpvar_6;
  tmpvar_6 = texture (sColor1, min (max ((v_src_uv * 
    mix (gl_FragCoord.w, 1.0, v_perspective.x)
  ), v_src_uv_sample_bounds.xy), v_src_uv_sample_bounds.zw));
  Cs_3 = tmpvar_6;
  if ((tmpvar_5.w != 0.0)) {
    Cb_4.xyz = (tmpvar_5.xyz / tmpvar_5.w);
  };
  if ((tmpvar_6.w != 0.0)) {
    Cs_3.xyz = (tmpvar_6.xyz / tmpvar_6.w);
  };
  result_2 = vec4(1.0, 1.0, 0.0, 1.0);
  bool tmpvar_7;
  bool tmpvar_8;
  tmpvar_8 = bool(0);
  int tmpvar_9;
  tmpvar_9 = (v_op.x & 255);
  tmpvar_7 = (1 == tmpvar_9);
  if (tmpvar_7) {
    result_2.xyz = (Cb_4.xyz * Cs_3.xyz);
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (3 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    vec3 tmpvar_10;
    tmpvar_10 = ((2.0 * Cb_4.xyz) - 1.0);
    result_2.xyz = mix ((Cs_3.xyz * (2.0 * Cb_4.xyz)), ((Cs_3.xyz + tmpvar_10) - (Cs_3.xyz * tmpvar_10)), vec3(greaterThanEqual (Cb_4.xyz, vec3(0.5, 0.5, 0.5))));
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (4 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    result_2.xyz = min (Cs_3.xyz, Cb_4.xyz);
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (5 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    result_2.xyz = max (Cs_3.xyz, Cb_4.xyz);
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (6 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    float tmpvar_11;
    if ((Cb_4.x == 0.0)) {
      tmpvar_11 = 0.0;
    } else {
      if ((Cs_3.x == 1.0)) {
        tmpvar_11 = 1.0;
      } else {
        tmpvar_11 = min (1.0, (Cb_4.x / (1.0 - Cs_3.x)));
      };
    };
    result_2.x = tmpvar_11;
    float tmpvar_12;
    if ((Cb_4.y == 0.0)) {
      tmpvar_12 = 0.0;
    } else {
      if ((Cs_3.y == 1.0)) {
        tmpvar_12 = 1.0;
      } else {
        tmpvar_12 = min (1.0, (Cb_4.y / (1.0 - Cs_3.y)));
      };
    };
    result_2.y = tmpvar_12;
    float tmpvar_13;
    if ((Cb_4.z == 0.0)) {
      tmpvar_13 = 0.0;
    } else {
      if ((Cs_3.z == 1.0)) {
        tmpvar_13 = 1.0;
      } else {
        tmpvar_13 = min (1.0, (Cb_4.z / (1.0 - Cs_3.z)));
      };
    };
    result_2.z = tmpvar_13;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (7 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    float tmpvar_14;
    if ((Cb_4.x == 1.0)) {
      tmpvar_14 = 1.0;
    } else {
      if ((Cs_3.x == 0.0)) {
        tmpvar_14 = 0.0;
      } else {
        tmpvar_14 = (1.0 - min (1.0, (
          (1.0 - Cb_4.x)
         / Cs_3.x)));
      };
    };
    result_2.x = tmpvar_14;
    float tmpvar_15;
    if ((Cb_4.y == 1.0)) {
      tmpvar_15 = 1.0;
    } else {
      if ((Cs_3.y == 0.0)) {
        tmpvar_15 = 0.0;
      } else {
        tmpvar_15 = (1.0 - min (1.0, (
          (1.0 - Cb_4.y)
         / Cs_3.y)));
      };
    };
    result_2.y = tmpvar_15;
    float tmpvar_16;
    if ((Cb_4.z == 1.0)) {
      tmpvar_16 = 1.0;
    } else {
      if ((Cs_3.z == 0.0)) {
        tmpvar_16 = 0.0;
      } else {
        tmpvar_16 = (1.0 - min (1.0, (
          (1.0 - Cb_4.z)
         / Cs_3.z)));
      };
    };
    result_2.z = tmpvar_16;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (8 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    vec3 tmpvar_17;
    tmpvar_17 = ((2.0 * Cs_3.xyz) - 1.0);
    result_2.xyz = mix ((Cb_4.xyz * (2.0 * Cs_3.xyz)), ((Cb_4.xyz + tmpvar_17) - (Cb_4.xyz * tmpvar_17)), vec3(greaterThanEqual (Cs_3.xyz, vec3(0.5, 0.5, 0.5))));
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (9 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    float tmpvar_18;
    if ((0.5 >= Cs_3.x)) {
      tmpvar_18 = (Cb_4.x - ((
        (1.0 - (2.0 * Cs_3.x))
       * Cb_4.x) * (1.0 - Cb_4.x)));
    } else {
      float D_19;
      if ((0.25 >= Cb_4.x)) {
        D_19 = (((
          ((16.0 * Cb_4.x) - 12.0)
         * Cb_4.x) + 4.0) * Cb_4.x);
      } else {
        D_19 = sqrt(Cb_4.x);
      };
      tmpvar_18 = (Cb_4.x + ((
        (2.0 * Cs_3.x)
       - 1.0) * (D_19 - Cb_4.x)));
    };
    result_2.x = tmpvar_18;
    float tmpvar_20;
    if ((0.5 >= Cs_3.y)) {
      tmpvar_20 = (Cb_4.y - ((
        (1.0 - (2.0 * Cs_3.y))
       * Cb_4.y) * (1.0 - Cb_4.y)));
    } else {
      float D_21;
      if ((0.25 >= Cb_4.y)) {
        D_21 = (((
          ((16.0 * Cb_4.y) - 12.0)
         * Cb_4.y) + 4.0) * Cb_4.y);
      } else {
        D_21 = sqrt(Cb_4.y);
      };
      tmpvar_20 = (Cb_4.y + ((
        (2.0 * Cs_3.y)
       - 1.0) * (D_21 - Cb_4.y)));
    };
    result_2.y = tmpvar_20;
    float tmpvar_22;
    if ((0.5 >= Cs_3.z)) {
      tmpvar_22 = (Cb_4.z - ((
        (1.0 - (2.0 * Cs_3.z))
       * Cb_4.z) * (1.0 - Cb_4.z)));
    } else {
      float D_23;
      if ((0.25 >= Cb_4.z)) {
        D_23 = (((
          ((16.0 * Cb_4.z) - 12.0)
         * Cb_4.z) + 4.0) * Cb_4.z);
      } else {
        D_23 = sqrt(Cb_4.z);
      };
      tmpvar_22 = (Cb_4.z + ((
        (2.0 * Cs_3.z)
       - 1.0) * (D_23 - Cb_4.z)));
    };
    result_2.z = tmpvar_22;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (10 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    result_2.xyz = abs((Cb_4.xyz - Cs_3.xyz));
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (12 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    vec3 tmpvar_24;
    tmpvar_24 = Cs_3.xyz;
    float tmpvar_25;
    tmpvar_25 = (max (Cb_4.x, max (Cb_4.y, Cb_4.z)) - min (Cb_4.x, min (Cb_4.y, Cb_4.z)));
    vec3 tmpvar_26;
    tmpvar_26 = tmpvar_24;
    if ((Cs_3.y >= Cs_3.x)) {
      if ((Cs_3.z >= Cs_3.y)) {
        float tmpvar_27;
        tmpvar_27 = tmpvar_24.x;
        float tmpvar_28;
        tmpvar_28 = tmpvar_24.y;
        float tmpvar_29;
        tmpvar_29 = tmpvar_24.z;
        float tmpvar_30;
        tmpvar_30 = tmpvar_27;
        float tmpvar_31;
        tmpvar_31 = tmpvar_28;
        float tmpvar_32;
        tmpvar_32 = tmpvar_29;
        if ((Cs_3.x < Cs_3.z)) {
          tmpvar_31 = (((Cs_3.y - Cs_3.x) * tmpvar_25) / (Cs_3.z - Cs_3.x));
          tmpvar_32 = tmpvar_25;
        } else {
          tmpvar_31 = 0.0;
          tmpvar_32 = 0.0;
        };
        tmpvar_30 = 0.0;
        tmpvar_27 = tmpvar_30;
        tmpvar_28 = tmpvar_31;
        tmpvar_29 = tmpvar_32;
        tmpvar_26.x = 0.0;
        tmpvar_26.y = tmpvar_31;
        tmpvar_26.z = tmpvar_32;
      } else {
        if ((Cs_3.z >= Cs_3.x)) {
          float tmpvar_33;
          tmpvar_33 = tmpvar_24.x;
          float tmpvar_34;
          tmpvar_34 = tmpvar_24.z;
          float tmpvar_35;
          tmpvar_35 = tmpvar_24.y;
          float tmpvar_36;
          tmpvar_36 = tmpvar_33;
          float tmpvar_37;
          tmpvar_37 = tmpvar_34;
          float tmpvar_38;
          tmpvar_38 = tmpvar_35;
          if ((Cs_3.x < Cs_3.y)) {
            tmpvar_37 = (((Cs_3.z - Cs_3.x) * tmpvar_25) / (Cs_3.y - Cs_3.x));
            tmpvar_38 = tmpvar_25;
          } else {
            tmpvar_37 = 0.0;
            tmpvar_38 = 0.0;
          };
          tmpvar_36 = 0.0;
          tmpvar_33 = tmpvar_36;
          tmpvar_34 = tmpvar_37;
          tmpvar_35 = tmpvar_38;
          tmpvar_26.x = 0.0;
          tmpvar_26.z = tmpvar_37;
          tmpvar_26.y = tmpvar_38;
        } else {
          float tmpvar_39;
          tmpvar_39 = tmpvar_24.z;
          float tmpvar_40;
          tmpvar_40 = tmpvar_24.x;
          float tmpvar_41;
          tmpvar_41 = tmpvar_24.y;
          float tmpvar_42;
          tmpvar_42 = tmpvar_39;
          float tmpvar_43;
          tmpvar_43 = tmpvar_40;
          float tmpvar_44;
          tmpvar_44 = tmpvar_41;
          if ((Cs_3.z < Cs_3.y)) {
            tmpvar_43 = (((Cs_3.x - Cs_3.z) * tmpvar_25) / (Cs_3.y - Cs_3.z));
            tmpvar_44 = tmpvar_25;
          } else {
            tmpvar_43 = 0.0;
            tmpvar_44 = 0.0;
          };
          tmpvar_42 = 0.0;
          tmpvar_39 = tmpvar_42;
          tmpvar_40 = tmpvar_43;
          tmpvar_41 = tmpvar_44;
          tmpvar_26.z = 0.0;
          tmpvar_26.x = tmpvar_43;
          tmpvar_26.y = tmpvar_44;
        };
      };
    } else {
      if ((Cs_3.z >= Cs_3.x)) {
        float tmpvar_45;
        tmpvar_45 = tmpvar_24.y;
        float tmpvar_46;
        tmpvar_46 = tmpvar_24.x;
        float tmpvar_47;
        tmpvar_47 = tmpvar_24.z;
        float tmpvar_48;
        tmpvar_48 = tmpvar_45;
        float tmpvar_49;
        tmpvar_49 = tmpvar_46;
        float tmpvar_50;
        tmpvar_50 = tmpvar_47;
        if ((Cs_3.y < Cs_3.z)) {
          tmpvar_49 = (((Cs_3.x - Cs_3.y) * tmpvar_25) / (Cs_3.z - Cs_3.y));
          tmpvar_50 = tmpvar_25;
        } else {
          tmpvar_49 = 0.0;
          tmpvar_50 = 0.0;
        };
        tmpvar_48 = 0.0;
        tmpvar_45 = tmpvar_48;
        tmpvar_46 = tmpvar_49;
        tmpvar_47 = tmpvar_50;
        tmpvar_26.y = 0.0;
        tmpvar_26.x = tmpvar_49;
        tmpvar_26.z = tmpvar_50;
      } else {
        if ((Cs_3.z >= Cs_3.y)) {
          float tmpvar_51;
          tmpvar_51 = tmpvar_24.y;
          float tmpvar_52;
          tmpvar_52 = tmpvar_24.z;
          float tmpvar_53;
          tmpvar_53 = tmpvar_24.x;
          float tmpvar_54;
          tmpvar_54 = tmpvar_51;
          float tmpvar_55;
          tmpvar_55 = tmpvar_52;
          float tmpvar_56;
          tmpvar_56 = tmpvar_53;
          if ((Cs_3.y < Cs_3.x)) {
            tmpvar_55 = (((Cs_3.z - Cs_3.y) * tmpvar_25) / (Cs_3.x - Cs_3.y));
            tmpvar_56 = tmpvar_25;
          } else {
            tmpvar_55 = 0.0;
            tmpvar_56 = 0.0;
          };
          tmpvar_54 = 0.0;
          tmpvar_51 = tmpvar_54;
          tmpvar_52 = tmpvar_55;
          tmpvar_53 = tmpvar_56;
          tmpvar_26.y = 0.0;
          tmpvar_26.z = tmpvar_55;
          tmpvar_26.x = tmpvar_56;
        } else {
          float tmpvar_57;
          tmpvar_57 = tmpvar_24.z;
          float tmpvar_58;
          tmpvar_58 = tmpvar_24.y;
          float tmpvar_59;
          tmpvar_59 = tmpvar_24.x;
          float tmpvar_60;
          tmpvar_60 = tmpvar_57;
          float tmpvar_61;
          tmpvar_61 = tmpvar_58;
          float tmpvar_62;
          tmpvar_62 = tmpvar_59;
          if ((Cs_3.z < Cs_3.x)) {
            tmpvar_61 = (((Cs_3.y - Cs_3.z) * tmpvar_25) / (Cs_3.x - Cs_3.z));
            tmpvar_62 = tmpvar_25;
          } else {
            tmpvar_61 = 0.0;
            tmpvar_62 = 0.0;
          };
          tmpvar_60 = 0.0;
          tmpvar_57 = tmpvar_60;
          tmpvar_58 = tmpvar_61;
          tmpvar_59 = tmpvar_62;
          tmpvar_26.z = 0.0;
          tmpvar_26.y = tmpvar_61;
          tmpvar_26.x = tmpvar_62;
        };
      };
    };
    vec3 tmpvar_63;
    tmpvar_63 = (tmpvar_26 + (dot (Cb_4.xyz, vec3(0.3, 0.59, 0.11)) - dot (tmpvar_26, vec3(0.3, 0.59, 0.11))));
    float tmpvar_64;
    tmpvar_64 = dot (tmpvar_63, vec3(0.3, 0.59, 0.11));
    float tmpvar_65;
    tmpvar_65 = min (tmpvar_63.x, min (tmpvar_63.y, tmpvar_63.z));
    float tmpvar_66;
    tmpvar_66 = max (tmpvar_63.x, max (tmpvar_63.y, tmpvar_63.z));
    if ((tmpvar_65 < 0.0)) {
      tmpvar_63 = (tmpvar_64 + ((
        (tmpvar_63 - tmpvar_64)
       * tmpvar_64) / (tmpvar_64 - tmpvar_65)));
    };
    if ((1.0 < tmpvar_66)) {
      tmpvar_63 = (tmpvar_64 + ((
        (tmpvar_63 - tmpvar_64)
       * 
        (1.0 - tmpvar_64)
      ) / (tmpvar_66 - tmpvar_64)));
    };
    result_2.xyz = tmpvar_63;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (13 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    vec3 tmpvar_67;
    tmpvar_67 = Cb_4.xyz;
    float tmpvar_68;
    tmpvar_68 = (max (Cs_3.x, max (Cs_3.y, Cs_3.z)) - min (Cs_3.x, min (Cs_3.y, Cs_3.z)));
    vec3 tmpvar_69;
    tmpvar_69 = tmpvar_67;
    if ((Cb_4.y >= Cb_4.x)) {
      if ((Cb_4.z >= Cb_4.y)) {
        float tmpvar_70;
        tmpvar_70 = tmpvar_67.x;
        float tmpvar_71;
        tmpvar_71 = tmpvar_67.y;
        float tmpvar_72;
        tmpvar_72 = tmpvar_67.z;
        float tmpvar_73;
        tmpvar_73 = tmpvar_70;
        float tmpvar_74;
        tmpvar_74 = tmpvar_71;
        float tmpvar_75;
        tmpvar_75 = tmpvar_72;
        if ((Cb_4.x < Cb_4.z)) {
          tmpvar_74 = (((Cb_4.y - Cb_4.x) * tmpvar_68) / (Cb_4.z - Cb_4.x));
          tmpvar_75 = tmpvar_68;
        } else {
          tmpvar_74 = 0.0;
          tmpvar_75 = 0.0;
        };
        tmpvar_73 = 0.0;
        tmpvar_70 = tmpvar_73;
        tmpvar_71 = tmpvar_74;
        tmpvar_72 = tmpvar_75;
        tmpvar_69.x = 0.0;
        tmpvar_69.y = tmpvar_74;
        tmpvar_69.z = tmpvar_75;
      } else {
        if ((Cb_4.z >= Cb_4.x)) {
          float tmpvar_76;
          tmpvar_76 = tmpvar_67.x;
          float tmpvar_77;
          tmpvar_77 = tmpvar_67.z;
          float tmpvar_78;
          tmpvar_78 = tmpvar_67.y;
          float tmpvar_79;
          tmpvar_79 = tmpvar_76;
          float tmpvar_80;
          tmpvar_80 = tmpvar_77;
          float tmpvar_81;
          tmpvar_81 = tmpvar_78;
          if ((Cb_4.x < Cb_4.y)) {
            tmpvar_80 = (((Cb_4.z - Cb_4.x) * tmpvar_68) / (Cb_4.y - Cb_4.x));
            tmpvar_81 = tmpvar_68;
          } else {
            tmpvar_80 = 0.0;
            tmpvar_81 = 0.0;
          };
          tmpvar_79 = 0.0;
          tmpvar_76 = tmpvar_79;
          tmpvar_77 = tmpvar_80;
          tmpvar_78 = tmpvar_81;
          tmpvar_69.x = 0.0;
          tmpvar_69.z = tmpvar_80;
          tmpvar_69.y = tmpvar_81;
        } else {
          float tmpvar_82;
          tmpvar_82 = tmpvar_67.z;
          float tmpvar_83;
          tmpvar_83 = tmpvar_67.x;
          float tmpvar_84;
          tmpvar_84 = tmpvar_67.y;
          float tmpvar_85;
          tmpvar_85 = tmpvar_82;
          float tmpvar_86;
          tmpvar_86 = tmpvar_83;
          float tmpvar_87;
          tmpvar_87 = tmpvar_84;
          if ((Cb_4.z < Cb_4.y)) {
            tmpvar_86 = (((Cb_4.x - Cb_4.z) * tmpvar_68) / (Cb_4.y - Cb_4.z));
            tmpvar_87 = tmpvar_68;
          } else {
            tmpvar_86 = 0.0;
            tmpvar_87 = 0.0;
          };
          tmpvar_85 = 0.0;
          tmpvar_82 = tmpvar_85;
          tmpvar_83 = tmpvar_86;
          tmpvar_84 = tmpvar_87;
          tmpvar_69.z = 0.0;
          tmpvar_69.x = tmpvar_86;
          tmpvar_69.y = tmpvar_87;
        };
      };
    } else {
      if ((Cb_4.z >= Cb_4.x)) {
        float tmpvar_88;
        tmpvar_88 = tmpvar_67.y;
        float tmpvar_89;
        tmpvar_89 = tmpvar_67.x;
        float tmpvar_90;
        tmpvar_90 = tmpvar_67.z;
        float tmpvar_91;
        tmpvar_91 = tmpvar_88;
        float tmpvar_92;
        tmpvar_92 = tmpvar_89;
        float tmpvar_93;
        tmpvar_93 = tmpvar_90;
        if ((Cb_4.y < Cb_4.z)) {
          tmpvar_92 = (((Cb_4.x - Cb_4.y) * tmpvar_68) / (Cb_4.z - Cb_4.y));
          tmpvar_93 = tmpvar_68;
        } else {
          tmpvar_92 = 0.0;
          tmpvar_93 = 0.0;
        };
        tmpvar_91 = 0.0;
        tmpvar_88 = tmpvar_91;
        tmpvar_89 = tmpvar_92;
        tmpvar_90 = tmpvar_93;
        tmpvar_69.y = 0.0;
        tmpvar_69.x = tmpvar_92;
        tmpvar_69.z = tmpvar_93;
      } else {
        if ((Cb_4.z >= Cb_4.y)) {
          float tmpvar_94;
          tmpvar_94 = tmpvar_67.y;
          float tmpvar_95;
          tmpvar_95 = tmpvar_67.z;
          float tmpvar_96;
          tmpvar_96 = tmpvar_67.x;
          float tmpvar_97;
          tmpvar_97 = tmpvar_94;
          float tmpvar_98;
          tmpvar_98 = tmpvar_95;
          float tmpvar_99;
          tmpvar_99 = tmpvar_96;
          if ((Cb_4.y < Cb_4.x)) {
            tmpvar_98 = (((Cb_4.z - Cb_4.y) * tmpvar_68) / (Cb_4.x - Cb_4.y));
            tmpvar_99 = tmpvar_68;
          } else {
            tmpvar_98 = 0.0;
            tmpvar_99 = 0.0;
          };
          tmpvar_97 = 0.0;
          tmpvar_94 = tmpvar_97;
          tmpvar_95 = tmpvar_98;
          tmpvar_96 = tmpvar_99;
          tmpvar_69.y = 0.0;
          tmpvar_69.z = tmpvar_98;
          tmpvar_69.x = tmpvar_99;
        } else {
          float tmpvar_100;
          tmpvar_100 = tmpvar_67.z;
          float tmpvar_101;
          tmpvar_101 = tmpvar_67.y;
          float tmpvar_102;
          tmpvar_102 = tmpvar_67.x;
          float tmpvar_103;
          tmpvar_103 = tmpvar_100;
          float tmpvar_104;
          tmpvar_104 = tmpvar_101;
          float tmpvar_105;
          tmpvar_105 = tmpvar_102;
          if ((Cb_4.z < Cb_4.x)) {
            tmpvar_104 = (((Cb_4.y - Cb_4.z) * tmpvar_68) / (Cb_4.x - Cb_4.z));
            tmpvar_105 = tmpvar_68;
          } else {
            tmpvar_104 = 0.0;
            tmpvar_105 = 0.0;
          };
          tmpvar_103 = 0.0;
          tmpvar_100 = tmpvar_103;
          tmpvar_101 = tmpvar_104;
          tmpvar_102 = tmpvar_105;
          tmpvar_69.z = 0.0;
          tmpvar_69.y = tmpvar_104;
          tmpvar_69.x = tmpvar_105;
        };
      };
    };
    vec3 tmpvar_106;
    tmpvar_106 = (tmpvar_69 + (dot (Cb_4.xyz, vec3(0.3, 0.59, 0.11)) - dot (tmpvar_69, vec3(0.3, 0.59, 0.11))));
    float tmpvar_107;
    tmpvar_107 = dot (tmpvar_106, vec3(0.3, 0.59, 0.11));
    float tmpvar_108;
    tmpvar_108 = min (tmpvar_106.x, min (tmpvar_106.y, tmpvar_106.z));
    float tmpvar_109;
    tmpvar_109 = max (tmpvar_106.x, max (tmpvar_106.y, tmpvar_106.z));
    if ((tmpvar_108 < 0.0)) {
      tmpvar_106 = (tmpvar_107 + ((
        (tmpvar_106 - tmpvar_107)
       * tmpvar_107) / (tmpvar_107 - tmpvar_108)));
    };
    if ((1.0 < tmpvar_109)) {
      tmpvar_106 = (tmpvar_107 + ((
        (tmpvar_106 - tmpvar_107)
       * 
        (1.0 - tmpvar_107)
      ) / (tmpvar_109 - tmpvar_107)));
    };
    result_2.xyz = tmpvar_106;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (14 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    vec3 tmpvar_110;
    tmpvar_110 = (Cs_3.xyz + (dot (Cb_4.xyz, vec3(0.3, 0.59, 0.11)) - dot (Cs_3.xyz, vec3(0.3, 0.59, 0.11))));
    float tmpvar_111;
    tmpvar_111 = dot (tmpvar_110, vec3(0.3, 0.59, 0.11));
    float tmpvar_112;
    tmpvar_112 = min (tmpvar_110.x, min (tmpvar_110.y, tmpvar_110.z));
    float tmpvar_113;
    tmpvar_113 = max (tmpvar_110.x, max (tmpvar_110.y, tmpvar_110.z));
    if ((tmpvar_112 < 0.0)) {
      tmpvar_110 = (tmpvar_111 + ((
        (tmpvar_110 - tmpvar_111)
       * tmpvar_111) / (tmpvar_111 - tmpvar_112)));
    };
    if ((1.0 < tmpvar_113)) {
      tmpvar_110 = (tmpvar_111 + ((
        (tmpvar_110 - tmpvar_111)
       * 
        (1.0 - tmpvar_111)
      ) / (tmpvar_113 - tmpvar_111)));
    };
    result_2.xyz = tmpvar_110;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (15 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    vec3 tmpvar_114;
    tmpvar_114 = (Cb_4.xyz + (dot (Cs_3.xyz, vec3(0.3, 0.59, 0.11)) - dot (Cb_4.xyz, vec3(0.3, 0.59, 0.11))));
    float tmpvar_115;
    tmpvar_115 = dot (tmpvar_114, vec3(0.3, 0.59, 0.11));
    float tmpvar_116;
    tmpvar_116 = min (tmpvar_114.x, min (tmpvar_114.y, tmpvar_114.z));
    float tmpvar_117;
    tmpvar_117 = max (tmpvar_114.x, max (tmpvar_114.y, tmpvar_114.z));
    if ((tmpvar_116 < 0.0)) {
      tmpvar_114 = (tmpvar_115 + ((
        (tmpvar_114 - tmpvar_115)
       * tmpvar_115) / (tmpvar_115 - tmpvar_116)));
    };
    if ((1.0 < tmpvar_117)) {
      tmpvar_114 = (tmpvar_115 + ((
        (tmpvar_114 - tmpvar_115)
       * 
        (1.0 - tmpvar_115)
      ) / (tmpvar_117 - tmpvar_115)));
    };
    result_2.xyz = tmpvar_114;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (2 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 || (11 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 || (16 == tmpvar_9));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = !(tmpvar_8);
  if (tmpvar_7) {
    tmpvar_8 = bool(1);
  };
  result_2.xyz = (((1.0 - tmpvar_5.w) * Cs_3.xyz) + (tmpvar_5.w * result_2.xyz));
  result_2.w = Cs_3.w;
  result_2.xyz = (result_2.xyz * tmpvar_6.w);
  frag_color_1 = result_2;
  float tmpvar_118;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_118 = 1.0;
  } else {
    vec2 tmpvar_119;
    tmpvar_119 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_120;
    tmpvar_120.xy = greaterThanEqual (tmpvar_119, vClipMaskUvBounds.xy);
    tmpvar_120.zw = lessThan (tmpvar_119, vClipMaskUvBounds.zw);
    bool tmpvar_121;
    tmpvar_121 = (tmpvar_120 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_121)) {
      tmpvar_118 = 0.0;
    } else {
      tmpvar_118 = texelFetch (sClipMask, ivec2(tmpvar_119), 0).x;
    };
  };
  frag_color_1 = (result_2 * tmpvar_118);
  oFragColor = frag_color_1;
}

brush_mix_blend_DEBUG_OVERDRAW#version 150
// brush_mix_blend
// features: ["DEBUG_OVERDRAW"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_src_uv;
flat out vec4 v_src_uv_sample_bounds;
out vec2 v_backdrop_uv;
flat out vec4 v_backdrop_uv_sample_bounds;
flat out vec2 v_perspective;
flat out ivec2 v_op;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  vec2 tmpvar_40;
  tmpvar_40 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  float tmpvar_41;
  if (((tmpvar_27 & 1) != 0)) {
    tmpvar_41 = 1.0;
  } else {
    tmpvar_41 = 0.0;
  };
  v_perspective.x = tmpvar_41;
  v_op.x = tmpvar_12.x;
  vec2 inv_texture_size_42;
  ivec2 tmpvar_43;
  tmpvar_43.x = int((uint(tmpvar_12.y) % 1024u));
  tmpvar_43.y = int((uint(tmpvar_12.y) / 1024u));
  vec4 tmpvar_44;
  tmpvar_44 = texelFetchOffset (sGpuCache, tmpvar_43, 0, ivec2(0, 0));
  inv_texture_size_42 = (1.0/(vec2(textureSize (sColor0, 0))));
  int tmpvar_45;
  tmpvar_45 = (tmpvar_12.y + 2);
  ivec2 tmpvar_46;
  tmpvar_46.x = int((uint(tmpvar_45) % 1024u));
  tmpvar_46.y = int((uint(tmpvar_45) / 1024u));
  vec4 tmpvar_47;
  tmpvar_47 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_46, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_46, 0, ivec2(1, 0)), tmpvar_40.x), mix (texelFetchOffset (sGpuCache, tmpvar_46, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_46, 0, ivec2(3, 0)), tmpvar_40.x), tmpvar_40.y);
  vec4 tmpvar_48;
  tmpvar_48.xy = (tmpvar_44.xy + vec2(0.5, 0.5));
  tmpvar_48.zw = (tmpvar_44.zw - vec2(0.5, 0.5));
  v_backdrop_uv = (mix (tmpvar_44.xy, tmpvar_44.zw, (tmpvar_47.xy / tmpvar_47.w)) * inv_texture_size_42);
  v_backdrop_uv_sample_bounds = (tmpvar_48 * inv_texture_size_42.xyxy);
  vec2 inv_texture_size_49;
  ivec2 tmpvar_50;
  tmpvar_50.x = int((uint(tmpvar_12.z) % 1024u));
  tmpvar_50.y = int((uint(tmpvar_12.z) / 1024u));
  vec4 tmpvar_51;
  tmpvar_51 = texelFetchOffset (sGpuCache, tmpvar_50, 0, ivec2(0, 0));
  inv_texture_size_49 = (1.0/(vec2(textureSize (sColor1, 0))));
  int tmpvar_52;
  tmpvar_52 = (tmpvar_12.z + 2);
  ivec2 tmpvar_53;
  tmpvar_53.x = int((uint(tmpvar_52) % 1024u));
  tmpvar_53.y = int((uint(tmpvar_52) / 1024u));
  vec4 tmpvar_54;
  tmpvar_54 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_53, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_53, 0, ivec2(1, 0)), tmpvar_40.x), mix (texelFetchOffset (sGpuCache, tmpvar_53, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_53, 0, ivec2(3, 0)), tmpvar_40.x), tmpvar_40.y);
  vec4 tmpvar_55;
  tmpvar_55.xy = (tmpvar_51.xy + vec2(0.5, 0.5));
  tmpvar_55.zw = (tmpvar_51.zw - vec2(0.5, 0.5));
  v_src_uv = ((mix (tmpvar_51.xy, tmpvar_51.zw, 
    (tmpvar_54.xy / tmpvar_54.w)
  ) * inv_texture_size_49) * mix (tmpvar_38.w, 1.0, tmpvar_41));
  v_src_uv_sample_bounds = (tmpvar_55 * inv_texture_size_49.xyxy);
}

#version 150
// brush_mix_blend
// features: ["DEBUG_OVERDRAW"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

#version 150
// brush_opacity
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_uv;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_opacity_perspective_vec;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  ivec2 tmpvar_40;
  tmpvar_40.x = int((uint(tmpvar_12.x) % 1024u));
  tmpvar_40.y = int((uint(tmpvar_12.x) / 1024u));
  vec4 tmpvar_41;
  tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
  vec2 tmpvar_42;
  tmpvar_42 = vec2(textureSize (sColor0, 0));
  vec2 tmpvar_43;
  tmpvar_43 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  int tmpvar_44;
  tmpvar_44 = (tmpvar_12.x + 2);
  ivec2 tmpvar_45;
  tmpvar_45.x = int((uint(tmpvar_44) % 1024u));
  tmpvar_45.y = int((uint(tmpvar_44) / 1024u));
  vec4 tmpvar_46;
  tmpvar_46 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(1, 0)), tmpvar_43.x), mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(3, 0)), tmpvar_43.x), tmpvar_43.y);
  vec2 tmpvar_47;
  tmpvar_47 = mix (tmpvar_41.xy, tmpvar_41.zw, (tmpvar_46.xy / tmpvar_46.w));
  float tmpvar_48;
  if (((tmpvar_27 & 1) != 0)) {
    tmpvar_48 = 1.0;
  } else {
    tmpvar_48 = 0.0;
  };
  v_uv = ((tmpvar_47 / tmpvar_42) * mix (tmpvar_38.w, 1.0, tmpvar_48));
  v_opacity_perspective_vec.y = tmpvar_48;
  vec4 tmpvar_49;
  tmpvar_49.xy = (tmpvar_41.xy + vec2(0.5, 0.5));
  tmpvar_49.zw = (tmpvar_41.zw - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_49 / tmpvar_42.xyxy);
  v_opacity_perspective_vec.x = min (max ((
    float(tmpvar_12.y)
   / 65536.0), 0.0), 1.0);
}

#version 150
// brush_opacity
// features: []

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
in vec2 v_uv;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_opacity_perspective_vec;
void main ()
{
  oFragColor = (v_opacity_perspective_vec.x * texture (sColor0, min (max (
    (v_uv * mix (gl_FragCoord.w, 1.0, v_opacity_perspective_vec.y))
  , v_uv_sample_bounds.xy), v_uv_sample_bounds.zw)));
}

brush_opacity_ALPHA_PASS#version 150
// brush_opacity
// features: ["ALPHA_PASS"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_opacity_perspective_vec;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  vec2 tmpvar_11;
  vec2 tmpvar_12;
  tmpvar_11 = tmpvar_8.xy;
  tmpvar_12 = tmpvar_8.zw;
  ivec2 tmpvar_13;
  tmpvar_13.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_13.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(0, 0));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_14.x);
  mat4 transform_m_16;
  bool transform_is_axis_aligned_17;
  transform_is_axis_aligned_17 = ((tmpvar_14.z >> 24) == 0);
  int tmpvar_18;
  tmpvar_18 = (tmpvar_14.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_16[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_16[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_16[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_16[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  ivec2 tmpvar_20;
  tmpvar_20.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_20.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_21;
  tmpvar_21 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(0, 0));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_23;
  float area_device_pixel_scale_24;
  vec2 area_screen_origin_25;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_23 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_24 = 0.0;
    area_screen_origin_25 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_26;
    tmpvar_26.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_26.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_27;
    tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
    area_task_rect_23.p0 = tmpvar_27.xy;
    area_task_rect_23.p1 = tmpvar_27.zw;
    area_device_pixel_scale_24 = tmpvar_28.x;
    area_screen_origin_25 = tmpvar_28.yz;
  };
  vec2 tmpvar_29;
  vec2 tmpvar_30;
  tmpvar_29 = tmpvar_11;
  tmpvar_30 = tmpvar_12;
  vec2 adjusted_segment_rect_p0_31;
  vec2 adjusted_segment_rect_p1_32;
  vec2 segment_rect_p0_33;
  vec2 segment_rect_p1_34;
  int tmpvar_35;
  tmpvar_35 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_36;
  tmpvar_36 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_33 = tmpvar_9;
    segment_rect_p1_34 = tmpvar_10;
  } else {
    int tmpvar_37;
    tmpvar_37 = ((tmpvar_14.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_38;
    tmpvar_38.x = int((uint(tmpvar_37) % 1024u));
    tmpvar_38.y = int((uint(tmpvar_37) / 1024u));
    vec4 tmpvar_39;
    tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_38, 0, ivec2(0, 0));
    segment_rect_p0_33 = (tmpvar_39.xy + tmpvar_7.xy);
    segment_rect_p1_34 = (tmpvar_39.zw + tmpvar_7.xy);
  };
  adjusted_segment_rect_p0_31 = segment_rect_p0_33;
  adjusted_segment_rect_p1_32 = segment_rect_p1_34;
  if ((!(transform_is_axis_aligned_17) || ((tmpvar_36 & 256) != 0))) {
    vec2 tmpvar_40;
    tmpvar_40 = min (max (segment_rect_p0_33, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_41;
    tmpvar_41 = min (max (segment_rect_p1_34, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_42;
    tmpvar_42.x = bool((tmpvar_35 & 1));
    tmpvar_42.y = bool((tmpvar_35 & 2));
    tmpvar_42.z = bool((tmpvar_35 & 4));
    tmpvar_42.w = bool((tmpvar_35 & 8));
    vec4 tmpvar_43;
    tmpvar_43.xy = tmpvar_40;
    tmpvar_43.zw = tmpvar_41;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_43, bvec4(tmpvar_42));
    vec4 tmpvar_44;
    tmpvar_44 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_42));
    adjusted_segment_rect_p0_31 = (tmpvar_40 - tmpvar_44.xy);
    adjusted_segment_rect_p1_32 = (tmpvar_41 + tmpvar_44.zw);
    tmpvar_29 = vec2(-1e+16, -1e+16);
    tmpvar_30 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_45;
  tmpvar_45 = min (max (mix (adjusted_segment_rect_p0_31, adjusted_segment_rect_p1_32, aPosition), tmpvar_29), tmpvar_30);
  vec4 tmpvar_46;
  tmpvar_46.zw = vec2(0.0, 1.0);
  tmpvar_46.xy = tmpvar_45;
  vec4 tmpvar_47;
  tmpvar_47 = (transform_m_16 * tmpvar_46);
  vec4 tmpvar_48;
  tmpvar_48.xy = ((tmpvar_47.xy * tmpvar_22.x) + ((
    -(tmpvar_22.yz)
   + tmpvar_21.xy) * tmpvar_47.w));
  tmpvar_48.z = (ph_z_5 * tmpvar_47.w);
  tmpvar_48.w = tmpvar_47.w;
  gl_Position = (uTransform * tmpvar_48);
  vec4 tmpvar_49;
  tmpvar_49.xy = area_task_rect_23.p0;
  tmpvar_49.zw = area_task_rect_23.p1;
  vClipMaskUvBounds = tmpvar_49;
  vClipMaskUv = ((tmpvar_47.xy * area_device_pixel_scale_24) + (tmpvar_47.w * (area_task_rect_23.p0 - area_screen_origin_25)));
  ivec2 tmpvar_50;
  tmpvar_50.x = int((uint(tmpvar_15.x) % 1024u));
  tmpvar_50.y = int((uint(tmpvar_15.x) / 1024u));
  vec4 tmpvar_51;
  tmpvar_51 = texelFetchOffset (sGpuCache, tmpvar_50, 0, ivec2(0, 0));
  vec2 tmpvar_52;
  tmpvar_52 = vec2(textureSize (sColor0, 0));
  vec2 tmpvar_53;
  tmpvar_53 = ((tmpvar_45 - tmpvar_7.xy) / (tmpvar_7.zw - tmpvar_7.xy));
  int tmpvar_54;
  tmpvar_54 = (tmpvar_15.x + 2);
  ivec2 tmpvar_55;
  tmpvar_55.x = int((uint(tmpvar_54) % 1024u));
  tmpvar_55.y = int((uint(tmpvar_54) / 1024u));
  vec4 tmpvar_56;
  tmpvar_56 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(1, 0)), tmpvar_53.x), mix (texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(3, 0)), tmpvar_53.x), tmpvar_53.y);
  vec2 tmpvar_57;
  tmpvar_57 = mix (tmpvar_51.xy, tmpvar_51.zw, (tmpvar_56.xy / tmpvar_56.w));
  float tmpvar_58;
  if (((tmpvar_36 & 1) != 0)) {
    tmpvar_58 = 1.0;
  } else {
    tmpvar_58 = 0.0;
  };
  v_uv = ((tmpvar_57 / tmpvar_52) * mix (tmpvar_47.w, 1.0, tmpvar_58));
  v_opacity_perspective_vec.y = tmpvar_58;
  vec4 tmpvar_59;
  tmpvar_59.xy = (tmpvar_51.xy + vec2(0.5, 0.5));
  tmpvar_59.zw = (tmpvar_51.zw - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_59 / tmpvar_52.xyxy);
  v_opacity_perspective_vec.x = min (max ((
    float(tmpvar_15.y)
   / 65536.0), 0.0), 1.0);
  v_local_pos = tmpvar_45;
}

#version 150
// brush_opacity
// features: ["ALPHA_PASS"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 v_uv;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_opacity_perspective_vec;
void main ()
{
  vec4 frag_color_1;
  vec2 tmpvar_2;
  tmpvar_2 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  frag_color_1 = ((v_opacity_perspective_vec.x * min (
    max ((0.5 - max (tmpvar_2.x, tmpvar_2.y)), 0.0)
  , 1.0)) * texture (sColor0, min (max (
    (v_uv * mix (gl_FragCoord.w, 1.0, v_opacity_perspective_vec.y))
  , v_uv_sample_bounds.xy), v_uv_sample_bounds.zw)));
  float tmpvar_3;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_3 = 1.0;
  } else {
    vec2 tmpvar_4;
    tmpvar_4 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_5;
    tmpvar_5.xy = greaterThanEqual (tmpvar_4, vClipMaskUvBounds.xy);
    tmpvar_5.zw = lessThan (tmpvar_4, vClipMaskUvBounds.zw);
    bool tmpvar_6;
    tmpvar_6 = (tmpvar_5 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_6)) {
      tmpvar_3 = 0.0;
    } else {
      tmpvar_3 = texelFetch (sClipMask, ivec2(tmpvar_4), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_3);
  oFragColor = frag_color_1;
}

178490b1cf64dc9brush_opacity_ALPHA_PASS_ANTIALIASING#version 150
// brush_opacity
// features: ["ALPHA_PASS", "ANTIALIASING"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_opacity_perspective_vec;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  vec2 tmpvar_11;
  vec2 tmpvar_12;
  tmpvar_11 = tmpvar_8.xy;
  tmpvar_12 = tmpvar_8.zw;
  ivec2 tmpvar_13;
  tmpvar_13.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_13.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(0, 0));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_14.x);
  mat4 transform_m_16;
  bool transform_is_axis_aligned_17;
  transform_is_axis_aligned_17 = ((tmpvar_14.z >> 24) == 0);
  int tmpvar_18;
  tmpvar_18 = (tmpvar_14.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_16[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_16[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_16[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_16[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  ivec2 tmpvar_20;
  tmpvar_20.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_20.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_21;
  tmpvar_21 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(0, 0));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_23;
  float area_device_pixel_scale_24;
  vec2 area_screen_origin_25;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_23 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_24 = 0.0;
    area_screen_origin_25 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_26;
    tmpvar_26.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_26.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_27;
    tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
    area_task_rect_23.p0 = tmpvar_27.xy;
    area_task_rect_23.p1 = tmpvar_27.zw;
    area_device_pixel_scale_24 = tmpvar_28.x;
    area_screen_origin_25 = tmpvar_28.yz;
  };
  vec2 tmpvar_29;
  vec2 tmpvar_30;
  tmpvar_29 = tmpvar_11;
  tmpvar_30 = tmpvar_12;
  vec2 adjusted_segment_rect_p0_31;
  vec2 adjusted_segment_rect_p1_32;
  vec2 segment_rect_p0_33;
  vec2 segment_rect_p1_34;
  int tmpvar_35;
  tmpvar_35 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_36;
  tmpvar_36 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_33 = tmpvar_9;
    segment_rect_p1_34 = tmpvar_10;
  } else {
    int tmpvar_37;
    tmpvar_37 = ((tmpvar_14.y + 3) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_38;
    tmpvar_38.x = int((uint(tmpvar_37) % 1024u));
    tmpvar_38.y = int((uint(tmpvar_37) / 1024u));
    vec4 tmpvar_39;
    tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_38, 0, ivec2(0, 0));
    segment_rect_p0_33 = (tmpvar_39.xy + tmpvar_7.xy);
    segment_rect_p1_34 = (tmpvar_39.zw + tmpvar_7.xy);
  };
  adjusted_segment_rect_p0_31 = segment_rect_p0_33;
  adjusted_segment_rect_p1_32 = segment_rect_p1_34;
  if ((!(transform_is_axis_aligned_17) || ((tmpvar_36 & 256) != 0))) {
    vec2 tmpvar_40;
    tmpvar_40 = min (max (segment_rect_p0_33, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_41;
    tmpvar_41 = min (max (segment_rect_p1_34, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_42;
    tmpvar_42.x = bool((tmpvar_35 & 1));
    tmpvar_42.y = bool((tmpvar_35 & 2));
    tmpvar_42.z = bool((tmpvar_35 & 4));
    tmpvar_42.w = bool((tmpvar_35 & 8));
    vec4 tmpvar_43;
    tmpvar_43.xy = tmpvar_40;
    tmpvar_43.zw = tmpvar_41;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_43, bvec4(tmpvar_42));
    vec4 tmpvar_44;
    tmpvar_44 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_42));
    adjusted_segment_rect_p0_31 = (tmpvar_40 - tmpvar_44.xy);
    adjusted_segment_rect_p1_32 = (tmpvar_41 + tmpvar_44.zw);
    tmpvar_29 = vec2(-1e+16, -1e+16);
    tmpvar_30 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_45;
  tmpvar_45 = min (max (mix (adjusted_segment_rect_p0_31, adjusted_segment_rect_p1_32, aPosition), tmpvar_29), tmpvar_30);
  vec4 tmpvar_46;
  tmpvar_46.zw = vec2(0.0, 1.0);
  tmpvar_46.xy = tmpvar_45;
  vec4 tmpvar_47;
  tmpvar_47 = (transform_m_16 * tmpvar_46);
  vec4 tmpvar_48;
  tmpvar_48.xy = ((tmpvar_47.xy * tmpvar_22.x) + ((
    -(tmpvar_22.yz)
   + tmpvar_21.xy) * tmpvar_47.w));
  tmpvar_48.z = (ph_z_5 * tmpvar_47.w);
  tmpvar_48.w = tmpvar_47.w;
  gl_Position = (uTransform * tmpvar_48);
  vec4 tmpvar_49;
  tmpvar_49.xy = area_task_rect_23.p0;
  tmpvar_49.zw = area_task_rect_23.p1;
  vClipMaskUvBounds = tmpvar_49;
  vClipMaskUv = ((tmpvar_47.xy * area_device_pixel_scale_24) + (tmpvar_47.w * (area_task_rect_23.p0 - area_screen_origin_25)));
  ivec2 tmpvar_50;
  tmpvar_50.x = int((uint(tmpvar_15.x) % 1024u));
  tmpvar_50.y = int((uint(tmpvar_15.x) / 1024u));
  vec4 tmpvar_51;
  tmpvar_51 = texelFetchOffset (sGpuCache, tmpvar_50, 0, ivec2(0, 0));
  vec2 tmpvar_52;
  tmpvar_52 = vec2(textureSize (sColor0, 0));
  vec2 tmpvar_53;
  tmpvar_53 = ((tmpvar_45 - tmpvar_7.xy) / (tmpvar_7.zw - tmpvar_7.xy));
  int tmpvar_54;
  tmpvar_54 = (tmpvar_15.x + 2);
  ivec2 tmpvar_55;
  tmpvar_55.x = int((uint(tmpvar_54) % 1024u));
  tmpvar_55.y = int((uint(tmpvar_54) / 1024u));
  vec4 tmpvar_56;
  tmpvar_56 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(1, 0)), tmpvar_53.x), mix (texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_55, 0, ivec2(3, 0)), tmpvar_53.x), tmpvar_53.y);
  vec2 tmpvar_57;
  tmpvar_57 = mix (tmpvar_51.xy, tmpvar_51.zw, (tmpvar_56.xy / tmpvar_56.w));
  float tmpvar_58;
  if (((tmpvar_36 & 1) != 0)) {
    tmpvar_58 = 1.0;
  } else {
    tmpvar_58 = 0.0;
  };
  v_uv = ((tmpvar_57 / tmpvar_52) * mix (tmpvar_47.w, 1.0, tmpvar_58));
  v_opacity_perspective_vec.y = tmpvar_58;
  vec4 tmpvar_59;
  tmpvar_59.xy = (tmpvar_51.xy + vec2(0.5, 0.5));
  tmpvar_59.zw = (tmpvar_51.zw - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_59 / tmpvar_52.xyxy);
  v_opacity_perspective_vec.x = min (max ((
    float(tmpvar_15.y)
   / 65536.0), 0.0), 1.0);
  v_local_pos = tmpvar_45;
}

#version 150
// brush_opacity
// features: ["ALPHA_PASS", "ANTIALIASING"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 v_uv;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_opacity_perspective_vec;
void main ()
{
  vec4 frag_color_1;
  vec2 tmpvar_2;
  tmpvar_2 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  frag_color_1 = ((v_opacity_perspective_vec.x * min (
    max ((0.5 - max (tmpvar_2.x, tmpvar_2.y)), 0.0)
  , 1.0)) * texture (sColor0, min (max (
    (v_uv * mix (gl_FragCoord.w, 1.0, v_opacity_perspective_vec.y))
  , v_uv_sample_bounds.xy), v_uv_sample_bounds.zw)));
  float tmpvar_3;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_3 = 1.0;
  } else {
    vec2 tmpvar_4;
    tmpvar_4 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_5;
    tmpvar_5.xy = greaterThanEqual (tmpvar_4, vClipMaskUvBounds.xy);
    tmpvar_5.zw = lessThan (tmpvar_4, vClipMaskUvBounds.zw);
    bool tmpvar_6;
    tmpvar_6 = (tmpvar_5 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_6)) {
      tmpvar_3 = 0.0;
    } else {
      tmpvar_3 = texelFetch (sClipMask, ivec2(tmpvar_4), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_3);
  oFragColor = frag_color_1;
}

brush_opacity_ANTIALIASING#version 150
// brush_opacity
// features: ["ANTIALIASING"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_opacity_perspective_vec;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  ivec2 tmpvar_40;
  tmpvar_40.x = int((uint(tmpvar_12.x) % 1024u));
  tmpvar_40.y = int((uint(tmpvar_12.x) / 1024u));
  vec4 tmpvar_41;
  tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
  vec2 tmpvar_42;
  tmpvar_42 = vec2(textureSize (sColor0, 0));
  vec2 tmpvar_43;
  tmpvar_43 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  int tmpvar_44;
  tmpvar_44 = (tmpvar_12.x + 2);
  ivec2 tmpvar_45;
  tmpvar_45.x = int((uint(tmpvar_44) % 1024u));
  tmpvar_45.y = int((uint(tmpvar_44) / 1024u));
  vec4 tmpvar_46;
  tmpvar_46 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(1, 0)), tmpvar_43.x), mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(3, 0)), tmpvar_43.x), tmpvar_43.y);
  vec2 tmpvar_47;
  tmpvar_47 = mix (tmpvar_41.xy, tmpvar_41.zw, (tmpvar_46.xy / tmpvar_46.w));
  float tmpvar_48;
  if (((tmpvar_27 & 1) != 0)) {
    tmpvar_48 = 1.0;
  } else {
    tmpvar_48 = 0.0;
  };
  v_uv = ((tmpvar_47 / tmpvar_42) * mix (tmpvar_38.w, 1.0, tmpvar_48));
  v_opacity_perspective_vec.y = tmpvar_48;
  vec4 tmpvar_49;
  tmpvar_49.xy = (tmpvar_41.xy + vec2(0.5, 0.5));
  tmpvar_49.zw = (tmpvar_41.zw - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_49 / tmpvar_42.xyxy);
  v_opacity_perspective_vec.x = min (max ((
    float(tmpvar_12.y)
   / 65536.0), 0.0), 1.0);
  v_local_pos = tmpvar_36;
}

#version 150
// brush_opacity
// features: ["ANTIALIASING"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
in vec2 v_uv;
flat in vec4 v_uv_sample_bounds;
flat in vec2 v_opacity_perspective_vec;
void main ()
{
  oFragColor = (v_opacity_perspective_vec.x * texture (sColor0, min (max (
    (v_uv * mix (gl_FragCoord.w, 1.0, v_opacity_perspective_vec.y))
  , v_uv_sample_bounds.xy), v_uv_sample_bounds.zw)));
}

2795e285192523cbrush_opacity_ANTIALIASING_DEBUG_OVERDRAW#version 150
// brush_opacity
// features: ["ANTIALIASING", "DEBUG_OVERDRAW"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 v_uv;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_opacity_perspective_vec;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  ivec2 tmpvar_40;
  tmpvar_40.x = int((uint(tmpvar_12.x) % 1024u));
  tmpvar_40.y = int((uint(tmpvar_12.x) / 1024u));
  vec4 tmpvar_41;
  tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
  vec2 tmpvar_42;
  tmpvar_42 = vec2(textureSize (sColor0, 0));
  vec2 tmpvar_43;
  tmpvar_43 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  int tmpvar_44;
  tmpvar_44 = (tmpvar_12.x + 2);
  ivec2 tmpvar_45;
  tmpvar_45.x = int((uint(tmpvar_44) % 1024u));
  tmpvar_45.y = int((uint(tmpvar_44) / 1024u));
  vec4 tmpvar_46;
  tmpvar_46 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(1, 0)), tmpvar_43.x), mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(3, 0)), tmpvar_43.x), tmpvar_43.y);
  vec2 tmpvar_47;
  tmpvar_47 = mix (tmpvar_41.xy, tmpvar_41.zw, (tmpvar_46.xy / tmpvar_46.w));
  float tmpvar_48;
  if (((tmpvar_27 & 1) != 0)) {
    tmpvar_48 = 1.0;
  } else {
    tmpvar_48 = 0.0;
  };
  v_uv = ((tmpvar_47 / tmpvar_42) * mix (tmpvar_38.w, 1.0, tmpvar_48));
  v_opacity_perspective_vec.y = tmpvar_48;
  vec4 tmpvar_49;
  tmpvar_49.xy = (tmpvar_41.xy + vec2(0.5, 0.5));
  tmpvar_49.zw = (tmpvar_41.zw - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_49 / tmpvar_42.xyxy);
  v_opacity_perspective_vec.x = min (max ((
    float(tmpvar_12.y)
   / 65536.0), 0.0), 1.0);
  v_local_pos = tmpvar_36;
}

#version 150
// brush_opacity
// features: ["ANTIALIASING", "DEBUG_OVERDRAW"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

brush_opacity_DEBUG_OVERDRAW#version 150
// brush_opacity
// features: ["DEBUG_OVERDRAW"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_uv;
flat out vec4 v_uv_sample_bounds;
flat out vec2 v_opacity_perspective_vec;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 3) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  ivec2 tmpvar_40;
  tmpvar_40.x = int((uint(tmpvar_12.x) % 1024u));
  tmpvar_40.y = int((uint(tmpvar_12.x) / 1024u));
  vec4 tmpvar_41;
  tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_40, 0, ivec2(0, 0));
  vec2 tmpvar_42;
  tmpvar_42 = vec2(textureSize (sColor0, 0));
  vec2 tmpvar_43;
  tmpvar_43 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  int tmpvar_44;
  tmpvar_44 = (tmpvar_12.x + 2);
  ivec2 tmpvar_45;
  tmpvar_45.x = int((uint(tmpvar_44) % 1024u));
  tmpvar_45.y = int((uint(tmpvar_44) / 1024u));
  vec4 tmpvar_46;
  tmpvar_46 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(1, 0)), tmpvar_43.x), mix (texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_45, 0, ivec2(3, 0)), tmpvar_43.x), tmpvar_43.y);
  vec2 tmpvar_47;
  tmpvar_47 = mix (tmpvar_41.xy, tmpvar_41.zw, (tmpvar_46.xy / tmpvar_46.w));
  float tmpvar_48;
  if (((tmpvar_27 & 1) != 0)) {
    tmpvar_48 = 1.0;
  } else {
    tmpvar_48 = 0.0;
  };
  v_uv = ((tmpvar_47 / tmpvar_42) * mix (tmpvar_38.w, 1.0, tmpvar_48));
  v_opacity_perspective_vec.y = tmpvar_48;
  vec4 tmpvar_49;
  tmpvar_49.xy = (tmpvar_41.xy + vec2(0.5, 0.5));
  tmpvar_49.zw = (tmpvar_41.zw - vec2(0.5, 0.5));
  v_uv_sample_bounds = (tmpvar_49 / tmpvar_42.xyxy);
  v_opacity_perspective_vec.x = min (max ((
    float(tmpvar_12.y)
   / 65536.0), 0.0), 1.0);
}

#version 150
// brush_opacity
// features: ["DEBUG_OVERDRAW"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

#version 150
// brush_solid
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
flat out vec4 v_color;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 1) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec4 tmpvar_36;
  tmpvar_36.zw = vec2(0.0, 1.0);
  tmpvar_36.xy = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37 = (transform_m_13 * tmpvar_36);
  vec4 tmpvar_38;
  tmpvar_38.xy = ((tmpvar_37.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_37.w));
  tmpvar_38.z = (ph_z_4 * tmpvar_37.w);
  tmpvar_38.w = tmpvar_37.w;
  gl_Position = (uTransform * tmpvar_38);
  ivec2 tmpvar_39;
  tmpvar_39.x = int((uint(tmpvar_11.y) % 1024u));
  tmpvar_39.y = int((uint(tmpvar_11.y) / 1024u));
  v_color = (texelFetch (sGpuCache, tmpvar_39, 0) * (float(tmpvar_12.x) / 65535.0));
}

#version 150
// brush_solid
// features: []

precision highp float;
out vec4 oFragColor;
flat in vec4 v_color;
void main ()
{
  oFragColor = v_color;
}

brush_solid_ALPHA_PASS#version 150
// brush_solid
// features: ["ALPHA_PASS"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
flat out vec4 v_color;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  vec2 tmpvar_11;
  vec2 tmpvar_12;
  tmpvar_11 = tmpvar_8.xy;
  tmpvar_12 = tmpvar_8.zw;
  ivec2 tmpvar_13;
  tmpvar_13.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_13.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(0, 0));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_14.x);
  mat4 transform_m_16;
  bool transform_is_axis_aligned_17;
  transform_is_axis_aligned_17 = ((tmpvar_14.z >> 24) == 0);
  int tmpvar_18;
  tmpvar_18 = (tmpvar_14.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_16[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_16[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_16[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_16[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  ivec2 tmpvar_20;
  tmpvar_20.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_20.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_21;
  tmpvar_21 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(0, 0));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_23;
  float area_device_pixel_scale_24;
  vec2 area_screen_origin_25;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_23 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_24 = 0.0;
    area_screen_origin_25 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_26;
    tmpvar_26.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_26.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_27;
    tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
    area_task_rect_23.p0 = tmpvar_27.xy;
    area_task_rect_23.p1 = tmpvar_27.zw;
    area_device_pixel_scale_24 = tmpvar_28.x;
    area_screen_origin_25 = tmpvar_28.yz;
  };
  vec2 tmpvar_29;
  vec2 tmpvar_30;
  tmpvar_29 = tmpvar_11;
  tmpvar_30 = tmpvar_12;
  vec2 adjusted_segment_rect_p0_31;
  vec2 adjusted_segment_rect_p1_32;
  vec2 segment_rect_p0_33;
  vec2 segment_rect_p1_34;
  int tmpvar_35;
  tmpvar_35 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_36;
  tmpvar_36 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_33 = tmpvar_9;
    segment_rect_p1_34 = tmpvar_10;
  } else {
    int tmpvar_37;
    tmpvar_37 = ((tmpvar_14.y + 1) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_38;
    tmpvar_38.x = int((uint(tmpvar_37) % 1024u));
    tmpvar_38.y = int((uint(tmpvar_37) / 1024u));
    vec4 tmpvar_39;
    tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_38, 0, ivec2(0, 0));
    segment_rect_p0_33 = (tmpvar_39.xy + tmpvar_7.xy);
    segment_rect_p1_34 = (tmpvar_39.zw + tmpvar_7.xy);
  };
  adjusted_segment_rect_p0_31 = segment_rect_p0_33;
  adjusted_segment_rect_p1_32 = segment_rect_p1_34;
  if ((!(transform_is_axis_aligned_17) || ((tmpvar_36 & 256) != 0))) {
    vec2 tmpvar_40;
    tmpvar_40 = min (max (segment_rect_p0_33, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_41;
    tmpvar_41 = min (max (segment_rect_p1_34, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_42;
    tmpvar_42.x = bool((tmpvar_35 & 1));
    tmpvar_42.y = bool((tmpvar_35 & 2));
    tmpvar_42.z = bool((tmpvar_35 & 4));
    tmpvar_42.w = bool((tmpvar_35 & 8));
    vec4 tmpvar_43;
    tmpvar_43.xy = tmpvar_40;
    tmpvar_43.zw = tmpvar_41;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_43, bvec4(tmpvar_42));
    vec4 tmpvar_44;
    tmpvar_44 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_42));
    adjusted_segment_rect_p0_31 = (tmpvar_40 - tmpvar_44.xy);
    adjusted_segment_rect_p1_32 = (tmpvar_41 + tmpvar_44.zw);
    tmpvar_29 = vec2(-1e+16, -1e+16);
    tmpvar_30 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_45;
  tmpvar_45 = min (max (mix (adjusted_segment_rect_p0_31, adjusted_segment_rect_p1_32, aPosition), tmpvar_29), tmpvar_30);
  vec4 tmpvar_46;
  tmpvar_46.zw = vec2(0.0, 1.0);
  tmpvar_46.xy = tmpvar_45;
  vec4 tmpvar_47;
  tmpvar_47 = (transform_m_16 * tmpvar_46);
  vec4 tmpvar_48;
  tmpvar_48.xy = ((tmpvar_47.xy * tmpvar_22.x) + ((
    -(tmpvar_22.yz)
   + tmpvar_21.xy) * tmpvar_47.w));
  tmpvar_48.z = (ph_z_5 * tmpvar_47.w);
  tmpvar_48.w = tmpvar_47.w;
  gl_Position = (uTransform * tmpvar_48);
  vec4 tmpvar_49;
  tmpvar_49.xy = area_task_rect_23.p0;
  tmpvar_49.zw = area_task_rect_23.p1;
  vClipMaskUvBounds = tmpvar_49;
  vClipMaskUv = ((tmpvar_47.xy * area_device_pixel_scale_24) + (tmpvar_47.w * (area_task_rect_23.p0 - area_screen_origin_25)));
  ivec2 tmpvar_50;
  tmpvar_50.x = int((uint(tmpvar_14.y) % 1024u));
  tmpvar_50.y = int((uint(tmpvar_14.y) / 1024u));
  v_color = (texelFetch (sGpuCache, tmpvar_50, 0) * (float(tmpvar_15.x) / 65535.0));
  v_local_pos = tmpvar_45;
}

#version 150
// brush_solid
// features: ["ALPHA_PASS"]

precision highp float;
out vec4 oFragColor;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
flat in vec4 v_color;
void main ()
{
  vec4 frag_color_1;
  vec2 tmpvar_2;
  tmpvar_2 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  frag_color_1 = (v_color * min (max (
    (0.5 - max (tmpvar_2.x, tmpvar_2.y))
  , 0.0), 1.0));
  float tmpvar_3;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_3 = 1.0;
  } else {
    vec2 tmpvar_4;
    tmpvar_4 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_5;
    tmpvar_5.xy = greaterThanEqual (tmpvar_4, vClipMaskUvBounds.xy);
    tmpvar_5.zw = lessThan (tmpvar_4, vClipMaskUvBounds.zw);
    bool tmpvar_6;
    tmpvar_6 = (tmpvar_5 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_6)) {
      tmpvar_3 = 0.0;
    } else {
      tmpvar_3 = texelFetch (sClipMask, ivec2(tmpvar_4), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_3);
  oFragColor = frag_color_1;
}

brush_solid_DEBUG_OVERDRAW#version 150
// brush_solid
// features: ["DEBUG_OVERDRAW"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
flat out vec4 v_color;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 1) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec4 tmpvar_36;
  tmpvar_36.zw = vec2(0.0, 1.0);
  tmpvar_36.xy = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37 = (transform_m_13 * tmpvar_36);
  vec4 tmpvar_38;
  tmpvar_38.xy = ((tmpvar_37.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_37.w));
  tmpvar_38.z = (ph_z_4 * tmpvar_37.w);
  tmpvar_38.w = tmpvar_37.w;
  gl_Position = (uTransform * tmpvar_38);
  ivec2 tmpvar_39;
  tmpvar_39.x = int((uint(tmpvar_11.y) % 1024u));
  tmpvar_39.y = int((uint(tmpvar_11.y) / 1024u));
  v_color = (texelFetch (sGpuCache, tmpvar_39, 0) * (float(tmpvar_12.x) / 65535.0));
}

#version 150
// brush_solid
// features: ["DEBUG_OVERDRAW"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

brush_yuv_image_ALPHA_PASS_TEXTURE_2D_YUV#version 150
// brush_yuv_image
// features: ["ALPHA_PASS", "TEXTURE_2D", "YUV"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sColor2;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 vUv_Y;
flat out vec4 vUvBounds_Y;
out vec2 vUv_U;
flat out vec4 vUvBounds_U;
out vec2 vUv_V;
flat out vec4 vUvBounds_V;
flat out vec3 vYcbcrBias;
flat out mat3 vRgbFromDebiasedYcbcr;
flat out ivec2 vFormat;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  vec2 tmpvar_11;
  vec2 tmpvar_12;
  tmpvar_11 = tmpvar_8.xy;
  tmpvar_12 = tmpvar_8.zw;
  ivec2 tmpvar_13;
  tmpvar_13.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_13.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(0, 0));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_14.x);
  mat4 transform_m_16;
  bool transform_is_axis_aligned_17;
  transform_is_axis_aligned_17 = ((tmpvar_14.z >> 24) == 0);
  int tmpvar_18;
  tmpvar_18 = (tmpvar_14.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_16[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_16[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_16[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_16[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  ivec2 tmpvar_20;
  tmpvar_20.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_20.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_21;
  tmpvar_21 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(0, 0));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_23;
  float area_device_pixel_scale_24;
  vec2 area_screen_origin_25;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_23 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_24 = 0.0;
    area_screen_origin_25 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_26;
    tmpvar_26.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_26.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_27;
    tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
    area_task_rect_23.p0 = tmpvar_27.xy;
    area_task_rect_23.p1 = tmpvar_27.zw;
    area_device_pixel_scale_24 = tmpvar_28.x;
    area_screen_origin_25 = tmpvar_28.yz;
  };
  vec2 tmpvar_29;
  vec2 tmpvar_30;
  tmpvar_29 = tmpvar_11;
  tmpvar_30 = tmpvar_12;
  vec2 adjusted_segment_rect_p0_31;
  vec2 adjusted_segment_rect_p1_32;
  vec2 segment_rect_p0_33;
  vec2 segment_rect_p1_34;
  int tmpvar_35;
  tmpvar_35 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_36;
  tmpvar_36 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_33 = tmpvar_9;
    segment_rect_p1_34 = tmpvar_10;
  } else {
    int tmpvar_37;
    tmpvar_37 = ((tmpvar_14.y + 1) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_38;
    tmpvar_38.x = int((uint(tmpvar_37) % 1024u));
    tmpvar_38.y = int((uint(tmpvar_37) / 1024u));
    vec4 tmpvar_39;
    tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_38, 0, ivec2(0, 0));
    segment_rect_p0_33 = (tmpvar_39.xy + tmpvar_7.xy);
    segment_rect_p1_34 = (tmpvar_39.zw + tmpvar_7.xy);
  };
  adjusted_segment_rect_p0_31 = segment_rect_p0_33;
  adjusted_segment_rect_p1_32 = segment_rect_p1_34;
  if ((!(transform_is_axis_aligned_17) || ((tmpvar_36 & 256) != 0))) {
    vec2 tmpvar_40;
    tmpvar_40 = min (max (segment_rect_p0_33, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_41;
    tmpvar_41 = min (max (segment_rect_p1_34, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_42;
    tmpvar_42.x = bool((tmpvar_35 & 1));
    tmpvar_42.y = bool((tmpvar_35 & 2));
    tmpvar_42.z = bool((tmpvar_35 & 4));
    tmpvar_42.w = bool((tmpvar_35 & 8));
    vec4 tmpvar_43;
    tmpvar_43.xy = tmpvar_40;
    tmpvar_43.zw = tmpvar_41;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_43, bvec4(tmpvar_42));
    vec4 tmpvar_44;
    tmpvar_44 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_42));
    adjusted_segment_rect_p0_31 = (tmpvar_40 - tmpvar_44.xy);
    adjusted_segment_rect_p1_32 = (tmpvar_41 + tmpvar_44.zw);
    tmpvar_29 = vec2(-1e+16, -1e+16);
    tmpvar_30 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_45;
  tmpvar_45 = min (max (mix (adjusted_segment_rect_p0_31, adjusted_segment_rect_p1_32, aPosition), tmpvar_29), tmpvar_30);
  vec4 tmpvar_46;
  tmpvar_46.zw = vec2(0.0, 1.0);
  tmpvar_46.xy = tmpvar_45;
  vec4 tmpvar_47;
  tmpvar_47 = (transform_m_16 * tmpvar_46);
  vec4 tmpvar_48;
  tmpvar_48.xy = ((tmpvar_47.xy * tmpvar_22.x) + ((
    -(tmpvar_22.yz)
   + tmpvar_21.xy) * tmpvar_47.w));
  tmpvar_48.z = (ph_z_5 * tmpvar_47.w);
  tmpvar_48.w = tmpvar_47.w;
  gl_Position = (uTransform * tmpvar_48);
  vec4 tmpvar_49;
  tmpvar_49.xy = area_task_rect_23.p0;
  tmpvar_49.zw = area_task_rect_23.p1;
  vClipMaskUvBounds = tmpvar_49;
  vClipMaskUv = ((tmpvar_47.xy * area_device_pixel_scale_24) + (tmpvar_47.w * (area_task_rect_23.p0 - area_screen_origin_25)));
  vec2 f_50;
  f_50 = ((tmpvar_45 - tmpvar_7.xy) / (tmpvar_7.zw - tmpvar_7.xy));
  ivec2 tmpvar_51;
  tmpvar_51.x = int((uint(tmpvar_14.y) % 1024u));
  tmpvar_51.y = int((uint(tmpvar_14.y) / 1024u));
  vec4 tmpvar_52;
  tmpvar_52 = texelFetch (sGpuCache, tmpvar_51, 0);
  int tmpvar_53;
  tmpvar_53 = int(tmpvar_52.z);
  int tmpvar_54;
  int tmpvar_55;
  tmpvar_54 = int(tmpvar_52.x);
  tmpvar_55 = int(tmpvar_52.y);
  mat3 tmpvar_56;
  vec4 tmpvar_57;
  float channel_max_58;
  channel_max_58 = 255.0;
  if ((8 < tmpvar_54)) {
    if ((tmpvar_53 == 1)) {
      channel_max_58 = float(((1 << tmpvar_54) - 1));
    } else {
      channel_max_58 = 65535.0;
    };
  };
  if ((tmpvar_55 == 0)) {
    tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
    tmpvar_57 = (vec4((ivec4(16, 128, 235, 240) << 
      (tmpvar_54 - 8)
    )) / channel_max_58);
  } else {
    if ((tmpvar_55 == 1)) {
      float tmpvar_59;
      tmpvar_59 = (float((
        (1 << tmpvar_54)
       - 1)) / channel_max_58);
      vec4 tmpvar_60;
      tmpvar_60.xy = vec2(0.0, 0.0);
      tmpvar_60.z = tmpvar_59;
      tmpvar_60.w = tmpvar_59;
      vec4 tmpvar_61;
      tmpvar_61.x = 0.0;
      tmpvar_61.y = (vec4((ivec4(16, 128, 235, 240) << 
        (tmpvar_54 - 8)
      )) / channel_max_58).y;
      tmpvar_61.zw = tmpvar_60.zw;
      tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
      tmpvar_57 = tmpvar_61;
    } else {
      if ((tmpvar_55 == 2)) {
        tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
        tmpvar_57 = (vec4((ivec4(16, 128, 235, 240) << 
          (tmpvar_54 - 8)
        )) / channel_max_58);
      } else {
        if ((tmpvar_55 == 3)) {
          float tmpvar_62;
          tmpvar_62 = (float((
            (1 << tmpvar_54)
           - 1)) / channel_max_58);
          vec4 tmpvar_63;
          tmpvar_63.xy = vec2(0.0, 0.0);
          tmpvar_63.z = tmpvar_62;
          tmpvar_63.w = tmpvar_62;
          vec4 tmpvar_64;
          tmpvar_64.x = 0.0;
          tmpvar_64.y = (vec4((ivec4(16, 128, 235, 240) << 
            (tmpvar_54 - 8)
          )) / channel_max_58).y;
          tmpvar_64.zw = tmpvar_63.zw;
          tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
          tmpvar_57 = tmpvar_64;
        } else {
          if ((tmpvar_55 == 4)) {
            tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
            tmpvar_57 = (vec4((ivec4(16, 128, 235, 240) << 
              (tmpvar_54 - 8)
            )) / channel_max_58);
          } else {
            if ((tmpvar_55 == 5)) {
              float tmpvar_65;
              tmpvar_65 = (float((
                (1 << tmpvar_54)
               - 1)) / channel_max_58);
              vec4 tmpvar_66;
              tmpvar_66.xy = vec2(0.0, 0.0);
              tmpvar_66.z = tmpvar_65;
              tmpvar_66.w = tmpvar_65;
              vec4 tmpvar_67;
              tmpvar_67.x = 0.0;
              tmpvar_67.y = (vec4((ivec4(16, 128, 235, 240) << 
                (tmpvar_54 - 8)
              )) / channel_max_58).y;
              tmpvar_67.zw = tmpvar_66.zw;
              tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
              tmpvar_57 = tmpvar_67;
            } else {
              float tmpvar_68;
              tmpvar_68 = (float((
                (1 << tmpvar_54)
               - 1)) / channel_max_58);
              vec4 tmpvar_69;
              tmpvar_69.xy = vec2(0.0, 0.0);
              tmpvar_69.z = tmpvar_68;
              tmpvar_69.w = tmpvar_68;
              tmpvar_56 = mat3(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0);
              tmpvar_57 = tmpvar_69;
            };
          };
        };
      };
    };
  };
  vec2 tmpvar_70;
  tmpvar_70 = (1.0/((tmpvar_57.zw - tmpvar_57.xy)));
  mat3 tmpvar_71;
  tmpvar_71[uint(0)].x = tmpvar_70.x;
  tmpvar_71[uint(0)].y = 0.0;
  tmpvar_71[uint(0)].z = 0.0;
  tmpvar_71[1u].x = 0.0;
  tmpvar_71[1u].y = tmpvar_70.y;
  tmpvar_71[1u].z = 0.0;
  tmpvar_71[2u].x = 0.0;
  tmpvar_71[2u].y = 0.0;
  tmpvar_71[2u].z = tmpvar_70.y;
  vYcbcrBias = tmpvar_57.xyy;
  vRgbFromDebiasedYcbcr = (tmpvar_56 * tmpvar_71);
  vFormat.x = tmpvar_53;
  if (((tmpvar_53 == 2) || (tmpvar_53 == 99))) {
    ivec2 tmpvar_72;
    tmpvar_72.x = int((uint(tmpvar_15.x) % 1024u));
    tmpvar_72.y = int((uint(tmpvar_15.x) / 1024u));
    vec4 tmpvar_73;
    tmpvar_73 = texelFetchOffset (sGpuCache, tmpvar_72, 0, ivec2(0, 0));
    ivec2 tmpvar_74;
    tmpvar_74.x = int((uint(tmpvar_15.y) % 1024u));
    tmpvar_74.y = int((uint(tmpvar_15.y) / 1024u));
    vec4 tmpvar_75;
    tmpvar_75 = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(0, 0));
    ivec2 tmpvar_76;
    tmpvar_76.x = int((uint(tmpvar_15.z) % 1024u));
    tmpvar_76.y = int((uint(tmpvar_15.z) / 1024u));
    vec4 tmpvar_77;
    tmpvar_77 = texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(0, 0));
    vec2 tmpvar_78;
    tmpvar_78 = vec2(textureSize (sColor0, 0));
    vec4 tmpvar_79;
    tmpvar_79.xy = (tmpvar_73.xy + vec2(0.5, 0.5));
    tmpvar_79.zw = (tmpvar_73.zw - vec2(0.5, 0.5));
    vUv_Y = (mix (tmpvar_73.xy, tmpvar_73.zw, f_50) / tmpvar_78);
    vUvBounds_Y = (tmpvar_79 / tmpvar_78.xyxy);
    vec2 tmpvar_80;
    tmpvar_80 = vec2(textureSize (sColor1, 0));
    vec4 tmpvar_81;
    tmpvar_81.xy = (tmpvar_75.xy + vec2(0.5, 0.5));
    tmpvar_81.zw = (tmpvar_75.zw - vec2(0.5, 0.5));
    vUv_U = (mix (tmpvar_75.xy, tmpvar_75.zw, f_50) / tmpvar_80);
    vUvBounds_U = (tmpvar_81 / tmpvar_80.xyxy);
    vec2 tmpvar_82;
    tmpvar_82 = vec2(textureSize (sColor2, 0));
    vec4 tmpvar_83;
    tmpvar_83.xy = (tmpvar_77.xy + vec2(0.5, 0.5));
    tmpvar_83.zw = (tmpvar_77.zw - vec2(0.5, 0.5));
    vUv_V = (mix (tmpvar_77.xy, tmpvar_77.zw, f_50) / tmpvar_82);
    vUvBounds_V = (tmpvar_83 / tmpvar_82.xyxy);
  } else {
    if (((tmpvar_53 == 0) || (tmpvar_53 == 1))) {
      ivec2 tmpvar_84;
      tmpvar_84.x = int((uint(tmpvar_15.x) % 1024u));
      tmpvar_84.y = int((uint(tmpvar_15.x) / 1024u));
      vec4 tmpvar_85;
      tmpvar_85 = texelFetchOffset (sGpuCache, tmpvar_84, 0, ivec2(0, 0));
      ivec2 tmpvar_86;
      tmpvar_86.x = int((uint(tmpvar_15.y) % 1024u));
      tmpvar_86.y = int((uint(tmpvar_15.y) / 1024u));
      vec4 tmpvar_87;
      tmpvar_87 = texelFetchOffset (sGpuCache, tmpvar_86, 0, ivec2(0, 0));
      vec2 tmpvar_88;
      tmpvar_88 = vec2(textureSize (sColor0, 0));
      vec4 tmpvar_89;
      tmpvar_89.xy = (tmpvar_85.xy + vec2(0.5, 0.5));
      tmpvar_89.zw = (tmpvar_85.zw - vec2(0.5, 0.5));
      vUv_Y = (mix (tmpvar_85.xy, tmpvar_85.zw, f_50) / tmpvar_88);
      vUvBounds_Y = (tmpvar_89 / tmpvar_88.xyxy);
      vec2 tmpvar_90;
      tmpvar_90 = vec2(textureSize (sColor1, 0));
      vec4 tmpvar_91;
      tmpvar_91.xy = (tmpvar_87.xy + vec2(0.5, 0.5));
      tmpvar_91.zw = (tmpvar_87.zw - vec2(0.5, 0.5));
      vUv_U = (mix (tmpvar_87.xy, tmpvar_87.zw, f_50) / tmpvar_90);
      vUvBounds_U = (tmpvar_91 / tmpvar_90.xyxy);
    } else {
      if ((tmpvar_53 == 3)) {
        ivec2 tmpvar_92;
        tmpvar_92.x = int((uint(tmpvar_15.x) % 1024u));
        tmpvar_92.y = int((uint(tmpvar_15.x) / 1024u));
        vec4 tmpvar_93;
        tmpvar_93 = texelFetchOffset (sGpuCache, tmpvar_92, 0, ivec2(0, 0));
        vec2 tmpvar_94;
        tmpvar_94 = vec2(textureSize (sColor0, 0));
        vec4 tmpvar_95;
        tmpvar_95.xy = (tmpvar_93.xy + vec2(0.5, 0.5));
        tmpvar_95.zw = (tmpvar_93.zw - vec2(0.5, 0.5));
        vUv_Y = (mix (tmpvar_93.xy, tmpvar_93.zw, f_50) / tmpvar_94);
        vUvBounds_Y = (tmpvar_95 / tmpvar_94.xyxy);
      };
    };
  };
  v_local_pos = tmpvar_45;
}

#version 150
// brush_yuv_image
// features: ["ALPHA_PASS", "TEXTURE_2D", "YUV"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sColor2;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 vUv_Y;
flat in vec4 vUvBounds_Y;
in vec2 vUv_U;
flat in vec4 vUvBounds_U;
in vec2 vUv_V;
flat in vec4 vUvBounds_V;
flat in vec3 vYcbcrBias;
flat in mat3 vRgbFromDebiasedYcbcr;
flat in ivec2 vFormat;
void main ()
{
  vec4 frag_color_1;
  vec3 ycbcr_sample_2;
  bool tmpvar_3;
  bool tmpvar_4;
  tmpvar_4 = bool(0);
  tmpvar_3 = (2 == vFormat.x);
  if (tmpvar_3) {
    ycbcr_sample_2.x = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).x;
    ycbcr_sample_2.y = texture (sColor1, min (max (vUv_U, vUvBounds_U.xy), vUvBounds_U.zw)).x;
    ycbcr_sample_2.z = texture (sColor2, min (max (vUv_V, vUvBounds_V.xy), vUvBounds_V.zw)).x;
    tmpvar_4 = bool(1);
  };
  tmpvar_3 = (tmpvar_3 || (0 == vFormat.x));
  tmpvar_3 = (tmpvar_3 || (1 == vFormat.x));
  tmpvar_3 = (tmpvar_3 && !(tmpvar_4));
  if (tmpvar_3) {
    ycbcr_sample_2.x = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).x;
    ycbcr_sample_2.yz = texture (sColor1, min (max (vUv_U, vUvBounds_U.xy), vUvBounds_U.zw)).xy;
    tmpvar_4 = bool(1);
  };
  tmpvar_3 = (tmpvar_3 || (3 == vFormat.x));
  tmpvar_3 = (tmpvar_3 && !(tmpvar_4));
  if (tmpvar_3) {
    ycbcr_sample_2 = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).yzx;
    tmpvar_4 = bool(1);
  };
  tmpvar_3 = !(tmpvar_4);
  if (tmpvar_3) {
    ycbcr_sample_2 = vec3(0.0, 0.0, 0.0);
    tmpvar_4 = bool(1);
  };
  vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = (vRgbFromDebiasedYcbcr * (ycbcr_sample_2 - vYcbcrBias));
  vec2 tmpvar_6;
  tmpvar_6 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  frag_color_1 = (tmpvar_5 * min (max (
    (0.5 - max (tmpvar_6.x, tmpvar_6.y))
  , 0.0), 1.0));
  float tmpvar_7;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_7 = 1.0;
  } else {
    vec2 tmpvar_8;
    tmpvar_8 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_9;
    tmpvar_9.xy = greaterThanEqual (tmpvar_8, vClipMaskUvBounds.xy);
    tmpvar_9.zw = lessThan (tmpvar_8, vClipMaskUvBounds.zw);
    bool tmpvar_10;
    tmpvar_10 = (tmpvar_9 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_10)) {
      tmpvar_7 = 0.0;
    } else {
      tmpvar_7 = texelFetch (sClipMask, ivec2(tmpvar_8), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_7);
  oFragColor = frag_color_1;
}

brush_yuv_image_ALPHA_PASS_TEXTURE_RECT_YUV#version 150
// brush_yuv_image
// features: ["ALPHA_PASS", "TEXTURE_RECT", "YUV"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 v_local_pos;
out vec2 vUv_Y;
flat out vec4 vUvBounds_Y;
out vec2 vUv_U;
flat out vec4 vUvBounds_U;
out vec2 vUv_V;
flat out vec4 vUvBounds_V;
flat out vec3 vYcbcrBias;
flat out mat3 vRgbFromDebiasedYcbcr;
flat out ivec2 vFormat;
void main ()
{
  int instance_picture_task_address_1;
  int instance_clip_address_2;
  int instance_segment_index_3;
  int instance_flags_4;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_clip_address_2 = (aData.y & 65535);
  instance_segment_index_3 = (aData.z & 65535);
  instance_flags_4 = (aData.z >> 16);
  float ph_z_5;
  ivec2 tmpvar_6;
  tmpvar_6.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_6.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(0, 0));
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_6, 0, ivec2(1, 0));
  vec2 tmpvar_9;
  vec2 tmpvar_10;
  tmpvar_9 = tmpvar_7.xy;
  tmpvar_10 = tmpvar_7.zw;
  vec2 tmpvar_11;
  vec2 tmpvar_12;
  tmpvar_11 = tmpvar_8.xy;
  tmpvar_12 = tmpvar_8.zw;
  ivec2 tmpvar_13;
  tmpvar_13.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_13.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(0, 0));
  ivec4 tmpvar_15;
  tmpvar_15 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_13, 0, ivec2(1, 0));
  ph_z_5 = float(tmpvar_14.x);
  mat4 transform_m_16;
  bool transform_is_axis_aligned_17;
  transform_is_axis_aligned_17 = ((tmpvar_14.z >> 24) == 0);
  int tmpvar_18;
  tmpvar_18 = (tmpvar_14.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_16[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_16[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_16[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_16[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  ivec2 tmpvar_20;
  tmpvar_20.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_20.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_21;
  tmpvar_21 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(0, 0));
  vec4 tmpvar_22;
  tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(1, 0));
  RectWithEndpoint area_task_rect_23;
  float area_device_pixel_scale_24;
  vec2 area_screen_origin_25;
  if ((instance_clip_address_2 >= 32767)) {
    area_task_rect_23 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_24 = 0.0;
    area_screen_origin_25 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_26;
    tmpvar_26.x = int((2u * (
      uint(instance_clip_address_2)
     % 512u)));
    tmpvar_26.y = int((uint(instance_clip_address_2) / 512u));
    vec4 tmpvar_27;
    tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
    vec4 tmpvar_28;
    tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
    area_task_rect_23.p0 = tmpvar_27.xy;
    area_task_rect_23.p1 = tmpvar_27.zw;
    area_device_pixel_scale_24 = tmpvar_28.x;
    area_screen_origin_25 = tmpvar_28.yz;
  };
  vec2 tmpvar_29;
  vec2 tmpvar_30;
  tmpvar_29 = tmpvar_11;
  tmpvar_30 = tmpvar_12;
  vec2 adjusted_segment_rect_p0_31;
  vec2 adjusted_segment_rect_p1_32;
  vec2 segment_rect_p0_33;
  vec2 segment_rect_p1_34;
  int tmpvar_35;
  tmpvar_35 = ((instance_flags_4 >> 12) & 15);
  int tmpvar_36;
  tmpvar_36 = (instance_flags_4 & 4095);
  if ((instance_segment_index_3 == 65535)) {
    segment_rect_p0_33 = tmpvar_9;
    segment_rect_p1_34 = tmpvar_10;
  } else {
    int tmpvar_37;
    tmpvar_37 = ((tmpvar_14.y + 1) + (instance_segment_index_3 * 2));
    ivec2 tmpvar_38;
    tmpvar_38.x = int((uint(tmpvar_37) % 1024u));
    tmpvar_38.y = int((uint(tmpvar_37) / 1024u));
    vec4 tmpvar_39;
    tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_38, 0, ivec2(0, 0));
    segment_rect_p0_33 = (tmpvar_39.xy + tmpvar_7.xy);
    segment_rect_p1_34 = (tmpvar_39.zw + tmpvar_7.xy);
  };
  adjusted_segment_rect_p0_31 = segment_rect_p0_33;
  adjusted_segment_rect_p1_32 = segment_rect_p1_34;
  if ((!(transform_is_axis_aligned_17) || ((tmpvar_36 & 256) != 0))) {
    vec2 tmpvar_40;
    tmpvar_40 = min (max (segment_rect_p0_33, tmpvar_8.xy), tmpvar_8.zw);
    vec2 tmpvar_41;
    tmpvar_41 = min (max (segment_rect_p1_34, tmpvar_8.xy), tmpvar_8.zw);
    bvec4 tmpvar_42;
    tmpvar_42.x = bool((tmpvar_35 & 1));
    tmpvar_42.y = bool((tmpvar_35 & 2));
    tmpvar_42.z = bool((tmpvar_35 & 4));
    tmpvar_42.w = bool((tmpvar_35 & 8));
    vec4 tmpvar_43;
    tmpvar_43.xy = tmpvar_40;
    tmpvar_43.zw = tmpvar_41;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_43, bvec4(tmpvar_42));
    vec4 tmpvar_44;
    tmpvar_44 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_42));
    adjusted_segment_rect_p0_31 = (tmpvar_40 - tmpvar_44.xy);
    adjusted_segment_rect_p1_32 = (tmpvar_41 + tmpvar_44.zw);
    tmpvar_29 = vec2(-1e+16, -1e+16);
    tmpvar_30 = vec2(1e+16, 1e+16);
  } else {
    vTransformBounds = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  };
  vec2 tmpvar_45;
  tmpvar_45 = min (max (mix (adjusted_segment_rect_p0_31, adjusted_segment_rect_p1_32, aPosition), tmpvar_29), tmpvar_30);
  vec4 tmpvar_46;
  tmpvar_46.zw = vec2(0.0, 1.0);
  tmpvar_46.xy = tmpvar_45;
  vec4 tmpvar_47;
  tmpvar_47 = (transform_m_16 * tmpvar_46);
  vec4 tmpvar_48;
  tmpvar_48.xy = ((tmpvar_47.xy * tmpvar_22.x) + ((
    -(tmpvar_22.yz)
   + tmpvar_21.xy) * tmpvar_47.w));
  tmpvar_48.z = (ph_z_5 * tmpvar_47.w);
  tmpvar_48.w = tmpvar_47.w;
  gl_Position = (uTransform * tmpvar_48);
  vec4 tmpvar_49;
  tmpvar_49.xy = area_task_rect_23.p0;
  tmpvar_49.zw = area_task_rect_23.p1;
  vClipMaskUvBounds = tmpvar_49;
  vClipMaskUv = ((tmpvar_47.xy * area_device_pixel_scale_24) + (tmpvar_47.w * (area_task_rect_23.p0 - area_screen_origin_25)));
  vec2 f_50;
  f_50 = ((tmpvar_45 - tmpvar_7.xy) / (tmpvar_7.zw - tmpvar_7.xy));
  ivec2 tmpvar_51;
  tmpvar_51.x = int((uint(tmpvar_14.y) % 1024u));
  tmpvar_51.y = int((uint(tmpvar_14.y) / 1024u));
  vec4 tmpvar_52;
  tmpvar_52 = texelFetch (sGpuCache, tmpvar_51, 0);
  int tmpvar_53;
  tmpvar_53 = int(tmpvar_52.z);
  int tmpvar_54;
  int tmpvar_55;
  tmpvar_54 = int(tmpvar_52.x);
  tmpvar_55 = int(tmpvar_52.y);
  mat3 tmpvar_56;
  vec4 tmpvar_57;
  float channel_max_58;
  channel_max_58 = 255.0;
  if ((8 < tmpvar_54)) {
    if ((tmpvar_53 == 1)) {
      channel_max_58 = float(((1 << tmpvar_54) - 1));
    } else {
      channel_max_58 = 65535.0;
    };
  };
  if ((tmpvar_55 == 0)) {
    tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
    tmpvar_57 = (vec4((ivec4(16, 128, 235, 240) << 
      (tmpvar_54 - 8)
    )) / channel_max_58);
  } else {
    if ((tmpvar_55 == 1)) {
      float tmpvar_59;
      tmpvar_59 = (float((
        (1 << tmpvar_54)
       - 1)) / channel_max_58);
      vec4 tmpvar_60;
      tmpvar_60.xy = vec2(0.0, 0.0);
      tmpvar_60.z = tmpvar_59;
      tmpvar_60.w = tmpvar_59;
      vec4 tmpvar_61;
      tmpvar_61.x = 0.0;
      tmpvar_61.y = (vec4((ivec4(16, 128, 235, 240) << 
        (tmpvar_54 - 8)
      )) / channel_max_58).y;
      tmpvar_61.zw = tmpvar_60.zw;
      tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
      tmpvar_57 = tmpvar_61;
    } else {
      if ((tmpvar_55 == 2)) {
        tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
        tmpvar_57 = (vec4((ivec4(16, 128, 235, 240) << 
          (tmpvar_54 - 8)
        )) / channel_max_58);
      } else {
        if ((tmpvar_55 == 3)) {
          float tmpvar_62;
          tmpvar_62 = (float((
            (1 << tmpvar_54)
           - 1)) / channel_max_58);
          vec4 tmpvar_63;
          tmpvar_63.xy = vec2(0.0, 0.0);
          tmpvar_63.z = tmpvar_62;
          tmpvar_63.w = tmpvar_62;
          vec4 tmpvar_64;
          tmpvar_64.x = 0.0;
          tmpvar_64.y = (vec4((ivec4(16, 128, 235, 240) << 
            (tmpvar_54 - 8)
          )) / channel_max_58).y;
          tmpvar_64.zw = tmpvar_63.zw;
          tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
          tmpvar_57 = tmpvar_64;
        } else {
          if ((tmpvar_55 == 4)) {
            tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
            tmpvar_57 = (vec4((ivec4(16, 128, 235, 240) << 
              (tmpvar_54 - 8)
            )) / channel_max_58);
          } else {
            if ((tmpvar_55 == 5)) {
              float tmpvar_65;
              tmpvar_65 = (float((
                (1 << tmpvar_54)
               - 1)) / channel_max_58);
              vec4 tmpvar_66;
              tmpvar_66.xy = vec2(0.0, 0.0);
              tmpvar_66.z = tmpvar_65;
              tmpvar_66.w = tmpvar_65;
              vec4 tmpvar_67;
              tmpvar_67.x = 0.0;
              tmpvar_67.y = (vec4((ivec4(16, 128, 235, 240) << 
                (tmpvar_54 - 8)
              )) / channel_max_58).y;
              tmpvar_67.zw = tmpvar_66.zw;
              tmpvar_56 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
              tmpvar_57 = tmpvar_67;
            } else {
              float tmpvar_68;
              tmpvar_68 = (float((
                (1 << tmpvar_54)
               - 1)) / channel_max_58);
              vec4 tmpvar_69;
              tmpvar_69.xy = vec2(0.0, 0.0);
              tmpvar_69.z = tmpvar_68;
              tmpvar_69.w = tmpvar_68;
              tmpvar_56 = mat3(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0);
              tmpvar_57 = tmpvar_69;
            };
          };
        };
      };
    };
  };
  vec2 tmpvar_70;
  tmpvar_70 = (1.0/((tmpvar_57.zw - tmpvar_57.xy)));
  mat3 tmpvar_71;
  tmpvar_71[uint(0)].x = tmpvar_70.x;
  tmpvar_71[uint(0)].y = 0.0;
  tmpvar_71[uint(0)].z = 0.0;
  tmpvar_71[1u].x = 0.0;
  tmpvar_71[1u].y = tmpvar_70.y;
  tmpvar_71[1u].z = 0.0;
  tmpvar_71[2u].x = 0.0;
  tmpvar_71[2u].y = 0.0;
  tmpvar_71[2u].z = tmpvar_70.y;
  vYcbcrBias = tmpvar_57.xyy;
  vRgbFromDebiasedYcbcr = (tmpvar_56 * tmpvar_71);
  vFormat.x = tmpvar_53;
  if (((tmpvar_53 == 2) || (tmpvar_53 == 99))) {
    ivec2 tmpvar_72;
    tmpvar_72.x = int((uint(tmpvar_15.x) % 1024u));
    tmpvar_72.y = int((uint(tmpvar_15.x) / 1024u));
    vec4 tmpvar_73;
    tmpvar_73 = texelFetchOffset (sGpuCache, tmpvar_72, 0, ivec2(0, 0));
    ivec2 tmpvar_74;
    tmpvar_74.x = int((uint(tmpvar_15.y) % 1024u));
    tmpvar_74.y = int((uint(tmpvar_15.y) / 1024u));
    vec4 tmpvar_75;
    tmpvar_75 = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(0, 0));
    ivec2 tmpvar_76;
    tmpvar_76.x = int((uint(tmpvar_15.z) % 1024u));
    tmpvar_76.y = int((uint(tmpvar_15.z) / 1024u));
    vec4 tmpvar_77;
    tmpvar_77 = texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(0, 0));
    vec4 tmpvar_78;
    tmpvar_78.xy = (tmpvar_73.xy + vec2(0.5, 0.5));
    tmpvar_78.zw = (tmpvar_73.zw - vec2(0.5, 0.5));
    vUv_Y = mix (tmpvar_73.xy, tmpvar_73.zw, f_50);
    vUvBounds_Y = tmpvar_78;
    vec4 tmpvar_79;
    tmpvar_79.xy = (tmpvar_75.xy + vec2(0.5, 0.5));
    tmpvar_79.zw = (tmpvar_75.zw - vec2(0.5, 0.5));
    vUv_U = mix (tmpvar_75.xy, tmpvar_75.zw, f_50);
    vUvBounds_U = tmpvar_79;
    vec4 tmpvar_80;
    tmpvar_80.xy = (tmpvar_77.xy + vec2(0.5, 0.5));
    tmpvar_80.zw = (tmpvar_77.zw - vec2(0.5, 0.5));
    vUv_V = mix (tmpvar_77.xy, tmpvar_77.zw, f_50);
    vUvBounds_V = tmpvar_80;
  } else {
    if (((tmpvar_53 == 0) || (tmpvar_53 == 1))) {
      ivec2 tmpvar_81;
      tmpvar_81.x = int((uint(tmpvar_15.x) % 1024u));
      tmpvar_81.y = int((uint(tmpvar_15.x) / 1024u));
      vec4 tmpvar_82;
      tmpvar_82 = texelFetchOffset (sGpuCache, tmpvar_81, 0, ivec2(0, 0));
      ivec2 tmpvar_83;
      tmpvar_83.x = int((uint(tmpvar_15.y) % 1024u));
      tmpvar_83.y = int((uint(tmpvar_15.y) / 1024u));
      vec4 tmpvar_84;
      tmpvar_84 = texelFetchOffset (sGpuCache, tmpvar_83, 0, ivec2(0, 0));
      vec4 tmpvar_85;
      tmpvar_85.xy = (tmpvar_82.xy + vec2(0.5, 0.5));
      tmpvar_85.zw = (tmpvar_82.zw - vec2(0.5, 0.5));
      vUv_Y = mix (tmpvar_82.xy, tmpvar_82.zw, f_50);
      vUvBounds_Y = tmpvar_85;
      vec4 tmpvar_86;
      tmpvar_86.xy = (tmpvar_84.xy + vec2(0.5, 0.5));
      tmpvar_86.zw = (tmpvar_84.zw - vec2(0.5, 0.5));
      vUv_U = mix (tmpvar_84.xy, tmpvar_84.zw, f_50);
      vUvBounds_U = tmpvar_86;
    } else {
      if ((tmpvar_53 == 3)) {
        ivec2 tmpvar_87;
        tmpvar_87.x = int((uint(tmpvar_15.x) % 1024u));
        tmpvar_87.y = int((uint(tmpvar_15.x) / 1024u));
        vec4 tmpvar_88;
        tmpvar_88 = texelFetchOffset (sGpuCache, tmpvar_87, 0, ivec2(0, 0));
        vec4 tmpvar_89;
        tmpvar_89.xy = (tmpvar_88.xy + vec2(0.5, 0.5));
        tmpvar_89.zw = (tmpvar_88.zw - vec2(0.5, 0.5));
        vUv_Y = mix (tmpvar_88.xy, tmpvar_88.zw, f_50);
        vUvBounds_Y = tmpvar_89;
      };
    };
  };
  v_local_pos = tmpvar_45;
}

#version 150
// brush_yuv_image
// features: ["ALPHA_PASS", "TEXTURE_RECT", "YUV"]

precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
uniform sampler2DRect sColor1;
uniform sampler2DRect sColor2;
flat in vec4 vTransformBounds;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 v_local_pos;
in vec2 vUv_Y;
flat in vec4 vUvBounds_Y;
in vec2 vUv_U;
flat in vec4 vUvBounds_U;
in vec2 vUv_V;
flat in vec4 vUvBounds_V;
flat in vec3 vYcbcrBias;
flat in mat3 vRgbFromDebiasedYcbcr;
flat in ivec2 vFormat;
void main ()
{
  vec4 frag_color_1;
  vec3 ycbcr_sample_2;
  bool tmpvar_3;
  bool tmpvar_4;
  tmpvar_4 = bool(0);
  tmpvar_3 = (2 == vFormat.x);
  if (tmpvar_3) {
    ycbcr_sample_2.x = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).x;
    ycbcr_sample_2.y = texture (sColor1, min (max (vUv_U, vUvBounds_U.xy), vUvBounds_U.zw)).x;
    ycbcr_sample_2.z = texture (sColor2, min (max (vUv_V, vUvBounds_V.xy), vUvBounds_V.zw)).x;
    tmpvar_4 = bool(1);
  };
  tmpvar_3 = (tmpvar_3 || (0 == vFormat.x));
  tmpvar_3 = (tmpvar_3 || (1 == vFormat.x));
  tmpvar_3 = (tmpvar_3 && !(tmpvar_4));
  if (tmpvar_3) {
    ycbcr_sample_2.x = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).x;
    ycbcr_sample_2.yz = texture (sColor1, min (max (vUv_U, vUvBounds_U.xy), vUvBounds_U.zw)).xy;
    tmpvar_4 = bool(1);
  };
  tmpvar_3 = (tmpvar_3 || (3 == vFormat.x));
  tmpvar_3 = (tmpvar_3 && !(tmpvar_4));
  if (tmpvar_3) {
    ycbcr_sample_2 = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).yzx;
    tmpvar_4 = bool(1);
  };
  tmpvar_3 = !(tmpvar_4);
  if (tmpvar_3) {
    ycbcr_sample_2 = vec3(0.0, 0.0, 0.0);
    tmpvar_4 = bool(1);
  };
  vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = (vRgbFromDebiasedYcbcr * (ycbcr_sample_2 - vYcbcrBias));
  vec2 tmpvar_6;
  tmpvar_6 = (max ((vTransformBounds.xy - v_local_pos), (v_local_pos - vTransformBounds.zw)) / (abs(
    dFdx(v_local_pos)
  ) + abs(
    dFdy(v_local_pos)
  )));
  frag_color_1 = (tmpvar_5 * min (max (
    (0.5 - max (tmpvar_6.x, tmpvar_6.y))
  , 0.0), 1.0));
  float tmpvar_7;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_7 = 1.0;
  } else {
    vec2 tmpvar_8;
    tmpvar_8 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_9;
    tmpvar_9.xy = greaterThanEqual (tmpvar_8, vClipMaskUvBounds.xy);
    tmpvar_9.zw = lessThan (tmpvar_8, vClipMaskUvBounds.zw);
    bool tmpvar_10;
    tmpvar_10 = (tmpvar_9 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_10)) {
      tmpvar_7 = 0.0;
    } else {
      tmpvar_7 = texelFetch (sClipMask, ivec2(tmpvar_8), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_7);
  oFragColor = frag_color_1;
}

brush_yuv_image_DEBUG_OVERDRAW_TEXTURE_2D_YUV#version 150
// brush_yuv_image
// features: ["DEBUG_OVERDRAW", "TEXTURE_2D", "YUV"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sColor2;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 vUv_Y;
flat out vec4 vUvBounds_Y;
out vec2 vUv_U;
flat out vec4 vUvBounds_U;
out vec2 vUv_V;
flat out vec4 vUvBounds_V;
flat out vec3 vYcbcrBias;
flat out mat3 vRgbFromDebiasedYcbcr;
flat out ivec2 vFormat;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 1) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  vec2 f_40;
  f_40 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  ivec2 tmpvar_41;
  tmpvar_41.x = int((uint(tmpvar_11.y) % 1024u));
  tmpvar_41.y = int((uint(tmpvar_11.y) / 1024u));
  vec4 tmpvar_42;
  tmpvar_42 = texelFetch (sGpuCache, tmpvar_41, 0);
  int tmpvar_43;
  tmpvar_43 = int(tmpvar_42.z);
  int tmpvar_44;
  int tmpvar_45;
  tmpvar_44 = int(tmpvar_42.x);
  tmpvar_45 = int(tmpvar_42.y);
  mat3 tmpvar_46;
  vec4 tmpvar_47;
  float channel_max_48;
  channel_max_48 = 255.0;
  if ((8 < tmpvar_44)) {
    if ((tmpvar_43 == 1)) {
      channel_max_48 = float(((1 << tmpvar_44) - 1));
    } else {
      channel_max_48 = 65535.0;
    };
  };
  if ((tmpvar_45 == 0)) {
    tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
    tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
      (tmpvar_44 - 8)
    )) / channel_max_48);
  } else {
    if ((tmpvar_45 == 1)) {
      float tmpvar_49;
      tmpvar_49 = (float((
        (1 << tmpvar_44)
       - 1)) / channel_max_48);
      vec4 tmpvar_50;
      tmpvar_50.xy = vec2(0.0, 0.0);
      tmpvar_50.z = tmpvar_49;
      tmpvar_50.w = tmpvar_49;
      vec4 tmpvar_51;
      tmpvar_51.x = 0.0;
      tmpvar_51.y = (vec4((ivec4(16, 128, 235, 240) << 
        (tmpvar_44 - 8)
      )) / channel_max_48).y;
      tmpvar_51.zw = tmpvar_50.zw;
      tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
      tmpvar_47 = tmpvar_51;
    } else {
      if ((tmpvar_45 == 2)) {
        tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
        tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
          (tmpvar_44 - 8)
        )) / channel_max_48);
      } else {
        if ((tmpvar_45 == 3)) {
          float tmpvar_52;
          tmpvar_52 = (float((
            (1 << tmpvar_44)
           - 1)) / channel_max_48);
          vec4 tmpvar_53;
          tmpvar_53.xy = vec2(0.0, 0.0);
          tmpvar_53.z = tmpvar_52;
          tmpvar_53.w = tmpvar_52;
          vec4 tmpvar_54;
          tmpvar_54.x = 0.0;
          tmpvar_54.y = (vec4((ivec4(16, 128, 235, 240) << 
            (tmpvar_44 - 8)
          )) / channel_max_48).y;
          tmpvar_54.zw = tmpvar_53.zw;
          tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
          tmpvar_47 = tmpvar_54;
        } else {
          if ((tmpvar_45 == 4)) {
            tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
            tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
              (tmpvar_44 - 8)
            )) / channel_max_48);
          } else {
            if ((tmpvar_45 == 5)) {
              float tmpvar_55;
              tmpvar_55 = (float((
                (1 << tmpvar_44)
               - 1)) / channel_max_48);
              vec4 tmpvar_56;
              tmpvar_56.xy = vec2(0.0, 0.0);
              tmpvar_56.z = tmpvar_55;
              tmpvar_56.w = tmpvar_55;
              vec4 tmpvar_57;
              tmpvar_57.x = 0.0;
              tmpvar_57.y = (vec4((ivec4(16, 128, 235, 240) << 
                (tmpvar_44 - 8)
              )) / channel_max_48).y;
              tmpvar_57.zw = tmpvar_56.zw;
              tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
              tmpvar_47 = tmpvar_57;
            } else {
              float tmpvar_58;
              tmpvar_58 = (float((
                (1 << tmpvar_44)
               - 1)) / channel_max_48);
              vec4 tmpvar_59;
              tmpvar_59.xy = vec2(0.0, 0.0);
              tmpvar_59.z = tmpvar_58;
              tmpvar_59.w = tmpvar_58;
              tmpvar_46 = mat3(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0);
              tmpvar_47 = tmpvar_59;
            };
          };
        };
      };
    };
  };
  vec2 tmpvar_60;
  tmpvar_60 = (1.0/((tmpvar_47.zw - tmpvar_47.xy)));
  mat3 tmpvar_61;
  tmpvar_61[uint(0)].x = tmpvar_60.x;
  tmpvar_61[uint(0)].y = 0.0;
  tmpvar_61[uint(0)].z = 0.0;
  tmpvar_61[1u].x = 0.0;
  tmpvar_61[1u].y = tmpvar_60.y;
  tmpvar_61[1u].z = 0.0;
  tmpvar_61[2u].x = 0.0;
  tmpvar_61[2u].y = 0.0;
  tmpvar_61[2u].z = tmpvar_60.y;
  vYcbcrBias = tmpvar_47.xyy;
  vRgbFromDebiasedYcbcr = (tmpvar_46 * tmpvar_61);
  vFormat.x = tmpvar_43;
  if (((tmpvar_43 == 2) || (tmpvar_43 == 99))) {
    ivec2 tmpvar_62;
    tmpvar_62.x = int((uint(tmpvar_12.x) % 1024u));
    tmpvar_62.y = int((uint(tmpvar_12.x) / 1024u));
    vec4 tmpvar_63;
    tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_62, 0, ivec2(0, 0));
    ivec2 tmpvar_64;
    tmpvar_64.x = int((uint(tmpvar_12.y) % 1024u));
    tmpvar_64.y = int((uint(tmpvar_12.y) / 1024u));
    vec4 tmpvar_65;
    tmpvar_65 = texelFetchOffset (sGpuCache, tmpvar_64, 0, ivec2(0, 0));
    ivec2 tmpvar_66;
    tmpvar_66.x = int((uint(tmpvar_12.z) % 1024u));
    tmpvar_66.y = int((uint(tmpvar_12.z) / 1024u));
    vec4 tmpvar_67;
    tmpvar_67 = texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(0, 0));
    vec2 tmpvar_68;
    tmpvar_68 = vec2(textureSize (sColor0, 0));
    vec4 tmpvar_69;
    tmpvar_69.xy = (tmpvar_63.xy + vec2(0.5, 0.5));
    tmpvar_69.zw = (tmpvar_63.zw - vec2(0.5, 0.5));
    vUv_Y = (mix (tmpvar_63.xy, tmpvar_63.zw, f_40) / tmpvar_68);
    vUvBounds_Y = (tmpvar_69 / tmpvar_68.xyxy);
    vec2 tmpvar_70;
    tmpvar_70 = vec2(textureSize (sColor1, 0));
    vec4 tmpvar_71;
    tmpvar_71.xy = (tmpvar_65.xy + vec2(0.5, 0.5));
    tmpvar_71.zw = (tmpvar_65.zw - vec2(0.5, 0.5));
    vUv_U = (mix (tmpvar_65.xy, tmpvar_65.zw, f_40) / tmpvar_70);
    vUvBounds_U = (tmpvar_71 / tmpvar_70.xyxy);
    vec2 tmpvar_72;
    tmpvar_72 = vec2(textureSize (sColor2, 0));
    vec4 tmpvar_73;
    tmpvar_73.xy = (tmpvar_67.xy + vec2(0.5, 0.5));
    tmpvar_73.zw = (tmpvar_67.zw - vec2(0.5, 0.5));
    vUv_V = (mix (tmpvar_67.xy, tmpvar_67.zw, f_40) / tmpvar_72);
    vUvBounds_V = (tmpvar_73 / tmpvar_72.xyxy);
  } else {
    if (((tmpvar_43 == 0) || (tmpvar_43 == 1))) {
      ivec2 tmpvar_74;
      tmpvar_74.x = int((uint(tmpvar_12.x) % 1024u));
      tmpvar_74.y = int((uint(tmpvar_12.x) / 1024u));
      vec4 tmpvar_75;
      tmpvar_75 = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(0, 0));
      ivec2 tmpvar_76;
      tmpvar_76.x = int((uint(tmpvar_12.y) % 1024u));
      tmpvar_76.y = int((uint(tmpvar_12.y) / 1024u));
      vec4 tmpvar_77;
      tmpvar_77 = texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(0, 0));
      vec2 tmpvar_78;
      tmpvar_78 = vec2(textureSize (sColor0, 0));
      vec4 tmpvar_79;
      tmpvar_79.xy = (tmpvar_75.xy + vec2(0.5, 0.5));
      tmpvar_79.zw = (tmpvar_75.zw - vec2(0.5, 0.5));
      vUv_Y = (mix (tmpvar_75.xy, tmpvar_75.zw, f_40) / tmpvar_78);
      vUvBounds_Y = (tmpvar_79 / tmpvar_78.xyxy);
      vec2 tmpvar_80;
      tmpvar_80 = vec2(textureSize (sColor1, 0));
      vec4 tmpvar_81;
      tmpvar_81.xy = (tmpvar_77.xy + vec2(0.5, 0.5));
      tmpvar_81.zw = (tmpvar_77.zw - vec2(0.5, 0.5));
      vUv_U = (mix (tmpvar_77.xy, tmpvar_77.zw, f_40) / tmpvar_80);
      vUvBounds_U = (tmpvar_81 / tmpvar_80.xyxy);
    } else {
      if ((tmpvar_43 == 3)) {
        ivec2 tmpvar_82;
        tmpvar_82.x = int((uint(tmpvar_12.x) % 1024u));
        tmpvar_82.y = int((uint(tmpvar_12.x) / 1024u));
        vec4 tmpvar_83;
        tmpvar_83 = texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(0, 0));
        vec2 tmpvar_84;
        tmpvar_84 = vec2(textureSize (sColor0, 0));
        vec4 tmpvar_85;
        tmpvar_85.xy = (tmpvar_83.xy + vec2(0.5, 0.5));
        tmpvar_85.zw = (tmpvar_83.zw - vec2(0.5, 0.5));
        vUv_Y = (mix (tmpvar_83.xy, tmpvar_83.zw, f_40) / tmpvar_84);
        vUvBounds_Y = (tmpvar_85 / tmpvar_84.xyxy);
      };
    };
  };
}

#version 150
// brush_yuv_image
// features: ["DEBUG_OVERDRAW", "TEXTURE_2D", "YUV"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

brush_yuv_image_DEBUG_OVERDRAW_TEXTURE_RECT_YUV#version 150
// brush_yuv_image
// features: ["DEBUG_OVERDRAW", "TEXTURE_RECT", "YUV"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 vUv_Y;
flat out vec4 vUvBounds_Y;
out vec2 vUv_U;
flat out vec4 vUvBounds_U;
out vec2 vUv_V;
flat out vec4 vUvBounds_V;
flat out vec3 vYcbcrBias;
flat out mat3 vRgbFromDebiasedYcbcr;
flat out ivec2 vFormat;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 1) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  vec2 f_40;
  f_40 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  ivec2 tmpvar_41;
  tmpvar_41.x = int((uint(tmpvar_11.y) % 1024u));
  tmpvar_41.y = int((uint(tmpvar_11.y) / 1024u));
  vec4 tmpvar_42;
  tmpvar_42 = texelFetch (sGpuCache, tmpvar_41, 0);
  int tmpvar_43;
  tmpvar_43 = int(tmpvar_42.z);
  int tmpvar_44;
  int tmpvar_45;
  tmpvar_44 = int(tmpvar_42.x);
  tmpvar_45 = int(tmpvar_42.y);
  mat3 tmpvar_46;
  vec4 tmpvar_47;
  float channel_max_48;
  channel_max_48 = 255.0;
  if ((8 < tmpvar_44)) {
    if ((tmpvar_43 == 1)) {
      channel_max_48 = float(((1 << tmpvar_44) - 1));
    } else {
      channel_max_48 = 65535.0;
    };
  };
  if ((tmpvar_45 == 0)) {
    tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
    tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
      (tmpvar_44 - 8)
    )) / channel_max_48);
  } else {
    if ((tmpvar_45 == 1)) {
      float tmpvar_49;
      tmpvar_49 = (float((
        (1 << tmpvar_44)
       - 1)) / channel_max_48);
      vec4 tmpvar_50;
      tmpvar_50.xy = vec2(0.0, 0.0);
      tmpvar_50.z = tmpvar_49;
      tmpvar_50.w = tmpvar_49;
      vec4 tmpvar_51;
      tmpvar_51.x = 0.0;
      tmpvar_51.y = (vec4((ivec4(16, 128, 235, 240) << 
        (tmpvar_44 - 8)
      )) / channel_max_48).y;
      tmpvar_51.zw = tmpvar_50.zw;
      tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
      tmpvar_47 = tmpvar_51;
    } else {
      if ((tmpvar_45 == 2)) {
        tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
        tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
          (tmpvar_44 - 8)
        )) / channel_max_48);
      } else {
        if ((tmpvar_45 == 3)) {
          float tmpvar_52;
          tmpvar_52 = (float((
            (1 << tmpvar_44)
           - 1)) / channel_max_48);
          vec4 tmpvar_53;
          tmpvar_53.xy = vec2(0.0, 0.0);
          tmpvar_53.z = tmpvar_52;
          tmpvar_53.w = tmpvar_52;
          vec4 tmpvar_54;
          tmpvar_54.x = 0.0;
          tmpvar_54.y = (vec4((ivec4(16, 128, 235, 240) << 
            (tmpvar_44 - 8)
          )) / channel_max_48).y;
          tmpvar_54.zw = tmpvar_53.zw;
          tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
          tmpvar_47 = tmpvar_54;
        } else {
          if ((tmpvar_45 == 4)) {
            tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
            tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
              (tmpvar_44 - 8)
            )) / channel_max_48);
          } else {
            if ((tmpvar_45 == 5)) {
              float tmpvar_55;
              tmpvar_55 = (float((
                (1 << tmpvar_44)
               - 1)) / channel_max_48);
              vec4 tmpvar_56;
              tmpvar_56.xy = vec2(0.0, 0.0);
              tmpvar_56.z = tmpvar_55;
              tmpvar_56.w = tmpvar_55;
              vec4 tmpvar_57;
              tmpvar_57.x = 0.0;
              tmpvar_57.y = (vec4((ivec4(16, 128, 235, 240) << 
                (tmpvar_44 - 8)
              )) / channel_max_48).y;
              tmpvar_57.zw = tmpvar_56.zw;
              tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
              tmpvar_47 = tmpvar_57;
            } else {
              float tmpvar_58;
              tmpvar_58 = (float((
                (1 << tmpvar_44)
               - 1)) / channel_max_48);
              vec4 tmpvar_59;
              tmpvar_59.xy = vec2(0.0, 0.0);
              tmpvar_59.z = tmpvar_58;
              tmpvar_59.w = tmpvar_58;
              tmpvar_46 = mat3(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0);
              tmpvar_47 = tmpvar_59;
            };
          };
        };
      };
    };
  };
  vec2 tmpvar_60;
  tmpvar_60 = (1.0/((tmpvar_47.zw - tmpvar_47.xy)));
  mat3 tmpvar_61;
  tmpvar_61[uint(0)].x = tmpvar_60.x;
  tmpvar_61[uint(0)].y = 0.0;
  tmpvar_61[uint(0)].z = 0.0;
  tmpvar_61[1u].x = 0.0;
  tmpvar_61[1u].y = tmpvar_60.y;
  tmpvar_61[1u].z = 0.0;
  tmpvar_61[2u].x = 0.0;
  tmpvar_61[2u].y = 0.0;
  tmpvar_61[2u].z = tmpvar_60.y;
  vYcbcrBias = tmpvar_47.xyy;
  vRgbFromDebiasedYcbcr = (tmpvar_46 * tmpvar_61);
  vFormat.x = tmpvar_43;
  if (((tmpvar_43 == 2) || (tmpvar_43 == 99))) {
    ivec2 tmpvar_62;
    tmpvar_62.x = int((uint(tmpvar_12.x) % 1024u));
    tmpvar_62.y = int((uint(tmpvar_12.x) / 1024u));
    vec4 tmpvar_63;
    tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_62, 0, ivec2(0, 0));
    ivec2 tmpvar_64;
    tmpvar_64.x = int((uint(tmpvar_12.y) % 1024u));
    tmpvar_64.y = int((uint(tmpvar_12.y) / 1024u));
    vec4 tmpvar_65;
    tmpvar_65 = texelFetchOffset (sGpuCache, tmpvar_64, 0, ivec2(0, 0));
    ivec2 tmpvar_66;
    tmpvar_66.x = int((uint(tmpvar_12.z) % 1024u));
    tmpvar_66.y = int((uint(tmpvar_12.z) / 1024u));
    vec4 tmpvar_67;
    tmpvar_67 = texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(0, 0));
    vec4 tmpvar_68;
    tmpvar_68.xy = (tmpvar_63.xy + vec2(0.5, 0.5));
    tmpvar_68.zw = (tmpvar_63.zw - vec2(0.5, 0.5));
    vUv_Y = mix (tmpvar_63.xy, tmpvar_63.zw, f_40);
    vUvBounds_Y = tmpvar_68;
    vec4 tmpvar_69;
    tmpvar_69.xy = (tmpvar_65.xy + vec2(0.5, 0.5));
    tmpvar_69.zw = (tmpvar_65.zw - vec2(0.5, 0.5));
    vUv_U = mix (tmpvar_65.xy, tmpvar_65.zw, f_40);
    vUvBounds_U = tmpvar_69;
    vec4 tmpvar_70;
    tmpvar_70.xy = (tmpvar_67.xy + vec2(0.5, 0.5));
    tmpvar_70.zw = (tmpvar_67.zw - vec2(0.5, 0.5));
    vUv_V = mix (tmpvar_67.xy, tmpvar_67.zw, f_40);
    vUvBounds_V = tmpvar_70;
  } else {
    if (((tmpvar_43 == 0) || (tmpvar_43 == 1))) {
      ivec2 tmpvar_71;
      tmpvar_71.x = int((uint(tmpvar_12.x) % 1024u));
      tmpvar_71.y = int((uint(tmpvar_12.x) / 1024u));
      vec4 tmpvar_72;
      tmpvar_72 = texelFetchOffset (sGpuCache, tmpvar_71, 0, ivec2(0, 0));
      ivec2 tmpvar_73;
      tmpvar_73.x = int((uint(tmpvar_12.y) % 1024u));
      tmpvar_73.y = int((uint(tmpvar_12.y) / 1024u));
      vec4 tmpvar_74;
      tmpvar_74 = texelFetchOffset (sGpuCache, tmpvar_73, 0, ivec2(0, 0));
      vec4 tmpvar_75;
      tmpvar_75.xy = (tmpvar_72.xy + vec2(0.5, 0.5));
      tmpvar_75.zw = (tmpvar_72.zw - vec2(0.5, 0.5));
      vUv_Y = mix (tmpvar_72.xy, tmpvar_72.zw, f_40);
      vUvBounds_Y = tmpvar_75;
      vec4 tmpvar_76;
      tmpvar_76.xy = (tmpvar_74.xy + vec2(0.5, 0.5));
      tmpvar_76.zw = (tmpvar_74.zw - vec2(0.5, 0.5));
      vUv_U = mix (tmpvar_74.xy, tmpvar_74.zw, f_40);
      vUvBounds_U = tmpvar_76;
    } else {
      if ((tmpvar_43 == 3)) {
        ivec2 tmpvar_77;
        tmpvar_77.x = int((uint(tmpvar_12.x) % 1024u));
        tmpvar_77.y = int((uint(tmpvar_12.x) / 1024u));
        vec4 tmpvar_78;
        tmpvar_78 = texelFetchOffset (sGpuCache, tmpvar_77, 0, ivec2(0, 0));
        vec4 tmpvar_79;
        tmpvar_79.xy = (tmpvar_78.xy + vec2(0.5, 0.5));
        tmpvar_79.zw = (tmpvar_78.zw - vec2(0.5, 0.5));
        vUv_Y = mix (tmpvar_78.xy, tmpvar_78.zw, f_40);
        vUvBounds_Y = tmpvar_79;
      };
    };
  };
}

#version 150
// brush_yuv_image
// features: ["DEBUG_OVERDRAW", "TEXTURE_RECT", "YUV"]

precision highp float;
out vec4 oFragColor;
void main ()
{
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

brush_yuv_image_TEXTURE_2D_YUV#version 150
// brush_yuv_image
// features: ["TEXTURE_2D", "YUV"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sColor2;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 vUv_Y;
flat out vec4 vUvBounds_Y;
out vec2 vUv_U;
flat out vec4 vUvBounds_U;
out vec2 vUv_V;
flat out vec4 vUvBounds_V;
flat out vec3 vYcbcrBias;
flat out mat3 vRgbFromDebiasedYcbcr;
flat out ivec2 vFormat;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 1) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  vec2 f_40;
  f_40 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  ivec2 tmpvar_41;
  tmpvar_41.x = int((uint(tmpvar_11.y) % 1024u));
  tmpvar_41.y = int((uint(tmpvar_11.y) / 1024u));
  vec4 tmpvar_42;
  tmpvar_42 = texelFetch (sGpuCache, tmpvar_41, 0);
  int tmpvar_43;
  tmpvar_43 = int(tmpvar_42.z);
  int tmpvar_44;
  int tmpvar_45;
  tmpvar_44 = int(tmpvar_42.x);
  tmpvar_45 = int(tmpvar_42.y);
  mat3 tmpvar_46;
  vec4 tmpvar_47;
  float channel_max_48;
  channel_max_48 = 255.0;
  if ((8 < tmpvar_44)) {
    if ((tmpvar_43 == 1)) {
      channel_max_48 = float(((1 << tmpvar_44) - 1));
    } else {
      channel_max_48 = 65535.0;
    };
  };
  if ((tmpvar_45 == 0)) {
    tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
    tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
      (tmpvar_44 - 8)
    )) / channel_max_48);
  } else {
    if ((tmpvar_45 == 1)) {
      float tmpvar_49;
      tmpvar_49 = (float((
        (1 << tmpvar_44)
       - 1)) / channel_max_48);
      vec4 tmpvar_50;
      tmpvar_50.xy = vec2(0.0, 0.0);
      tmpvar_50.z = tmpvar_49;
      tmpvar_50.w = tmpvar_49;
      vec4 tmpvar_51;
      tmpvar_51.x = 0.0;
      tmpvar_51.y = (vec4((ivec4(16, 128, 235, 240) << 
        (tmpvar_44 - 8)
      )) / channel_max_48).y;
      tmpvar_51.zw = tmpvar_50.zw;
      tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
      tmpvar_47 = tmpvar_51;
    } else {
      if ((tmpvar_45 == 2)) {
        tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
        tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
          (tmpvar_44 - 8)
        )) / channel_max_48);
      } else {
        if ((tmpvar_45 == 3)) {
          float tmpvar_52;
          tmpvar_52 = (float((
            (1 << tmpvar_44)
           - 1)) / channel_max_48);
          vec4 tmpvar_53;
          tmpvar_53.xy = vec2(0.0, 0.0);
          tmpvar_53.z = tmpvar_52;
          tmpvar_53.w = tmpvar_52;
          vec4 tmpvar_54;
          tmpvar_54.x = 0.0;
          tmpvar_54.y = (vec4((ivec4(16, 128, 235, 240) << 
            (tmpvar_44 - 8)
          )) / channel_max_48).y;
          tmpvar_54.zw = tmpvar_53.zw;
          tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
          tmpvar_47 = tmpvar_54;
        } else {
          if ((tmpvar_45 == 4)) {
            tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
            tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
              (tmpvar_44 - 8)
            )) / channel_max_48);
          } else {
            if ((tmpvar_45 == 5)) {
              float tmpvar_55;
              tmpvar_55 = (float((
                (1 << tmpvar_44)
               - 1)) / channel_max_48);
              vec4 tmpvar_56;
              tmpvar_56.xy = vec2(0.0, 0.0);
              tmpvar_56.z = tmpvar_55;
              tmpvar_56.w = tmpvar_55;
              vec4 tmpvar_57;
              tmpvar_57.x = 0.0;
              tmpvar_57.y = (vec4((ivec4(16, 128, 235, 240) << 
                (tmpvar_44 - 8)
              )) / channel_max_48).y;
              tmpvar_57.zw = tmpvar_56.zw;
              tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
              tmpvar_47 = tmpvar_57;
            } else {
              float tmpvar_58;
              tmpvar_58 = (float((
                (1 << tmpvar_44)
               - 1)) / channel_max_48);
              vec4 tmpvar_59;
              tmpvar_59.xy = vec2(0.0, 0.0);
              tmpvar_59.z = tmpvar_58;
              tmpvar_59.w = tmpvar_58;
              tmpvar_46 = mat3(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0);
              tmpvar_47 = tmpvar_59;
            };
          };
        };
      };
    };
  };
  vec2 tmpvar_60;
  tmpvar_60 = (1.0/((tmpvar_47.zw - tmpvar_47.xy)));
  mat3 tmpvar_61;
  tmpvar_61[uint(0)].x = tmpvar_60.x;
  tmpvar_61[uint(0)].y = 0.0;
  tmpvar_61[uint(0)].z = 0.0;
  tmpvar_61[1u].x = 0.0;
  tmpvar_61[1u].y = tmpvar_60.y;
  tmpvar_61[1u].z = 0.0;
  tmpvar_61[2u].x = 0.0;
  tmpvar_61[2u].y = 0.0;
  tmpvar_61[2u].z = tmpvar_60.y;
  vYcbcrBias = tmpvar_47.xyy;
  vRgbFromDebiasedYcbcr = (tmpvar_46 * tmpvar_61);
  vFormat.x = tmpvar_43;
  if (((tmpvar_43 == 2) || (tmpvar_43 == 99))) {
    ivec2 tmpvar_62;
    tmpvar_62.x = int((uint(tmpvar_12.x) % 1024u));
    tmpvar_62.y = int((uint(tmpvar_12.x) / 1024u));
    vec4 tmpvar_63;
    tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_62, 0, ivec2(0, 0));
    ivec2 tmpvar_64;
    tmpvar_64.x = int((uint(tmpvar_12.y) % 1024u));
    tmpvar_64.y = int((uint(tmpvar_12.y) / 1024u));
    vec4 tmpvar_65;
    tmpvar_65 = texelFetchOffset (sGpuCache, tmpvar_64, 0, ivec2(0, 0));
    ivec2 tmpvar_66;
    tmpvar_66.x = int((uint(tmpvar_12.z) % 1024u));
    tmpvar_66.y = int((uint(tmpvar_12.z) / 1024u));
    vec4 tmpvar_67;
    tmpvar_67 = texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(0, 0));
    vec2 tmpvar_68;
    tmpvar_68 = vec2(textureSize (sColor0, 0));
    vec4 tmpvar_69;
    tmpvar_69.xy = (tmpvar_63.xy + vec2(0.5, 0.5));
    tmpvar_69.zw = (tmpvar_63.zw - vec2(0.5, 0.5));
    vUv_Y = (mix (tmpvar_63.xy, tmpvar_63.zw, f_40) / tmpvar_68);
    vUvBounds_Y = (tmpvar_69 / tmpvar_68.xyxy);
    vec2 tmpvar_70;
    tmpvar_70 = vec2(textureSize (sColor1, 0));
    vec4 tmpvar_71;
    tmpvar_71.xy = (tmpvar_65.xy + vec2(0.5, 0.5));
    tmpvar_71.zw = (tmpvar_65.zw - vec2(0.5, 0.5));
    vUv_U = (mix (tmpvar_65.xy, tmpvar_65.zw, f_40) / tmpvar_70);
    vUvBounds_U = (tmpvar_71 / tmpvar_70.xyxy);
    vec2 tmpvar_72;
    tmpvar_72 = vec2(textureSize (sColor2, 0));
    vec4 tmpvar_73;
    tmpvar_73.xy = (tmpvar_67.xy + vec2(0.5, 0.5));
    tmpvar_73.zw = (tmpvar_67.zw - vec2(0.5, 0.5));
    vUv_V = (mix (tmpvar_67.xy, tmpvar_67.zw, f_40) / tmpvar_72);
    vUvBounds_V = (tmpvar_73 / tmpvar_72.xyxy);
  } else {
    if (((tmpvar_43 == 0) || (tmpvar_43 == 1))) {
      ivec2 tmpvar_74;
      tmpvar_74.x = int((uint(tmpvar_12.x) % 1024u));
      tmpvar_74.y = int((uint(tmpvar_12.x) / 1024u));
      vec4 tmpvar_75;
      tmpvar_75 = texelFetchOffset (sGpuCache, tmpvar_74, 0, ivec2(0, 0));
      ivec2 tmpvar_76;
      tmpvar_76.x = int((uint(tmpvar_12.y) % 1024u));
      tmpvar_76.y = int((uint(tmpvar_12.y) / 1024u));
      vec4 tmpvar_77;
      tmpvar_77 = texelFetchOffset (sGpuCache, tmpvar_76, 0, ivec2(0, 0));
      vec2 tmpvar_78;
      tmpvar_78 = vec2(textureSize (sColor0, 0));
      vec4 tmpvar_79;
      tmpvar_79.xy = (tmpvar_75.xy + vec2(0.5, 0.5));
      tmpvar_79.zw = (tmpvar_75.zw - vec2(0.5, 0.5));
      vUv_Y = (mix (tmpvar_75.xy, tmpvar_75.zw, f_40) / tmpvar_78);
      vUvBounds_Y = (tmpvar_79 / tmpvar_78.xyxy);
      vec2 tmpvar_80;
      tmpvar_80 = vec2(textureSize (sColor1, 0));
      vec4 tmpvar_81;
      tmpvar_81.xy = (tmpvar_77.xy + vec2(0.5, 0.5));
      tmpvar_81.zw = (tmpvar_77.zw - vec2(0.5, 0.5));
      vUv_U = (mix (tmpvar_77.xy, tmpvar_77.zw, f_40) / tmpvar_80);
      vUvBounds_U = (tmpvar_81 / tmpvar_80.xyxy);
    } else {
      if ((tmpvar_43 == 3)) {
        ivec2 tmpvar_82;
        tmpvar_82.x = int((uint(tmpvar_12.x) % 1024u));
        tmpvar_82.y = int((uint(tmpvar_12.x) / 1024u));
        vec4 tmpvar_83;
        tmpvar_83 = texelFetchOffset (sGpuCache, tmpvar_82, 0, ivec2(0, 0));
        vec2 tmpvar_84;
        tmpvar_84 = vec2(textureSize (sColor0, 0));
        vec4 tmpvar_85;
        tmpvar_85.xy = (tmpvar_83.xy + vec2(0.5, 0.5));
        tmpvar_85.zw = (tmpvar_83.zw - vec2(0.5, 0.5));
        vUv_Y = (mix (tmpvar_83.xy, tmpvar_83.zw, f_40) / tmpvar_84);
        vUvBounds_Y = (tmpvar_85 / tmpvar_84.xyxy);
      };
    };
  };
}

#version 150
// brush_yuv_image
// features: ["TEXTURE_2D", "YUV"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sColor2;
in vec2 vUv_Y;
flat in vec4 vUvBounds_Y;
in vec2 vUv_U;
flat in vec4 vUvBounds_U;
in vec2 vUv_V;
flat in vec4 vUvBounds_V;
flat in vec3 vYcbcrBias;
flat in mat3 vRgbFromDebiasedYcbcr;
flat in ivec2 vFormat;
void main ()
{
  vec3 ycbcr_sample_1;
  bool tmpvar_2;
  bool tmpvar_3;
  tmpvar_3 = bool(0);
  tmpvar_2 = (2 == vFormat.x);
  if (tmpvar_2) {
    ycbcr_sample_1.x = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).x;
    ycbcr_sample_1.y = texture (sColor1, min (max (vUv_U, vUvBounds_U.xy), vUvBounds_U.zw)).x;
    ycbcr_sample_1.z = texture (sColor2, min (max (vUv_V, vUvBounds_V.xy), vUvBounds_V.zw)).x;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (0 == vFormat.x));
  tmpvar_2 = (tmpvar_2 || (1 == vFormat.x));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    ycbcr_sample_1.x = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).x;
    ycbcr_sample_1.yz = texture (sColor1, min (max (vUv_U, vUvBounds_U.xy), vUvBounds_U.zw)).xy;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (3 == vFormat.x));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    ycbcr_sample_1 = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).yzx;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = !(tmpvar_3);
  if (tmpvar_2) {
    ycbcr_sample_1 = vec3(0.0, 0.0, 0.0);
    tmpvar_3 = bool(1);
  };
  vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = (vRgbFromDebiasedYcbcr * (ycbcr_sample_1 - vYcbcrBias));
  oFragColor = tmpvar_4;
}

#version 150
// brush_yuv_image
// features: ["TEXTURE_RECT", "YUV"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 vUv_Y;
flat out vec4 vUvBounds_Y;
out vec2 vUv_U;
flat out vec4 vUvBounds_U;
out vec2 vUv_V;
flat out vec4 vUvBounds_V;
flat out vec3 vYcbcrBias;
flat out mat3 vRgbFromDebiasedYcbcr;
flat out ivec2 vFormat;
void main ()
{
  int instance_picture_task_address_1;
  int instance_segment_index_2;
  int instance_flags_3;
  instance_picture_task_address_1 = (aData.y >> 16);
  instance_segment_index_2 = (aData.z & 65535);
  instance_flags_3 = (aData.z >> 16);
  float ph_z_4;
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  vec4 tmpvar_7;
  tmpvar_7 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(1, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = tmpvar_6.xy;
  tmpvar_9 = tmpvar_6.zw;
  ivec2 tmpvar_10;
  tmpvar_10.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_10.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(0, 0));
  ivec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_10, 0, ivec2(1, 0));
  ph_z_4 = float(tmpvar_11.x);
  mat4 transform_m_13;
  bool transform_is_axis_aligned_14;
  transform_is_axis_aligned_14 = ((tmpvar_11.z >> 24) == 0);
  int tmpvar_15;
  tmpvar_15 = (tmpvar_11.z & 16777215);
  ivec2 tmpvar_16;
  tmpvar_16.x = int((8u * (
    uint(tmpvar_15)
   % 128u)));
  tmpvar_16.y = int((uint(tmpvar_15) / 128u));
  transform_m_13[0] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(0, 0));
  transform_m_13[1] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(1, 0));
  transform_m_13[2] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(2, 0));
  transform_m_13[3] = texelFetchOffset (sTransformPalette, tmpvar_16, 0, ivec2(3, 0));
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(instance_picture_task_address_1)
   % 512u)));
  tmpvar_17.y = int((uint(instance_picture_task_address_1) / 512u));
  vec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(0, 0));
  vec4 tmpvar_19;
  tmpvar_19 = texelFetchOffset (sRenderTasks, tmpvar_17, 0, ivec2(1, 0));
  vec2 tmpvar_20;
  vec2 tmpvar_21;
  tmpvar_20 = tmpvar_7.xy;
  tmpvar_21 = tmpvar_7.zw;
  vec2 adjusted_segment_rect_p0_22;
  vec2 adjusted_segment_rect_p1_23;
  vec2 segment_rect_p0_24;
  vec2 segment_rect_p1_25;
  int tmpvar_26;
  tmpvar_26 = ((instance_flags_3 >> 12) & 15);
  int tmpvar_27;
  tmpvar_27 = (instance_flags_3 & 4095);
  if ((instance_segment_index_2 == 65535)) {
    segment_rect_p0_24 = tmpvar_8;
    segment_rect_p1_25 = tmpvar_9;
  } else {
    int tmpvar_28;
    tmpvar_28 = ((tmpvar_11.y + 1) + (instance_segment_index_2 * 2));
    ivec2 tmpvar_29;
    tmpvar_29.x = int((uint(tmpvar_28) % 1024u));
    tmpvar_29.y = int((uint(tmpvar_28) / 1024u));
    vec4 tmpvar_30;
    tmpvar_30 = texelFetchOffset (sGpuCache, tmpvar_29, 0, ivec2(0, 0));
    segment_rect_p0_24 = (tmpvar_30.xy + tmpvar_6.xy);
    segment_rect_p1_25 = (tmpvar_30.zw + tmpvar_6.xy);
  };
  adjusted_segment_rect_p0_22 = segment_rect_p0_24;
  adjusted_segment_rect_p1_23 = segment_rect_p1_25;
  if ((!(transform_is_axis_aligned_14) || ((tmpvar_27 & 256) != 0))) {
    vec2 tmpvar_31;
    tmpvar_31 = min (max (segment_rect_p0_24, tmpvar_7.xy), tmpvar_7.zw);
    vec2 tmpvar_32;
    tmpvar_32 = min (max (segment_rect_p1_25, tmpvar_7.xy), tmpvar_7.zw);
    bvec4 tmpvar_33;
    tmpvar_33.x = bool((tmpvar_26 & 1));
    tmpvar_33.y = bool((tmpvar_26 & 2));
    tmpvar_33.z = bool((tmpvar_26 & 4));
    tmpvar_33.w = bool((tmpvar_26 & 8));
    vec4 tmpvar_34;
    tmpvar_34.xy = tmpvar_31;
    tmpvar_34.zw = tmpvar_32;
    vTransformBounds = mix(vec4(-1e+16, -1e+16, 1e+16, 1e+16), tmpvar_34, bvec4(tmpvar_33));
    vec4 tmpvar_35;
    tmpvar_35 = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(2.0, 2.0, 2.0, 2.0), bvec4(tmpvar_33));
    adjusted_segment_rect_p0_22 = (tmpvar_31 - tmpvar_35.xy);
    adjusted_segment_rect_p1_23 = (tmpvar_32 + tmpvar_35.zw);
    tmpvar_20 = vec2(-1e+16, -1e+16);
    tmpvar_21 = vec2(1e+16, 1e+16);
  };
  vec2 tmpvar_36;
  tmpvar_36 = min (max (mix (adjusted_segment_rect_p0_22, adjusted_segment_rect_p1_23, aPosition), tmpvar_20), tmpvar_21);
  vec4 tmpvar_37;
  tmpvar_37.zw = vec2(0.0, 1.0);
  tmpvar_37.xy = tmpvar_36;
  vec4 tmpvar_38;
  tmpvar_38 = (transform_m_13 * tmpvar_37);
  vec4 tmpvar_39;
  tmpvar_39.xy = ((tmpvar_38.xy * tmpvar_19.x) + ((
    -(tmpvar_19.yz)
   + tmpvar_18.xy) * tmpvar_38.w));
  tmpvar_39.z = (ph_z_4 * tmpvar_38.w);
  tmpvar_39.w = tmpvar_38.w;
  gl_Position = (uTransform * tmpvar_39);
  vec2 f_40;
  f_40 = ((tmpvar_36 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  ivec2 tmpvar_41;
  tmpvar_41.x = int((uint(tmpvar_11.y) % 1024u));
  tmpvar_41.y = int((uint(tmpvar_11.y) / 1024u));
  vec4 tmpvar_42;
  tmpvar_42 = texelFetch (sGpuCache, tmpvar_41, 0);
  int tmpvar_43;
  tmpvar_43 = int(tmpvar_42.z);
  int tmpvar_44;
  int tmpvar_45;
  tmpvar_44 = int(tmpvar_42.x);
  tmpvar_45 = int(tmpvar_42.y);
  mat3 tmpvar_46;
  vec4 tmpvar_47;
  float channel_max_48;
  channel_max_48 = 255.0;
  if ((8 < tmpvar_44)) {
    if ((tmpvar_43 == 1)) {
      channel_max_48 = float(((1 << tmpvar_44) - 1));
    } else {
      channel_max_48 = 65535.0;
    };
  };
  if ((tmpvar_45 == 0)) {
    tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
    tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
      (tmpvar_44 - 8)
    )) / channel_max_48);
  } else {
    if ((tmpvar_45 == 1)) {
      float tmpvar_49;
      tmpvar_49 = (float((
        (1 << tmpvar_44)
       - 1)) / channel_max_48);
      vec4 tmpvar_50;
      tmpvar_50.xy = vec2(0.0, 0.0);
      tmpvar_50.z = tmpvar_49;
      tmpvar_50.w = tmpvar_49;
      vec4 tmpvar_51;
      tmpvar_51.x = 0.0;
      tmpvar_51.y = (vec4((ivec4(16, 128, 235, 240) << 
        (tmpvar_44 - 8)
      )) / channel_max_48).y;
      tmpvar_51.zw = tmpvar_50.zw;
      tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
      tmpvar_47 = tmpvar_51;
    } else {
      if ((tmpvar_45 == 2)) {
        tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
        tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
          (tmpvar_44 - 8)
        )) / channel_max_48);
      } else {
        if ((tmpvar_45 == 3)) {
          float tmpvar_52;
          tmpvar_52 = (float((
            (1 << tmpvar_44)
           - 1)) / channel_max_48);
          vec4 tmpvar_53;
          tmpvar_53.xy = vec2(0.0, 0.0);
          tmpvar_53.z = tmpvar_52;
          tmpvar_53.w = tmpvar_52;
          vec4 tmpvar_54;
          tmpvar_54.x = 0.0;
          tmpvar_54.y = (vec4((ivec4(16, 128, 235, 240) << 
            (tmpvar_44 - 8)
          )) / channel_max_48).y;
          tmpvar_54.zw = tmpvar_53.zw;
          tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
          tmpvar_47 = tmpvar_54;
        } else {
          if ((tmpvar_45 == 4)) {
            tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
            tmpvar_47 = (vec4((ivec4(16, 128, 235, 240) << 
              (tmpvar_44 - 8)
            )) / channel_max_48);
          } else {
            if ((tmpvar_45 == 5)) {
              float tmpvar_55;
              tmpvar_55 = (float((
                (1 << tmpvar_44)
               - 1)) / channel_max_48);
              vec4 tmpvar_56;
              tmpvar_56.xy = vec2(0.0, 0.0);
              tmpvar_56.z = tmpvar_55;
              tmpvar_56.w = tmpvar_55;
              vec4 tmpvar_57;
              tmpvar_57.x = 0.0;
              tmpvar_57.y = (vec4((ivec4(16, 128, 235, 240) << 
                (tmpvar_44 - 8)
              )) / channel_max_48).y;
              tmpvar_57.zw = tmpvar_56.zw;
              tmpvar_46 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
              tmpvar_47 = tmpvar_57;
            } else {
              float tmpvar_58;
              tmpvar_58 = (float((
                (1 << tmpvar_44)
               - 1)) / channel_max_48);
              vec4 tmpvar_59;
              tmpvar_59.xy = vec2(0.0, 0.0);
              tmpvar_59.z = tmpvar_58;
              tmpvar_59.w = tmpvar_58;
              tmpvar_46 = mat3(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0);
              tmpvar_47 = tmpvar_59;
            };
          };
        };
      };
    };
  };
  vec2 tmpvar_60;
  tmpvar_60 = (1.0/((tmpvar_47.zw - tmpvar_47.xy)));
  mat3 tmpvar_61;
  tmpvar_61[uint(0)].x = tmpvar_60.x;
  tmpvar_61[uint(0)].y = 0.0;
  tmpvar_61[uint(0)].z = 0.0;
  tmpvar_61[1u].x = 0.0;
  tmpvar_61[1u].y = tmpvar_60.y;
  tmpvar_61[1u].z = 0.0;
  tmpvar_61[2u].x = 0.0;
  tmpvar_61[2u].y = 0.0;
  tmpvar_61[2u].z = tmpvar_60.y;
  vYcbcrBias = tmpvar_47.xyy;
  vRgbFromDebiasedYcbcr = (tmpvar_46 * tmpvar_61);
  vFormat.x = tmpvar_43;
  if (((tmpvar_43 == 2) || (tmpvar_43 == 99))) {
    ivec2 tmpvar_62;
    tmpvar_62.x = int((uint(tmpvar_12.x) % 1024u));
    tmpvar_62.y = int((uint(tmpvar_12.x) / 1024u));
    vec4 tmpvar_63;
    tmpvar_63 = texelFetchOffset (sGpuCache, tmpvar_62, 0, ivec2(0, 0));
    ivec2 tmpvar_64;
    tmpvar_64.x = int((uint(tmpvar_12.y) % 1024u));
    tmpvar_64.y = int((uint(tmpvar_12.y) / 1024u));
    vec4 tmpvar_65;
    tmpvar_65 = texelFetchOffset (sGpuCache, tmpvar_64, 0, ivec2(0, 0));
    ivec2 tmpvar_66;
    tmpvar_66.x = int((uint(tmpvar_12.z) % 1024u));
    tmpvar_66.y = int((uint(tmpvar_12.z) / 1024u));
    vec4 tmpvar_67;
    tmpvar_67 = texelFetchOffset (sGpuCache, tmpvar_66, 0, ivec2(0, 0));
    vec4 tmpvar_68;
    tmpvar_68.xy = (tmpvar_63.xy + vec2(0.5, 0.5));
    tmpvar_68.zw = (tmpvar_63.zw - vec2(0.5, 0.5));
    vUv_Y = mix (tmpvar_63.xy, tmpvar_63.zw, f_40);
    vUvBounds_Y = tmpvar_68;
    vec4 tmpvar_69;
    tmpvar_69.xy = (tmpvar_65.xy + vec2(0.5, 0.5));
    tmpvar_69.zw = (tmpvar_65.zw - vec2(0.5, 0.5));
    vUv_U = mix (tmpvar_65.xy, tmpvar_65.zw, f_40);
    vUvBounds_U = tmpvar_69;
    vec4 tmpvar_70;
    tmpvar_70.xy = (tmpvar_67.xy + vec2(0.5, 0.5));
    tmpvar_70.zw = (tmpvar_67.zw - vec2(0.5, 0.5));
    vUv_V = mix (tmpvar_67.xy, tmpvar_67.zw, f_40);
    vUvBounds_V = tmpvar_70;
  } else {
    if (((tmpvar_43 == 0) || (tmpvar_43 == 1))) {
      ivec2 tmpvar_71;
      tmpvar_71.x = int((uint(tmpvar_12.x) % 1024u));
      tmpvar_71.y = int((uint(tmpvar_12.x) / 1024u));
      vec4 tmpvar_72;
      tmpvar_72 = texelFetchOffset (sGpuCache, tmpvar_71, 0, ivec2(0, 0));
      ivec2 tmpvar_73;
      tmpvar_73.x = int((uint(tmpvar_12.y) % 1024u));
      tmpvar_73.y = int((uint(tmpvar_12.y) / 1024u));
      vec4 tmpvar_74;
      tmpvar_74 = texelFetchOffset (sGpuCache, tmpvar_73, 0, ivec2(0, 0));
      vec4 tmpvar_75;
      tmpvar_75.xy = (tmpvar_72.xy + vec2(0.5, 0.5));
      tmpvar_75.zw = (tmpvar_72.zw - vec2(0.5, 0.5));
      vUv_Y = mix (tmpvar_72.xy, tmpvar_72.zw, f_40);
      vUvBounds_Y = tmpvar_75;
      vec4 tmpvar_76;
      tmpvar_76.xy = (tmpvar_74.xy + vec2(0.5, 0.5));
      tmpvar_76.zw = (tmpvar_74.zw - vec2(0.5, 0.5));
      vUv_U = mix (tmpvar_74.xy, tmpvar_74.zw, f_40);
      vUvBounds_U = tmpvar_76;
    } else {
      if ((tmpvar_43 == 3)) {
        ivec2 tmpvar_77;
        tmpvar_77.x = int((uint(tmpvar_12.x) % 1024u));
        tmpvar_77.y = int((uint(tmpvar_12.x) / 1024u));
        vec4 tmpvar_78;
        tmpvar_78 = texelFetchOffset (sGpuCache, tmpvar_77, 0, ivec2(0, 0));
        vec4 tmpvar_79;
        tmpvar_79.xy = (tmpvar_78.xy + vec2(0.5, 0.5));
        tmpvar_79.zw = (tmpvar_78.zw - vec2(0.5, 0.5));
        vUv_Y = mix (tmpvar_78.xy, tmpvar_78.zw, f_40);
        vUvBounds_Y = tmpvar_79;
      };
    };
  };
}

#version 150
// brush_yuv_image
// features: ["TEXTURE_RECT", "YUV"]

precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
uniform sampler2DRect sColor1;
uniform sampler2DRect sColor2;
in vec2 vUv_Y;
flat in vec4 vUvBounds_Y;
in vec2 vUv_U;
flat in vec4 vUvBounds_U;
in vec2 vUv_V;
flat in vec4 vUvBounds_V;
flat in vec3 vYcbcrBias;
flat in mat3 vRgbFromDebiasedYcbcr;
flat in ivec2 vFormat;
void main ()
{
  vec3 ycbcr_sample_1;
  bool tmpvar_2;
  bool tmpvar_3;
  tmpvar_3 = bool(0);
  tmpvar_2 = (2 == vFormat.x);
  if (tmpvar_2) {
    ycbcr_sample_1.x = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).x;
    ycbcr_sample_1.y = texture (sColor1, min (max (vUv_U, vUvBounds_U.xy), vUvBounds_U.zw)).x;
    ycbcr_sample_1.z = texture (sColor2, min (max (vUv_V, vUvBounds_V.xy), vUvBounds_V.zw)).x;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (0 == vFormat.x));
  tmpvar_2 = (tmpvar_2 || (1 == vFormat.x));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    ycbcr_sample_1.x = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).x;
    ycbcr_sample_1.yz = texture (sColor1, min (max (vUv_U, vUvBounds_U.xy), vUvBounds_U.zw)).xy;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (3 == vFormat.x));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    ycbcr_sample_1 = texture (sColor0, min (max (vUv_Y, vUvBounds_Y.xy), vUvBounds_Y.zw)).yzx;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = !(tmpvar_3);
  if (tmpvar_2) {
    ycbcr_sample_1 = vec3(0.0, 0.0, 0.0);
    tmpvar_3 = bool(1);
  };
  vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = (vRgbFromDebiasedYcbcr * (ycbcr_sample_1 - vYcbcrBias));
  oFragColor = tmpvar_4;
}

composite_FAST_PATH_TEXTURE_2D#version 150
// composite
// features: ["FAST_PATH", "TEXTURE_2D"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
out vec2 vUv;
in vec4 aLocalRect;
in vec4 aDeviceClipRect;
in vec4 aParams;
in vec4 aTransform;
in vec4 aUvRect0;
void main ()
{
  vec4 uvBounds_1;
  vec2 uv_2;
  vec2 tmpvar_3;
  tmpvar_3 = ((aLocalRect.xy * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_4;
  tmpvar_4 = ((aLocalRect.zw * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_5;
  tmpvar_5 = min (max (mix (tmpvar_3, tmpvar_4, aPosition), aDeviceClipRect.xy), aDeviceClipRect.zw);
  vec2 tmpvar_6;
  tmpvar_6 = mix (aUvRect0.xy, aUvRect0.zw, ((tmpvar_5 - tmpvar_3) / (tmpvar_4 - tmpvar_3)));
  uv_2 = tmpvar_6;
  vec4 tmpvar_7;
  tmpvar_7.xy = min (aUvRect0.xy, aUvRect0.zw);
  tmpvar_7.zw = max (aUvRect0.xy, aUvRect0.zw);
  uvBounds_1 = tmpvar_7;
  int tmpvar_8;
  tmpvar_8 = int(aParams.y);
  if ((tmpvar_8 == 1)) {
    vec2 tmpvar_9;
    tmpvar_9 = vec2(textureSize (sColor0, 0));
    uvBounds_1 = (tmpvar_7 + vec4(0.5, 0.5, -0.5, -0.5));
    uv_2 = (tmpvar_6 / tmpvar_9);
    uvBounds_1 = (uvBounds_1 / tmpvar_9.xyxy);
  };
  vUv = uv_2;
  vec4 tmpvar_10;
  tmpvar_10.w = 1.0;
  tmpvar_10.xy = tmpvar_5;
  tmpvar_10.z = aParams.x;
  gl_Position = (uTransform * tmpvar_10);
}

#version 150
// composite
// features: ["FAST_PATH", "TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
in vec2 vUv;
void main ()
{
  oFragColor = texture (sColor0, vUv);
}

#version 150
// composite
// features: ["FAST_PATH", "TEXTURE_RECT"]

uniform mat4 uTransform;
in vec2 aPosition;
out vec2 vUv;
in vec4 aLocalRect;
in vec4 aDeviceClipRect;
in vec4 aParams;
in vec4 aTransform;
in vec4 aUvRect0;
void main ()
{
  vec2 tmpvar_1;
  tmpvar_1 = ((aLocalRect.xy * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_2;
  tmpvar_2 = ((aLocalRect.zw * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_3;
  tmpvar_3 = min (max (mix (tmpvar_1, tmpvar_2, aPosition), aDeviceClipRect.xy), aDeviceClipRect.zw);
  vUv = mix (aUvRect0.xy, aUvRect0.zw, ((tmpvar_3 - tmpvar_1) / (tmpvar_2 - tmpvar_1)));
  vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xy = tmpvar_3;
  tmpvar_4.z = aParams.x;
  gl_Position = (uTransform * tmpvar_4);
}

#version 150
// composite
// features: ["FAST_PATH", "TEXTURE_RECT"]

precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
in vec2 vUv;
void main ()
{
  oFragColor = texture (sColor0, vUv);
}

composite_TEXTURE_2D#version 150
// composite
// features: ["TEXTURE_2D"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
out vec2 vUv;
flat out vec4 vColor;
flat out vec4 vUVBounds;
in vec4 aLocalRect;
in vec4 aDeviceClipRect;
in vec4 aColor;
in vec4 aParams;
in vec4 aTransform;
in vec4 aUvRect0;
void main ()
{
  vec4 uvBounds_1;
  vec2 uv_2;
  vec2 tmpvar_3;
  tmpvar_3 = ((aLocalRect.xy * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_4;
  tmpvar_4 = ((aLocalRect.zw * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_5;
  tmpvar_5 = min (max (mix (tmpvar_3, tmpvar_4, aPosition), aDeviceClipRect.xy), aDeviceClipRect.zw);
  vec2 tmpvar_6;
  tmpvar_6 = mix (aUvRect0.xy, aUvRect0.zw, ((tmpvar_5 - tmpvar_3) / (tmpvar_4 - tmpvar_3)));
  uv_2 = tmpvar_6;
  vec4 tmpvar_7;
  tmpvar_7.xy = min (aUvRect0.xy, aUvRect0.zw);
  tmpvar_7.zw = max (aUvRect0.xy, aUvRect0.zw);
  uvBounds_1 = tmpvar_7;
  int tmpvar_8;
  tmpvar_8 = int(aParams.y);
  if ((tmpvar_8 == 1)) {
    vec2 tmpvar_9;
    tmpvar_9 = vec2(textureSize (sColor0, 0));
    uvBounds_1 = (tmpvar_7 + vec4(0.5, 0.5, -0.5, -0.5));
    uv_2 = (tmpvar_6 / tmpvar_9);
    uvBounds_1 = (uvBounds_1 / tmpvar_9.xyxy);
  };
  vUv = uv_2;
  vUVBounds = uvBounds_1;
  vColor = aColor;
  vec4 tmpvar_10;
  tmpvar_10.w = 1.0;
  tmpvar_10.xy = tmpvar_5;
  tmpvar_10.z = aParams.x;
  gl_Position = (uTransform * tmpvar_10);
}

#version 150
// composite
// features: ["TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
in vec2 vUv;
flat in vec4 vColor;
flat in vec4 vUVBounds;
void main ()
{
  oFragColor = (vColor * texture (sColor0, min (max (vUv, vUVBounds.xy), vUVBounds.zw)));
}

composite_TEXTURE_2D_YUV#version 150
// composite
// features: ["TEXTURE_2D", "YUV"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sColor2;
flat out vec3 vYcbcrBias;
flat out mat3 vRgbFromDebiasedYcbcr;
flat out ivec2 vYuvFormat;
out vec2 vUV_y;
out vec2 vUV_u;
out vec2 vUV_v;
flat out vec4 vUVBounds_y;
flat out vec4 vUVBounds_u;
flat out vec4 vUVBounds_v;
in vec4 aLocalRect;
in vec4 aDeviceClipRect;
in vec4 aParams;
in vec4 aTransform;
in vec4 aUvRect0;
in vec4 aUvRect1;
in vec4 aUvRect2;
void main ()
{
  vec2 uv_1;
  vec2 tmpvar_2;
  tmpvar_2 = ((aLocalRect.xy * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_3;
  tmpvar_3 = ((aLocalRect.zw * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_4;
  tmpvar_4 = min (max (mix (tmpvar_2, tmpvar_3, aPosition), aDeviceClipRect.xy), aDeviceClipRect.zw);
  uv_1 = ((tmpvar_4 - tmpvar_2) / (tmpvar_3 - tmpvar_2));
  int tmpvar_5;
  tmpvar_5 = int(aParams.z);
  int tmpvar_6;
  int tmpvar_7;
  tmpvar_6 = int(aParams.w);
  tmpvar_7 = int(aParams.y);
  mat3 tmpvar_8;
  vec4 tmpvar_9;
  float channel_max_10;
  channel_max_10 = 255.0;
  if ((8 < tmpvar_6)) {
    if ((tmpvar_5 == 1)) {
      channel_max_10 = float(((1 << tmpvar_6) - 1));
    } else {
      channel_max_10 = 65535.0;
    };
  };
  if ((tmpvar_7 == 0)) {
    tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
    tmpvar_9 = (vec4((ivec4(16, 128, 235, 240) << 
      (tmpvar_6 - 8)
    )) / channel_max_10);
  } else {
    if ((tmpvar_7 == 1)) {
      float tmpvar_11;
      tmpvar_11 = (float((
        (1 << tmpvar_6)
       - 1)) / channel_max_10);
      vec4 tmpvar_12;
      tmpvar_12.xy = vec2(0.0, 0.0);
      tmpvar_12.z = tmpvar_11;
      tmpvar_12.w = tmpvar_11;
      vec4 tmpvar_13;
      tmpvar_13.x = 0.0;
      tmpvar_13.y = (vec4((ivec4(16, 128, 235, 240) << 
        (tmpvar_6 - 8)
      )) / channel_max_10).y;
      tmpvar_13.zw = tmpvar_12.zw;
      tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
      tmpvar_9 = tmpvar_13;
    } else {
      if ((tmpvar_7 == 2)) {
        tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
        tmpvar_9 = (vec4((ivec4(16, 128, 235, 240) << 
          (tmpvar_6 - 8)
        )) / channel_max_10);
      } else {
        if ((tmpvar_7 == 3)) {
          float tmpvar_14;
          tmpvar_14 = (float((
            (1 << tmpvar_6)
           - 1)) / channel_max_10);
          vec4 tmpvar_15;
          tmpvar_15.xy = vec2(0.0, 0.0);
          tmpvar_15.z = tmpvar_14;
          tmpvar_15.w = tmpvar_14;
          vec4 tmpvar_16;
          tmpvar_16.x = 0.0;
          tmpvar_16.y = (vec4((ivec4(16, 128, 235, 240) << 
            (tmpvar_6 - 8)
          )) / channel_max_10).y;
          tmpvar_16.zw = tmpvar_15.zw;
          tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
          tmpvar_9 = tmpvar_16;
        } else {
          if ((tmpvar_7 == 4)) {
            tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
            tmpvar_9 = (vec4((ivec4(16, 128, 235, 240) << 
              (tmpvar_6 - 8)
            )) / channel_max_10);
          } else {
            if ((tmpvar_7 == 5)) {
              float tmpvar_17;
              tmpvar_17 = (float((
                (1 << tmpvar_6)
               - 1)) / channel_max_10);
              vec4 tmpvar_18;
              tmpvar_18.xy = vec2(0.0, 0.0);
              tmpvar_18.z = tmpvar_17;
              tmpvar_18.w = tmpvar_17;
              vec4 tmpvar_19;
              tmpvar_19.x = 0.0;
              tmpvar_19.y = (vec4((ivec4(16, 128, 235, 240) << 
                (tmpvar_6 - 8)
              )) / channel_max_10).y;
              tmpvar_19.zw = tmpvar_18.zw;
              tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
              tmpvar_9 = tmpvar_19;
            } else {
              float tmpvar_20;
              tmpvar_20 = (float((
                (1 << tmpvar_6)
               - 1)) / channel_max_10);
              vec4 tmpvar_21;
              tmpvar_21.xy = vec2(0.0, 0.0);
              tmpvar_21.z = tmpvar_20;
              tmpvar_21.w = tmpvar_20;
              tmpvar_8 = mat3(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0);
              tmpvar_9 = tmpvar_21;
            };
          };
        };
      };
    };
  };
  vec2 tmpvar_22;
  tmpvar_22 = (1.0/((tmpvar_9.zw - tmpvar_9.xy)));
  mat3 tmpvar_23;
  tmpvar_23[uint(0)].x = tmpvar_22.x;
  tmpvar_23[uint(0)].y = 0.0;
  tmpvar_23[uint(0)].z = 0.0;
  tmpvar_23[1u].x = 0.0;
  tmpvar_23[1u].y = tmpvar_22.y;
  tmpvar_23[1u].z = 0.0;
  tmpvar_23[2u].x = 0.0;
  tmpvar_23[2u].y = 0.0;
  tmpvar_23[2u].z = tmpvar_22.y;
  vYcbcrBias = tmpvar_9.xyy;
  vRgbFromDebiasedYcbcr = (tmpvar_8 * tmpvar_23);
  vYuvFormat.x = tmpvar_5;
  vec2 tmpvar_24;
  tmpvar_24 = vec2(textureSize (sColor0, 0));
  vec4 tmpvar_25;
  tmpvar_25.xy = (aUvRect0.xy + vec2(0.5, 0.5));
  tmpvar_25.zw = (aUvRect0.zw - vec2(0.5, 0.5));
  vUV_y = (mix (aUvRect0.xy, aUvRect0.zw, uv_1) / tmpvar_24);
  vUVBounds_y = (tmpvar_25 / tmpvar_24.xyxy);
  vec2 tmpvar_26;
  tmpvar_26 = vec2(textureSize (sColor1, 0));
  vec4 tmpvar_27;
  tmpvar_27.xy = (aUvRect1.xy + vec2(0.5, 0.5));
  tmpvar_27.zw = (aUvRect1.zw - vec2(0.5, 0.5));
  vUV_u = (mix (aUvRect1.xy, aUvRect1.zw, uv_1) / tmpvar_26);
  vUVBounds_u = (tmpvar_27 / tmpvar_26.xyxy);
  vec2 tmpvar_28;
  tmpvar_28 = vec2(textureSize (sColor2, 0));
  vec4 tmpvar_29;
  tmpvar_29.xy = (aUvRect2.xy + vec2(0.5, 0.5));
  tmpvar_29.zw = (aUvRect2.zw - vec2(0.5, 0.5));
  vUV_v = (mix (aUvRect2.xy, aUvRect2.zw, uv_1) / tmpvar_28);
  vUVBounds_v = (tmpvar_29 / tmpvar_28.xyxy);
  vec4 tmpvar_30;
  tmpvar_30.w = 1.0;
  tmpvar_30.xy = tmpvar_4;
  tmpvar_30.z = aParams.x;
  gl_Position = (uTransform * tmpvar_30);
}

#version 150
// composite
// features: ["TEXTURE_2D", "YUV"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sColor2;
flat in vec3 vYcbcrBias;
flat in mat3 vRgbFromDebiasedYcbcr;
flat in ivec2 vYuvFormat;
in vec2 vUV_y;
in vec2 vUV_u;
in vec2 vUV_v;
flat in vec4 vUVBounds_y;
flat in vec4 vUVBounds_u;
flat in vec4 vUVBounds_v;
void main ()
{
  vec3 ycbcr_sample_1;
  bool tmpvar_2;
  bool tmpvar_3;
  tmpvar_3 = bool(0);
  tmpvar_2 = (2 == vYuvFormat.x);
  if (tmpvar_2) {
    ycbcr_sample_1.x = texture (sColor0, min (max (vUV_y, vUVBounds_y.xy), vUVBounds_y.zw)).x;
    ycbcr_sample_1.y = texture (sColor1, min (max (vUV_u, vUVBounds_u.xy), vUVBounds_u.zw)).x;
    ycbcr_sample_1.z = texture (sColor2, min (max (vUV_v, vUVBounds_v.xy), vUVBounds_v.zw)).x;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (0 == vYuvFormat.x));
  tmpvar_2 = (tmpvar_2 || (1 == vYuvFormat.x));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    ycbcr_sample_1.x = texture (sColor0, min (max (vUV_y, vUVBounds_y.xy), vUVBounds_y.zw)).x;
    ycbcr_sample_1.yz = texture (sColor1, min (max (vUV_u, vUVBounds_u.xy), vUVBounds_u.zw)).xy;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (3 == vYuvFormat.x));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    ycbcr_sample_1 = texture (sColor0, min (max (vUV_y, vUVBounds_y.xy), vUVBounds_y.zw)).yzx;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = !(tmpvar_3);
  if (tmpvar_2) {
    ycbcr_sample_1 = vec3(0.0, 0.0, 0.0);
    tmpvar_3 = bool(1);
  };
  vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = (vRgbFromDebiasedYcbcr * (ycbcr_sample_1 - vYcbcrBias));
  oFragColor = tmpvar_4;
}

composite_TEXTURE_RECT#version 150
// composite
// features: ["TEXTURE_RECT"]

uniform mat4 uTransform;
in vec2 aPosition;
out vec2 vUv;
flat out vec4 vColor;
flat out vec4 vUVBounds;
in vec4 aLocalRect;
in vec4 aDeviceClipRect;
in vec4 aColor;
in vec4 aParams;
in vec4 aTransform;
in vec4 aUvRect0;
void main ()
{
  vec4 uvBounds_1;
  vec2 tmpvar_2;
  tmpvar_2 = ((aLocalRect.xy * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_3;
  tmpvar_3 = ((aLocalRect.zw * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_4;
  tmpvar_4 = min (max (mix (tmpvar_2, tmpvar_3, aPosition), aDeviceClipRect.xy), aDeviceClipRect.zw);
  vec2 tmpvar_5;
  tmpvar_5 = mix (aUvRect0.xy, aUvRect0.zw, ((tmpvar_4 - tmpvar_2) / (tmpvar_3 - tmpvar_2)));
  vec4 tmpvar_6;
  tmpvar_6.xy = min (aUvRect0.xy, aUvRect0.zw);
  tmpvar_6.zw = max (aUvRect0.xy, aUvRect0.zw);
  uvBounds_1 = tmpvar_6;
  int tmpvar_7;
  tmpvar_7 = int(aParams.y);
  if ((tmpvar_7 == 1)) {
    uvBounds_1 = (tmpvar_6 + vec4(0.5, 0.5, -0.5, -0.5));
  };
  vUv = tmpvar_5;
  vUVBounds = uvBounds_1;
  vColor = aColor;
  vec4 tmpvar_8;
  tmpvar_8.w = 1.0;
  tmpvar_8.xy = tmpvar_4;
  tmpvar_8.z = aParams.x;
  gl_Position = (uTransform * tmpvar_8);
}

#version 150
// composite
// features: ["TEXTURE_RECT"]

precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
in vec2 vUv;
flat in vec4 vColor;
flat in vec4 vUVBounds;
void main ()
{
  oFragColor = (vColor * texture (sColor0, min (max (vUv, vUVBounds.xy), vUVBounds.zw)));
}

composite_TEXTURE_RECT_YUV#version 150
// composite
// features: ["TEXTURE_RECT", "YUV"]

uniform mat4 uTransform;
in vec2 aPosition;
flat out vec3 vYcbcrBias;
flat out mat3 vRgbFromDebiasedYcbcr;
flat out ivec2 vYuvFormat;
out vec2 vUV_y;
out vec2 vUV_u;
out vec2 vUV_v;
flat out vec4 vUVBounds_y;
flat out vec4 vUVBounds_u;
flat out vec4 vUVBounds_v;
in vec4 aLocalRect;
in vec4 aDeviceClipRect;
in vec4 aParams;
in vec4 aTransform;
in vec4 aUvRect0;
in vec4 aUvRect1;
in vec4 aUvRect2;
void main ()
{
  vec2 uv_1;
  vec2 tmpvar_2;
  tmpvar_2 = ((aLocalRect.xy * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_3;
  tmpvar_3 = ((aLocalRect.zw * aTransform.xy) + aTransform.zw);
  vec2 tmpvar_4;
  tmpvar_4 = min (max (mix (tmpvar_2, tmpvar_3, aPosition), aDeviceClipRect.xy), aDeviceClipRect.zw);
  uv_1 = ((tmpvar_4 - tmpvar_2) / (tmpvar_3 - tmpvar_2));
  int tmpvar_5;
  tmpvar_5 = int(aParams.z);
  int tmpvar_6;
  int tmpvar_7;
  tmpvar_6 = int(aParams.w);
  tmpvar_7 = int(aParams.y);
  mat3 tmpvar_8;
  vec4 tmpvar_9;
  float channel_max_10;
  channel_max_10 = 255.0;
  if ((8 < tmpvar_6)) {
    if ((tmpvar_5 == 1)) {
      channel_max_10 = float(((1 << tmpvar_6) - 1));
    } else {
      channel_max_10 = 65535.0;
    };
  };
  if ((tmpvar_7 == 0)) {
    tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
    tmpvar_9 = (vec4((ivec4(16, 128, 235, 240) << 
      (tmpvar_6 - 8)
    )) / channel_max_10);
  } else {
    if ((tmpvar_7 == 1)) {
      float tmpvar_11;
      tmpvar_11 = (float((
        (1 << tmpvar_6)
       - 1)) / channel_max_10);
      vec4 tmpvar_12;
      tmpvar_12.xy = vec2(0.0, 0.0);
      tmpvar_12.z = tmpvar_11;
      tmpvar_12.w = tmpvar_11;
      vec4 tmpvar_13;
      tmpvar_13.x = 0.0;
      tmpvar_13.y = (vec4((ivec4(16, 128, 235, 240) << 
        (tmpvar_6 - 8)
      )) / channel_max_10).y;
      tmpvar_13.zw = tmpvar_12.zw;
      tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.17207, 0.886, 0.701, -0.35707, 0.0);
      tmpvar_9 = tmpvar_13;
    } else {
      if ((tmpvar_7 == 2)) {
        tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
        tmpvar_9 = (vec4((ivec4(16, 128, 235, 240) << 
          (tmpvar_6 - 8)
        )) / channel_max_10);
      } else {
        if ((tmpvar_7 == 3)) {
          float tmpvar_14;
          tmpvar_14 = (float((
            (1 << tmpvar_6)
           - 1)) / channel_max_10);
          vec4 tmpvar_15;
          tmpvar_15.xy = vec2(0.0, 0.0);
          tmpvar_15.z = tmpvar_14;
          tmpvar_15.w = tmpvar_14;
          vec4 tmpvar_16;
          tmpvar_16.x = 0.0;
          tmpvar_16.y = (vec4((ivec4(16, 128, 235, 240) << 
            (tmpvar_6 - 8)
          )) / channel_max_10).y;
          tmpvar_16.zw = tmpvar_15.zw;
          tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.09366, 0.9278, 0.7874, -0.23406, 0.0);
          tmpvar_9 = tmpvar_16;
        } else {
          if ((tmpvar_7 == 4)) {
            tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
            tmpvar_9 = (vec4((ivec4(16, 128, 235, 240) << 
              (tmpvar_6 - 8)
            )) / channel_max_10);
          } else {
            if ((tmpvar_7 == 5)) {
              float tmpvar_17;
              tmpvar_17 = (float((
                (1 << tmpvar_6)
               - 1)) / channel_max_10);
              vec4 tmpvar_18;
              tmpvar_18.xy = vec2(0.0, 0.0);
              tmpvar_18.z = tmpvar_17;
              tmpvar_18.w = tmpvar_17;
              vec4 tmpvar_19;
              tmpvar_19.x = 0.0;
              tmpvar_19.y = (vec4((ivec4(16, 128, 235, 240) << 
                (tmpvar_6 - 8)
              )) / channel_max_10).y;
              tmpvar_19.zw = tmpvar_18.zw;
              tmpvar_8 = mat3(1.0, 1.0, 1.0, 0.0, -0.08228, 0.9407, 0.7373, -0.28568, 0.0);
              tmpvar_9 = tmpvar_19;
            } else {
              float tmpvar_20;
              tmpvar_20 = (float((
                (1 << tmpvar_6)
               - 1)) / channel_max_10);
              vec4 tmpvar_21;
              tmpvar_21.xy = vec2(0.0, 0.0);
              tmpvar_21.z = tmpvar_20;
              tmpvar_21.w = tmpvar_20;
              tmpvar_8 = mat3(0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0);
              tmpvar_9 = tmpvar_21;
            };
          };
        };
      };
    };
  };
  vec2 tmpvar_22;
  tmpvar_22 = (1.0/((tmpvar_9.zw - tmpvar_9.xy)));
  mat3 tmpvar_23;
  tmpvar_23[uint(0)].x = tmpvar_22.x;
  tmpvar_23[uint(0)].y = 0.0;
  tmpvar_23[uint(0)].z = 0.0;
  tmpvar_23[1u].x = 0.0;
  tmpvar_23[1u].y = tmpvar_22.y;
  tmpvar_23[1u].z = 0.0;
  tmpvar_23[2u].x = 0.0;
  tmpvar_23[2u].y = 0.0;
  tmpvar_23[2u].z = tmpvar_22.y;
  vYcbcrBias = tmpvar_9.xyy;
  vRgbFromDebiasedYcbcr = (tmpvar_8 * tmpvar_23);
  vYuvFormat.x = tmpvar_5;
  vec4 tmpvar_24;
  tmpvar_24.xy = (aUvRect0.xy + vec2(0.5, 0.5));
  tmpvar_24.zw = (aUvRect0.zw - vec2(0.5, 0.5));
  vUV_y = mix (aUvRect0.xy, aUvRect0.zw, uv_1);
  vUVBounds_y = tmpvar_24;
  vec4 tmpvar_25;
  tmpvar_25.xy = (aUvRect1.xy + vec2(0.5, 0.5));
  tmpvar_25.zw = (aUvRect1.zw - vec2(0.5, 0.5));
  vUV_u = mix (aUvRect1.xy, aUvRect1.zw, uv_1);
  vUVBounds_u = tmpvar_25;
  vec4 tmpvar_26;
  tmpvar_26.xy = (aUvRect2.xy + vec2(0.5, 0.5));
  tmpvar_26.zw = (aUvRect2.zw - vec2(0.5, 0.5));
  vUV_v = mix (aUvRect2.xy, aUvRect2.zw, uv_1);
  vUVBounds_v = tmpvar_26;
  vec4 tmpvar_27;
  tmpvar_27.w = 1.0;
  tmpvar_27.xy = tmpvar_4;
  tmpvar_27.z = aParams.x;
  gl_Position = (uTransform * tmpvar_27);
}

#version 150
// composite
// features: ["TEXTURE_RECT", "YUV"]

precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
uniform sampler2DRect sColor1;
uniform sampler2DRect sColor2;
flat in vec3 vYcbcrBias;
flat in mat3 vRgbFromDebiasedYcbcr;
flat in ivec2 vYuvFormat;
in vec2 vUV_y;
in vec2 vUV_u;
in vec2 vUV_v;
flat in vec4 vUVBounds_y;
flat in vec4 vUVBounds_u;
flat in vec4 vUVBounds_v;
void main ()
{
  vec3 ycbcr_sample_1;
  bool tmpvar_2;
  bool tmpvar_3;
  tmpvar_3 = bool(0);
  tmpvar_2 = (2 == vYuvFormat.x);
  if (tmpvar_2) {
    ycbcr_sample_1.x = texture (sColor0, min (max (vUV_y, vUVBounds_y.xy), vUVBounds_y.zw)).x;
    ycbcr_sample_1.y = texture (sColor1, min (max (vUV_u, vUVBounds_u.xy), vUVBounds_u.zw)).x;
    ycbcr_sample_1.z = texture (sColor2, min (max (vUV_v, vUVBounds_v.xy), vUVBounds_v.zw)).x;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (0 == vYuvFormat.x));
  tmpvar_2 = (tmpvar_2 || (1 == vYuvFormat.x));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    ycbcr_sample_1.x = texture (sColor0, min (max (vUV_y, vUVBounds_y.xy), vUVBounds_y.zw)).x;
    ycbcr_sample_1.yz = texture (sColor1, min (max (vUV_u, vUVBounds_u.xy), vUVBounds_u.zw)).xy;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (3 == vYuvFormat.x));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    ycbcr_sample_1 = texture (sColor0, min (max (vUV_y, vUVBounds_y.xy), vUVBounds_y.zw)).yzx;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = !(tmpvar_3);
  if (tmpvar_2) {
    ycbcr_sample_1 = vec3(0.0, 0.0, 0.0);
    tmpvar_3 = bool(1);
  };
  vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = (vRgbFromDebiasedYcbcr * (ycbcr_sample_1 - vYcbcrBias));
  oFragColor = tmpvar_4;
}

cs_blur_ALPHA_TARGET#version 150
// cs_blur
// features: ["ALPHA_TARGET"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
out vec2 vUv;
flat out vec4 vUvRect;
flat out vec2 vOffsetScale;
flat out ivec2 vSupport;
flat out vec2 vGaussCoefficients;
in int aBlurRenderTaskAddress;
in int aBlurSourceTaskAddress;
in int aBlurDirection;
void main ()
{
  ivec2 tmpvar_1;
  tmpvar_1.x = int((2u * (
    uint(aBlurRenderTaskAddress)
   % 512u)));
  tmpvar_1.y = int((uint(aBlurRenderTaskAddress) / 512u));
  vec4 tmpvar_2;
  tmpvar_2 = texelFetchOffset (sRenderTasks, tmpvar_1, 0, ivec2(0, 0));
  vec4 tmpvar_3;
  tmpvar_3 = texelFetchOffset (sRenderTasks, tmpvar_1, 0, ivec2(1, 0));
  ivec2 tmpvar_4;
  tmpvar_4.x = int((2u * (
    uint(aBlurSourceTaskAddress)
   % 512u)));
  tmpvar_4.y = int((uint(aBlurSourceTaskAddress) / 512u));
  vec4 tmpvar_5;
  tmpvar_5 = texelFetchOffset (sRenderTasks, tmpvar_4, 0, ivec2(0, 0));
  vec2 tmpvar_6;
  tmpvar_6 = vec2(textureSize (sColor0, 0));
  vSupport.x = (int(ceil(
    (1.5 * tmpvar_3.x)
  )) * 2);
  if ((0 < vSupport.x)) {
    int i_7;
    float gauss_coefficient_total_8;
    vec3 gauss_coefficient_9;
    float tmpvar_10;
    tmpvar_10 = exp((-0.5 / (tmpvar_3.x * tmpvar_3.x)));
    vec2 tmpvar_11;
    tmpvar_11.x = (1.0/((2.506628 * tmpvar_3.x)));
    tmpvar_11.y = tmpvar_10;
    vGaussCoefficients = tmpvar_11;
    vec3 tmpvar_12;
    tmpvar_12.xy = tmpvar_11;
    tmpvar_12.z = (tmpvar_10 * tmpvar_10);
    gauss_coefficient_9 = tmpvar_12;
    gauss_coefficient_total_8 = tmpvar_12.x;
    i_7 = 1;
    for (; vSupport.x >= i_7; i_7 += 2) {
      gauss_coefficient_9.xy = (gauss_coefficient_9.xy * gauss_coefficient_9.yz);
      float tmpvar_13;
      tmpvar_13 = gauss_coefficient_9.x;
      gauss_coefficient_9.xy = (gauss_coefficient_9.xy * gauss_coefficient_9.yz);
      gauss_coefficient_total_8 = (gauss_coefficient_total_8 + (2.0 * (tmpvar_13 + gauss_coefficient_9.x)));
    };
    vGaussCoefficients.x = (tmpvar_11.x / gauss_coefficient_total_8);
  } else {
    vGaussCoefficients = vec2(1.0, 1.0);
  };
  bool tmpvar_14;
  bool tmpvar_15;
  tmpvar_15 = bool(0);
  tmpvar_14 = (0 == aBlurDirection);
  if (tmpvar_14) {
    vec2 tmpvar_16;
    tmpvar_16.y = 0.0;
    tmpvar_16.x = (1.0/(tmpvar_6.x));
    vOffsetScale = tmpvar_16;
    tmpvar_15 = bool(1);
  };
  tmpvar_14 = (tmpvar_14 || (1 == aBlurDirection));
  tmpvar_14 = (tmpvar_14 && !(tmpvar_15));
  if (tmpvar_14) {
    vec2 tmpvar_17;
    tmpvar_17.x = 0.0;
    tmpvar_17.y = (1.0/(tmpvar_6.y));
    vOffsetScale = tmpvar_17;
    tmpvar_15 = bool(1);
  };
  tmpvar_14 = !(tmpvar_15);
  if (tmpvar_14) {
    vOffsetScale = vec2(0.0, 0.0);
  };
  vec4 tmpvar_18;
  tmpvar_18.xy = (tmpvar_5.xy + vec2(0.5, 0.5));
  tmpvar_18.zw = ((tmpvar_5.xy + tmpvar_3.yz) - vec2(0.5, 0.5));
  vUvRect = (tmpvar_18 / tmpvar_6.xyxy);
  vUv = mix ((tmpvar_5.xy / tmpvar_6), (tmpvar_5.zw / tmpvar_6), aPosition);
  vec4 tmpvar_19;
  tmpvar_19.zw = vec2(0.0, 1.0);
  tmpvar_19.xy = mix (tmpvar_2.xy, tmpvar_2.zw, aPosition);
  gl_Position = (uTransform * tmpvar_19);
}

#version 150
// cs_blur
// features: ["ALPHA_TARGET"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
in vec2 vUv;
flat in vec4 vUvRect;
flat in vec2 vOffsetScale;
flat in ivec2 vSupport;
flat in vec2 vGaussCoefficients;
void main ()
{
  int i_1;
  float avg_color_2;
  vec3 gauss_coefficient_3;
  vec3 tmpvar_4;
  tmpvar_4.xy = vGaussCoefficients;
  tmpvar_4.z = (vGaussCoefficients.y * vGaussCoefficients.y);
  gauss_coefficient_3 = tmpvar_4;
  avg_color_2 = (texture (sColor0, vUv).x * vGaussCoefficients.x);
  int tmpvar_5;
  tmpvar_5 = min (vSupport.x, 300);
  i_1 = 1;
  for (; tmpvar_5 >= i_1; i_1 += 2) {
    float gauss_coefficient_subtotal_6;
    gauss_coefficient_3.xy = (gauss_coefficient_3.xy * gauss_coefficient_3.yz);
    float tmpvar_7;
    tmpvar_7 = gauss_coefficient_3.x;
    gauss_coefficient_3.xy = (gauss_coefficient_3.xy * gauss_coefficient_3.yz);
    gauss_coefficient_subtotal_6 = (tmpvar_7 + gauss_coefficient_3.x);
    vec2 tmpvar_8;
    tmpvar_8 = (vOffsetScale * (float(i_1) + (gauss_coefficient_3.x / gauss_coefficient_subtotal_6)));
    avg_color_2 = (avg_color_2 + ((texture (sColor0, 
      max ((vUv - tmpvar_8), vUvRect.xy)
    ).x + texture (sColor0, 
      min ((vUv + tmpvar_8), vUvRect.zw)
    ).x) * gauss_coefficient_subtotal_6));
  };
  oFragColor = vec4(avg_color_2);
}

cs_blur_COLOR_TARGET#version 150
// cs_blur
// features: ["COLOR_TARGET"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
out vec2 vUv;
flat out vec4 vUvRect;
flat out vec2 vOffsetScale;
flat out ivec2 vSupport;
flat out vec2 vGaussCoefficients;
in int aBlurRenderTaskAddress;
in int aBlurSourceTaskAddress;
in int aBlurDirection;
void main ()
{
  ivec2 tmpvar_1;
  tmpvar_1.x = int((2u * (
    uint(aBlurRenderTaskAddress)
   % 512u)));
  tmpvar_1.y = int((uint(aBlurRenderTaskAddress) / 512u));
  vec4 tmpvar_2;
  tmpvar_2 = texelFetchOffset (sRenderTasks, tmpvar_1, 0, ivec2(0, 0));
  vec4 tmpvar_3;
  tmpvar_3 = texelFetchOffset (sRenderTasks, tmpvar_1, 0, ivec2(1, 0));
  ivec2 tmpvar_4;
  tmpvar_4.x = int((2u * (
    uint(aBlurSourceTaskAddress)
   % 512u)));
  tmpvar_4.y = int((uint(aBlurSourceTaskAddress) / 512u));
  vec4 tmpvar_5;
  tmpvar_5 = texelFetchOffset (sRenderTasks, tmpvar_4, 0, ivec2(0, 0));
  vec2 tmpvar_6;
  tmpvar_6 = vec2(textureSize (sColor0, 0));
  vSupport.x = (int(ceil(
    (1.5 * tmpvar_3.x)
  )) * 2);
  if ((0 < vSupport.x)) {
    int i_7;
    float gauss_coefficient_total_8;
    vec3 gauss_coefficient_9;
    float tmpvar_10;
    tmpvar_10 = exp((-0.5 / (tmpvar_3.x * tmpvar_3.x)));
    vec2 tmpvar_11;
    tmpvar_11.x = (1.0/((2.506628 * tmpvar_3.x)));
    tmpvar_11.y = tmpvar_10;
    vGaussCoefficients = tmpvar_11;
    vec3 tmpvar_12;
    tmpvar_12.xy = tmpvar_11;
    tmpvar_12.z = (tmpvar_10 * tmpvar_10);
    gauss_coefficient_9 = tmpvar_12;
    gauss_coefficient_total_8 = tmpvar_12.x;
    i_7 = 1;
    for (; vSupport.x >= i_7; i_7 += 2) {
      gauss_coefficient_9.xy = (gauss_coefficient_9.xy * gauss_coefficient_9.yz);
      float tmpvar_13;
      tmpvar_13 = gauss_coefficient_9.x;
      gauss_coefficient_9.xy = (gauss_coefficient_9.xy * gauss_coefficient_9.yz);
      gauss_coefficient_total_8 = (gauss_coefficient_total_8 + (2.0 * (tmpvar_13 + gauss_coefficient_9.x)));
    };
    vGaussCoefficients.x = (tmpvar_11.x / gauss_coefficient_total_8);
  } else {
    vGaussCoefficients = vec2(1.0, 1.0);
  };
  bool tmpvar_14;
  bool tmpvar_15;
  tmpvar_15 = bool(0);
  tmpvar_14 = (0 == aBlurDirection);
  if (tmpvar_14) {
    vec2 tmpvar_16;
    tmpvar_16.y = 0.0;
    tmpvar_16.x = (1.0/(tmpvar_6.x));
    vOffsetScale = tmpvar_16;
    tmpvar_15 = bool(1);
  };
  tmpvar_14 = (tmpvar_14 || (1 == aBlurDirection));
  tmpvar_14 = (tmpvar_14 && !(tmpvar_15));
  if (tmpvar_14) {
    vec2 tmpvar_17;
    tmpvar_17.x = 0.0;
    tmpvar_17.y = (1.0/(tmpvar_6.y));
    vOffsetScale = tmpvar_17;
    tmpvar_15 = bool(1);
  };
  tmpvar_14 = !(tmpvar_15);
  if (tmpvar_14) {
    vOffsetScale = vec2(0.0, 0.0);
  };
  vec4 tmpvar_18;
  tmpvar_18.xy = (tmpvar_5.xy + vec2(0.5, 0.5));
  tmpvar_18.zw = ((tmpvar_5.xy + tmpvar_3.yz) - vec2(0.5, 0.5));
  vUvRect = (tmpvar_18 / tmpvar_6.xyxy);
  vUv = mix ((tmpvar_5.xy / tmpvar_6), (tmpvar_5.zw / tmpvar_6), aPosition);
  vec4 tmpvar_19;
  tmpvar_19.zw = vec2(0.0, 1.0);
  tmpvar_19.xy = mix (tmpvar_2.xy, tmpvar_2.zw, aPosition);
  gl_Position = (uTransform * tmpvar_19);
}

#version 150
// cs_blur
// features: ["COLOR_TARGET"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
in vec2 vUv;
flat in vec4 vUvRect;
flat in vec2 vOffsetScale;
flat in ivec2 vSupport;
flat in vec2 vGaussCoefficients;
void main ()
{
  int i_1;
  vec4 avg_color_2;
  vec3 gauss_coefficient_3;
  vec3 tmpvar_4;
  tmpvar_4.xy = vGaussCoefficients;
  tmpvar_4.z = (vGaussCoefficients.y * vGaussCoefficients.y);
  gauss_coefficient_3 = tmpvar_4;
  avg_color_2 = (texture (sColor0, vUv) * vGaussCoefficients.x);
  int tmpvar_5;
  tmpvar_5 = min (vSupport.x, 300);
  i_1 = 1;
  for (; tmpvar_5 >= i_1; i_1 += 2) {
    float gauss_coefficient_subtotal_6;
    gauss_coefficient_3.xy = (gauss_coefficient_3.xy * gauss_coefficient_3.yz);
    float tmpvar_7;
    tmpvar_7 = gauss_coefficient_3.x;
    gauss_coefficient_3.xy = (gauss_coefficient_3.xy * gauss_coefficient_3.yz);
    gauss_coefficient_subtotal_6 = (tmpvar_7 + gauss_coefficient_3.x);
    vec2 tmpvar_8;
    tmpvar_8 = (vOffsetScale * (float(i_1) + (gauss_coefficient_3.x / gauss_coefficient_subtotal_6)));
    avg_color_2 = (avg_color_2 + ((texture (sColor0, 
      max ((vUv - tmpvar_8), vUvRect.xy)
    ) + texture (sColor0, 
      min ((vUv + tmpvar_8), vUvRect.zw)
    )) * gauss_coefficient_subtotal_6));
  };
  oFragColor = avg_color_2;
}

#version 150
// cs_border_segment
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
flat out vec4 vColor00;
flat out vec4 vColor01;
flat out vec4 vColor10;
flat out vec4 vColor11;
flat out vec4 vColorLine;
flat out vec2 vSegmentClipMode;
flat out vec4 vStyleEdgeAxis;
flat out vec4 vClipCenter_Sign;
flat out vec4 vClipRadii;
flat out vec4 vEdgeReference;
flat out vec4 vPartialWidths;
flat out vec4 vClipParams1;
flat out vec4 vClipParams2;
out vec2 vPos;
in vec2 aTaskOrigin;
in vec4 aRect;
in vec4 aColor0;
in vec4 aColor1;
in int aFlags;
in vec2 aWidths;
in vec2 aRadii;
in vec4 aClipParams1;
in vec4 aClipParams2;
void main ()
{
  vec2 edge_reference_1;
  ivec2 edge_axis_2;
  vec2 clip_sign_3;
  int tmpvar_4;
  tmpvar_4 = (aFlags & 255);
  int tmpvar_5;
  tmpvar_5 = ((aFlags >> 8) & 255);
  int tmpvar_6;
  tmpvar_6 = ((aFlags >> 16) & 255);
  int tmpvar_7;
  tmpvar_7 = ((aFlags >> 24) & 15);
  vec2 tmpvar_8;
  tmpvar_8 = (aRect.zw - aRect.xy);
  vec2 p_9;
  bool tmpvar_10;
  bool tmpvar_11;
  tmpvar_11 = bool(0);
  tmpvar_10 = (0 == tmpvar_4);
  if (tmpvar_10) {
    p_9 = vec2(0.0, 0.0);
    tmpvar_11 = bool(1);
  };
  tmpvar_10 = (tmpvar_10 || (1 == tmpvar_4));
  tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
  if (tmpvar_10) {
    p_9 = vec2(1.0, 0.0);
    tmpvar_11 = bool(1);
  };
  tmpvar_10 = (tmpvar_10 || (2 == tmpvar_4));
  tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
  if (tmpvar_10) {
    p_9 = vec2(1.0, 1.0);
    tmpvar_11 = bool(1);
  };
  tmpvar_10 = (tmpvar_10 || (3 == tmpvar_4));
  tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
  if (tmpvar_10) {
    p_9 = vec2(0.0, 1.0);
    tmpvar_11 = bool(1);
  };
  tmpvar_10 = !(tmpvar_11);
  if (tmpvar_10) {
    p_9 = vec2(0.0, 0.0);
    tmpvar_11 = bool(1);
  };
  vec2 tmpvar_12;
  tmpvar_12 = (p_9 * tmpvar_8);
  clip_sign_3 = (1.0 - (2.0 * p_9));
  edge_axis_2 = ivec2(0, 0);
  edge_reference_1 = vec2(0.0, 0.0);
  bool tmpvar_13;
  bool tmpvar_14;
  tmpvar_14 = bool(0);
  tmpvar_13 = (0 == tmpvar_4);
  if (tmpvar_13) {
    edge_axis_2 = ivec2(0, 1);
    edge_reference_1 = tmpvar_12;
    tmpvar_14 = bool(1);
  };
  tmpvar_13 = (tmpvar_13 || (1 == tmpvar_4));
  tmpvar_13 = (tmpvar_13 && !(tmpvar_14));
  if (tmpvar_13) {
    edge_axis_2 = ivec2(1, 0);
    vec2 tmpvar_15;
    tmpvar_15.x = (tmpvar_12.x - aWidths.x);
    tmpvar_15.y = tmpvar_12.y;
    edge_reference_1 = tmpvar_15;
    tmpvar_14 = bool(1);
  };
  tmpvar_13 = (tmpvar_13 || (2 == tmpvar_4));
  tmpvar_13 = (tmpvar_13 && !(tmpvar_14));
  if (tmpvar_13) {
    edge_axis_2 = ivec2(0, 1);
    edge_reference_1 = (tmpvar_12 - aWidths);
    tmpvar_14 = bool(1);
  };
  tmpvar_13 = (tmpvar_13 || (3 == tmpvar_4));
  tmpvar_13 = (tmpvar_13 && !(tmpvar_14));
  if (tmpvar_13) {
    edge_axis_2 = ivec2(1, 0);
    vec2 tmpvar_16;
    tmpvar_16.x = tmpvar_12.x;
    tmpvar_16.y = (tmpvar_12.y - aWidths.y);
    edge_reference_1 = tmpvar_16;
    tmpvar_14 = bool(1);
  };
  tmpvar_13 = (tmpvar_13 || (5 == tmpvar_4));
  tmpvar_13 = (tmpvar_13 || (7 == tmpvar_4));
  tmpvar_13 = (tmpvar_13 && !(tmpvar_14));
  if (tmpvar_13) {
    edge_axis_2 = ivec2(1, 1);
    tmpvar_14 = bool(1);
  };
  tmpvar_13 = !(tmpvar_14);
  if (tmpvar_13) {
    tmpvar_14 = bool(1);
  };
  vec2 tmpvar_17;
  tmpvar_17.x = float(tmpvar_4);
  tmpvar_17.y = float(tmpvar_7);
  vSegmentClipMode = tmpvar_17;
  vec4 tmpvar_18;
  tmpvar_18.x = float(tmpvar_5);
  tmpvar_18.y = float(tmpvar_6);
  tmpvar_18.z = float(edge_axis_2.x);
  tmpvar_18.w = float(edge_axis_2.y);
  vStyleEdgeAxis = tmpvar_18;
  vec4 tmpvar_19;
  tmpvar_19.xy = (aWidths / 3.0);
  tmpvar_19.zw = (aWidths / 2.0);
  vPartialWidths = tmpvar_19;
  vPos = (tmpvar_8 * aPosition);
  vec4 tmpvar_20;
  vec4 tmpvar_21;
  bool tmpvar_22;
  tmpvar_22 = (aColor0.xyz == vec3(0.0, 0.0, 0.0));
  bool tmpvar_23;
  bool tmpvar_24;
  tmpvar_24 = bool(0);
  tmpvar_23 = (6 == tmpvar_5);
  if (tmpvar_23) {
    vec4 tmpvar_25;
    if (tmpvar_22) {
      vec4 tmpvar_26;
      tmpvar_26.xyz = vec3(0.7, 0.7, 0.7);
      tmpvar_26.w = aColor0.w;
      tmpvar_25 = tmpvar_26;
    } else {
      vec4 tmpvar_27;
      tmpvar_27.xyz = aColor0.xyz;
      tmpvar_27.w = aColor0.w;
      tmpvar_25 = tmpvar_27;
    };
    tmpvar_20 = tmpvar_25;
    vec4 tmpvar_28;
    if (tmpvar_22) {
      vec4 tmpvar_29;
      tmpvar_29.xyz = vec3(0.3, 0.3, 0.3);
      tmpvar_29.w = aColor0.w;
      tmpvar_28 = tmpvar_29;
    } else {
      vec4 tmpvar_30;
      tmpvar_30.xyz = (aColor0.xyz * 0.6666667);
      tmpvar_30.w = aColor0.w;
      tmpvar_28 = tmpvar_30;
    };
    tmpvar_21 = tmpvar_28;
    tmpvar_24 = bool(1);
  };
  tmpvar_23 = (tmpvar_23 || (7 == tmpvar_5));
  tmpvar_23 = (tmpvar_23 && !(tmpvar_24));
  if (tmpvar_23) {
    vec4 tmpvar_31;
    if (tmpvar_22) {
      vec4 tmpvar_32;
      tmpvar_32.xyz = vec3(0.3, 0.3, 0.3);
      tmpvar_32.w = aColor0.w;
      tmpvar_31 = tmpvar_32;
    } else {
      vec4 tmpvar_33;
      tmpvar_33.xyz = (aColor0.xyz * 0.6666667);
      tmpvar_33.w = aColor0.w;
      tmpvar_31 = tmpvar_33;
    };
    tmpvar_20 = tmpvar_31;
    vec4 tmpvar_34;
    if (tmpvar_22) {
      vec4 tmpvar_35;
      tmpvar_35.xyz = vec3(0.7, 0.7, 0.7);
      tmpvar_35.w = aColor0.w;
      tmpvar_34 = tmpvar_35;
    } else {
      vec4 tmpvar_36;
      tmpvar_36.xyz = aColor0.xyz;
      tmpvar_36.w = aColor0.w;
      tmpvar_34 = tmpvar_36;
    };
    tmpvar_21 = tmpvar_34;
    tmpvar_24 = bool(1);
  };
  tmpvar_23 = !(tmpvar_24);
  if (tmpvar_23) {
    tmpvar_20 = aColor0;
    tmpvar_21 = aColor0;
    tmpvar_24 = bool(1);
  };
  vColor00 = tmpvar_20;
  vColor01 = tmpvar_21;
  vec4 tmpvar_37;
  vec4 tmpvar_38;
  bool tmpvar_39;
  tmpvar_39 = (aColor1.xyz == vec3(0.0, 0.0, 0.0));
  bool tmpvar_40;
  bool tmpvar_41;
  tmpvar_41 = bool(0);
  tmpvar_40 = (6 == tmpvar_6);
  if (tmpvar_40) {
    vec4 tmpvar_42;
    if (tmpvar_39) {
      vec4 tmpvar_43;
      tmpvar_43.xyz = vec3(0.7, 0.7, 0.7);
      tmpvar_43.w = aColor1.w;
      tmpvar_42 = tmpvar_43;
    } else {
      vec4 tmpvar_44;
      tmpvar_44.xyz = aColor1.xyz;
      tmpvar_44.w = aColor1.w;
      tmpvar_42 = tmpvar_44;
    };
    tmpvar_37 = tmpvar_42;
    vec4 tmpvar_45;
    if (tmpvar_39) {
      vec4 tmpvar_46;
      tmpvar_46.xyz = vec3(0.3, 0.3, 0.3);
      tmpvar_46.w = aColor1.w;
      tmpvar_45 = tmpvar_46;
    } else {
      vec4 tmpvar_47;
      tmpvar_47.xyz = (aColor1.xyz * 0.6666667);
      tmpvar_47.w = aColor1.w;
      tmpvar_45 = tmpvar_47;
    };
    tmpvar_38 = tmpvar_45;
    tmpvar_41 = bool(1);
  };
  tmpvar_40 = (tmpvar_40 || (7 == tmpvar_6));
  tmpvar_40 = (tmpvar_40 && !(tmpvar_41));
  if (tmpvar_40) {
    vec4 tmpvar_48;
    if (tmpvar_39) {
      vec4 tmpvar_49;
      tmpvar_49.xyz = vec3(0.3, 0.3, 0.3);
      tmpvar_49.w = aColor1.w;
      tmpvar_48 = tmpvar_49;
    } else {
      vec4 tmpvar_50;
      tmpvar_50.xyz = (aColor1.xyz * 0.6666667);
      tmpvar_50.w = aColor1.w;
      tmpvar_48 = tmpvar_50;
    };
    tmpvar_37 = tmpvar_48;
    vec4 tmpvar_51;
    if (tmpvar_39) {
      vec4 tmpvar_52;
      tmpvar_52.xyz = vec3(0.7, 0.7, 0.7);
      tmpvar_52.w = aColor1.w;
      tmpvar_51 = tmpvar_52;
    } else {
      vec4 tmpvar_53;
      tmpvar_53.xyz = aColor1.xyz;
      tmpvar_53.w = aColor1.w;
      tmpvar_51 = tmpvar_53;
    };
    tmpvar_38 = tmpvar_51;
    tmpvar_41 = bool(1);
  };
  tmpvar_40 = !(tmpvar_41);
  if (tmpvar_40) {
    tmpvar_37 = aColor1;
    tmpvar_38 = aColor1;
    tmpvar_41 = bool(1);
  };
  vColor10 = tmpvar_37;
  vColor11 = tmpvar_38;
  vec4 tmpvar_54;
  tmpvar_54.xy = (tmpvar_12 + (clip_sign_3 * aRadii));
  tmpvar_54.zw = clip_sign_3;
  vClipCenter_Sign = tmpvar_54;
  vec4 tmpvar_55;
  tmpvar_55.xy = aRadii;
  tmpvar_55.zw = max ((aRadii - aWidths), 0.0);
  vClipRadii = tmpvar_55;
  vec4 tmpvar_56;
  tmpvar_56.xy = tmpvar_12;
  tmpvar_56.z = (aWidths.y * -(clip_sign_3.y));
  tmpvar_56.w = (aWidths.x * clip_sign_3.x);
  vColorLine = tmpvar_56;
  vec4 tmpvar_57;
  tmpvar_57.xy = edge_reference_1;
  tmpvar_57.zw = (edge_reference_1 + aWidths);
  vEdgeReference = tmpvar_57;
  vClipParams1 = aClipParams1;
  vClipParams2 = aClipParams2;
  if ((tmpvar_7 == 3)) {
    float radius_58;
    radius_58 = aClipParams1.z;
    if ((0.5 < aClipParams1.z)) {
      radius_58 = (aClipParams1.z + 2.0);
    };
    vPos = (aClipParams1.xy + (radius_58 * (
      (2.0 * aPosition)
     - 1.0)));
    vPos = min (max (vPos, vec2(0.0, 0.0)), tmpvar_8);
  } else {
    if ((tmpvar_7 == 1)) {
      vec2 tmpvar_59;
      tmpvar_59 = ((aClipParams1.xy + aClipParams2.xy) * 0.5);
      vec2 tmpvar_60;
      tmpvar_60 = (aClipParams1.xy - aClipParams2.xy);
      vec2 tmpvar_61;
      tmpvar_61 = (vec2(max (sqrt(
        dot (tmpvar_60, tmpvar_60)
      ), max (aWidths.x, aWidths.y))) + 2.0);
      vPos = min (max (vPos, (tmpvar_59 - tmpvar_61)), (tmpvar_59 + tmpvar_61));
    };
  };
  vec4 tmpvar_62;
  tmpvar_62.zw = vec2(0.0, 1.0);
  tmpvar_62.xy = ((aTaskOrigin + aRect.xy) + vPos);
  gl_Position = (uTransform * tmpvar_62);
}

#version 150
// cs_border_segment
// features: []

precision highp float;
out vec4 oFragColor;
flat in vec4 vColor00;
flat in vec4 vColor01;
flat in vec4 vColor10;
flat in vec4 vColor11;
flat in vec4 vColorLine;
flat in vec2 vSegmentClipMode;
flat in vec4 vStyleEdgeAxis;
flat in vec4 vClipCenter_Sign;
flat in vec4 vClipRadii;
flat in vec4 vEdgeReference;
flat in vec4 vPartialWidths;
flat in vec4 vClipParams1;
flat in vec4 vClipParams2;
in vec2 vPos;
void main ()
{
  float d_1;
  float mix_factor_2;
  vec4 color1_3;
  vec4 color0_4;
  vec2 tmpvar_5;
  tmpvar_5 = (abs(dFdx(vPos)) + abs(dFdy(vPos)));
  float tmpvar_6;
  tmpvar_6 = inversesqrt((0.5 * dot (tmpvar_5, tmpvar_5)));
  int tmpvar_7;
  tmpvar_7 = int(vSegmentClipMode.x);
  int tmpvar_8;
  tmpvar_8 = int(vSegmentClipMode.y);
  ivec2 tmpvar_9;
  tmpvar_9 = ivec2(vStyleEdgeAxis.xy);
  ivec2 tmpvar_10;
  tmpvar_10.x = int(vStyleEdgeAxis.z);
  tmpvar_10.y = int(vStyleEdgeAxis.w);
  mix_factor_2 = 0.0;
  if ((tmpvar_10.x != tmpvar_10.y)) {
    mix_factor_2 = min (max ((0.5 - 
      (-(dot ((vColorLine.zw * 
        inversesqrt(dot (vColorLine.zw, vColorLine.zw))
      ), (vColorLine.xy - vPos))) * tmpvar_6)
    ), 0.0), 1.0);
  };
  vec2 tmpvar_11;
  tmpvar_11 = (vPos - vClipCenter_Sign.xy);
  bool tmpvar_12;
  tmpvar_12 = (lessThan ((vClipCenter_Sign.zw * tmpvar_11), vec2(0.0, 0.0)) == bvec2(1, 1));
  d_1 = -1.0;
  bool tmpvar_13;
  bool tmpvar_14;
  tmpvar_14 = bool(0);
  tmpvar_13 = (3 == tmpvar_8);
  if (tmpvar_13) {
    vec2 tmpvar_15;
    tmpvar_15 = (vClipParams1.xy - vPos);
    d_1 = (sqrt(dot (tmpvar_15, tmpvar_15)) - vClipParams1.z);
    tmpvar_14 = bool(1);
  };
  tmpvar_13 = (tmpvar_13 || (2 == tmpvar_8));
  tmpvar_13 = (tmpvar_13 && !(tmpvar_14));
  if (tmpvar_13) {
    bool tmpvar_16;
    tmpvar_16 = (vClipParams1.x == 0.0);
    float tmpvar_17;
    if (tmpvar_16) {
      tmpvar_17 = vClipParams1.y;
    } else {
      tmpvar_17 = vClipParams1.x;
    };
    float tmpvar_18;
    if (tmpvar_16) {
      tmpvar_18 = vPos.y;
    } else {
      tmpvar_18 = vPos.x;
    };
    bool tmpvar_19;
    tmpvar_19 = ((tmpvar_18 < tmpvar_17) || ((3.0 * tmpvar_17) < tmpvar_18));
    if (!(tmpvar_19)) {
      d_1 = 1.0;
    };
    tmpvar_14 = bool(1);
  };
  tmpvar_13 = (tmpvar_13 || (1 == tmpvar_8));
  tmpvar_13 = (tmpvar_13 && !(tmpvar_14));
  if (tmpvar_13) {
    d_1 = max (dot ((vClipParams1.zw * 
      inversesqrt(dot (vClipParams1.zw, vClipParams1.zw))
    ), (vClipParams1.xy - vPos)), -(dot (
      (vClipParams2.zw * inversesqrt(dot (vClipParams2.zw, vClipParams2.zw)))
    , 
      (vClipParams2.xy - vPos)
    )));
    tmpvar_14 = bool(1);
  };
  tmpvar_13 = !(tmpvar_14);
  if (tmpvar_13) {
    tmpvar_14 = bool(1);
  };
  if (tmpvar_12) {
    float tmpvar_20;
    tmpvar_20 = float((lessThan (vec2(0.0, 0.0), vClipRadii.xy) == bvec2(1, 1)));
    vec2 tmpvar_21;
    tmpvar_21 = (tmpvar_11 * (1.0/(max (
      (vClipRadii.xy * vClipRadii.xy)
    , 1e-06))));
    vec2 tmpvar_22;
    tmpvar_22 = ((1.0 + tmpvar_20) * tmpvar_21);
    float tmpvar_23;
    tmpvar_23 = float((lessThan (vec2(0.0, 0.0), vClipRadii.zw) == bvec2(1, 1)));
    vec2 tmpvar_24;
    tmpvar_24 = (tmpvar_11 * (1.0/(max (
      (vClipRadii.zw * vClipRadii.zw)
    , 1e-06))));
    vec2 tmpvar_25;
    tmpvar_25 = ((1.0 + tmpvar_23) * tmpvar_24);
    d_1 = max (d_1, max ((
      (dot (tmpvar_11, tmpvar_21) - tmpvar_20)
     * 
      inversesqrt(dot (tmpvar_22, tmpvar_22))
    ), -(
      ((dot (tmpvar_11, tmpvar_24) - tmpvar_23) * inversesqrt(dot (tmpvar_25, tmpvar_25)))
    )));
    vec4 tmpvar_26;
    tmpvar_26 = vColor00;
    bool tmpvar_27;
    bool tmpvar_28;
    tmpvar_28 = bool(0);
    tmpvar_27 = (2 == tmpvar_9.x);
    if (tmpvar_27) {
      vec2 tmpvar_29;
      tmpvar_29 = (vClipRadii.xy - vPartialWidths.xy);
      float tmpvar_30;
      tmpvar_30 = float((lessThan (vec2(0.0, 0.0), tmpvar_29) == bvec2(1, 1)));
      vec2 tmpvar_31;
      tmpvar_31 = (tmpvar_11 * (1.0/(max (
        (tmpvar_29 * tmpvar_29)
      , 1e-06))));
      vec2 tmpvar_32;
      tmpvar_32 = ((1.0 + tmpvar_30) * tmpvar_31);
      vec2 tmpvar_33;
      tmpvar_33 = (vClipRadii.xy - (2.0 * vPartialWidths.xy));
      float tmpvar_34;
      tmpvar_34 = float((lessThan (vec2(0.0, 0.0), tmpvar_33) == bvec2(1, 1)));
      vec2 tmpvar_35;
      tmpvar_35 = (tmpvar_11 * (1.0/(max (
        (tmpvar_33 * tmpvar_33)
      , 1e-06))));
      vec2 tmpvar_36;
      tmpvar_36 = ((1.0 + tmpvar_34) * tmpvar_35);
      tmpvar_26 = (vColor00 * min (max (
        (0.5 - (min (-(
          ((dot (tmpvar_11, tmpvar_31) - tmpvar_30) * inversesqrt(dot (tmpvar_32, tmpvar_32)))
        ), (
          (dot (tmpvar_11, tmpvar_35) - tmpvar_34)
         * 
          inversesqrt(dot (tmpvar_36, tmpvar_36))
        )) * tmpvar_6))
      , 0.0), 1.0));
      tmpvar_28 = bool(1);
    };
    tmpvar_27 = (tmpvar_27 || (6 == tmpvar_9.x));
    tmpvar_27 = (tmpvar_27 || (7 == tmpvar_9.x));
    tmpvar_27 = (tmpvar_27 && !(tmpvar_28));
    if (tmpvar_27) {
      float swizzled_factor_37;
      vec2 tmpvar_38;
      tmpvar_38 = (vClipRadii.xy - vPartialWidths.zw);
      float tmpvar_39;
      tmpvar_39 = float((lessThan (vec2(0.0, 0.0), tmpvar_38) == bvec2(1, 1)));
      vec2 tmpvar_40;
      tmpvar_40 = (tmpvar_11 * (1.0/(max (
        (tmpvar_38 * tmpvar_38)
      , 1e-06))));
      vec2 tmpvar_41;
      tmpvar_41 = ((1.0 + tmpvar_39) * tmpvar_40);
      float tmpvar_42;
      tmpvar_42 = min (max ((0.5 - 
        (((dot (tmpvar_11, tmpvar_40) - tmpvar_39) * inversesqrt(dot (tmpvar_41, tmpvar_41))) * tmpvar_6)
      ), 0.0), 1.0);
      bool tmpvar_43;
      bool tmpvar_44;
      tmpvar_44 = bool(0);
      tmpvar_43 = (0 == tmpvar_7);
      if (tmpvar_43) {
        swizzled_factor_37 = 0.0;
        tmpvar_44 = bool(1);
      };
      tmpvar_43 = (tmpvar_43 || (1 == tmpvar_7));
      tmpvar_43 = (tmpvar_43 && !(tmpvar_44));
      if (tmpvar_43) {
        swizzled_factor_37 = mix_factor_2;
        tmpvar_44 = bool(1);
      };
      tmpvar_43 = (tmpvar_43 || (2 == tmpvar_7));
      tmpvar_43 = (tmpvar_43 && !(tmpvar_44));
      if (tmpvar_43) {
        swizzled_factor_37 = 1.0;
        tmpvar_44 = bool(1);
      };
      tmpvar_43 = (tmpvar_43 || (3 == tmpvar_7));
      tmpvar_43 = (tmpvar_43 && !(tmpvar_44));
      if (tmpvar_43) {
        swizzled_factor_37 = (1.0 - mix_factor_2);
        tmpvar_44 = bool(1);
      };
      tmpvar_43 = !(tmpvar_44);
      if (tmpvar_43) {
        swizzled_factor_37 = 0.0;
        tmpvar_44 = bool(1);
      };
      tmpvar_26 = mix (mix (vColor01, tmpvar_26, swizzled_factor_37), mix (tmpvar_26, vColor01, swizzled_factor_37), tmpvar_42);
      tmpvar_28 = bool(1);
    };
    tmpvar_27 = !(tmpvar_28);
    if (tmpvar_27) {
      tmpvar_28 = bool(1);
    };
    color0_4 = tmpvar_26;
    vec4 tmpvar_45;
    tmpvar_45 = vColor10;
    bool tmpvar_46;
    bool tmpvar_47;
    tmpvar_47 = bool(0);
    tmpvar_46 = (2 == tmpvar_9.y);
    if (tmpvar_46) {
      vec2 tmpvar_48;
      tmpvar_48 = (vClipRadii.xy - vPartialWidths.xy);
      float tmpvar_49;
      tmpvar_49 = float((lessThan (vec2(0.0, 0.0), tmpvar_48) == bvec2(1, 1)));
      vec2 tmpvar_50;
      tmpvar_50 = (tmpvar_11 * (1.0/(max (
        (tmpvar_48 * tmpvar_48)
      , 1e-06))));
      vec2 tmpvar_51;
      tmpvar_51 = ((1.0 + tmpvar_49) * tmpvar_50);
      vec2 tmpvar_52;
      tmpvar_52 = (vClipRadii.xy - (2.0 * vPartialWidths.xy));
      float tmpvar_53;
      tmpvar_53 = float((lessThan (vec2(0.0, 0.0), tmpvar_52) == bvec2(1, 1)));
      vec2 tmpvar_54;
      tmpvar_54 = (tmpvar_11 * (1.0/(max (
        (tmpvar_52 * tmpvar_52)
      , 1e-06))));
      vec2 tmpvar_55;
      tmpvar_55 = ((1.0 + tmpvar_53) * tmpvar_54);
      tmpvar_45 = (vColor10 * min (max (
        (0.5 - (min (-(
          ((dot (tmpvar_11, tmpvar_50) - tmpvar_49) * inversesqrt(dot (tmpvar_51, tmpvar_51)))
        ), (
          (dot (tmpvar_11, tmpvar_54) - tmpvar_53)
         * 
          inversesqrt(dot (tmpvar_55, tmpvar_55))
        )) * tmpvar_6))
      , 0.0), 1.0));
      tmpvar_47 = bool(1);
    };
    tmpvar_46 = (tmpvar_46 || (6 == tmpvar_9.y));
    tmpvar_46 = (tmpvar_46 || (7 == tmpvar_9.y));
    tmpvar_46 = (tmpvar_46 && !(tmpvar_47));
    if (tmpvar_46) {
      float swizzled_factor_56;
      vec2 tmpvar_57;
      tmpvar_57 = (vClipRadii.xy - vPartialWidths.zw);
      float tmpvar_58;
      tmpvar_58 = float((lessThan (vec2(0.0, 0.0), tmpvar_57) == bvec2(1, 1)));
      vec2 tmpvar_59;
      tmpvar_59 = (tmpvar_11 * (1.0/(max (
        (tmpvar_57 * tmpvar_57)
      , 1e-06))));
      vec2 tmpvar_60;
      tmpvar_60 = ((1.0 + tmpvar_58) * tmpvar_59);
      float tmpvar_61;
      tmpvar_61 = min (max ((0.5 - 
        (((dot (tmpvar_11, tmpvar_59) - tmpvar_58) * inversesqrt(dot (tmpvar_60, tmpvar_60))) * tmpvar_6)
      ), 0.0), 1.0);
      bool tmpvar_62;
      bool tmpvar_63;
      tmpvar_63 = bool(0);
      tmpvar_62 = (0 == tmpvar_7);
      if (tmpvar_62) {
        swizzled_factor_56 = 0.0;
        tmpvar_63 = bool(1);
      };
      tmpvar_62 = (tmpvar_62 || (1 == tmpvar_7));
      tmpvar_62 = (tmpvar_62 && !(tmpvar_63));
      if (tmpvar_62) {
        swizzled_factor_56 = mix_factor_2;
        tmpvar_63 = bool(1);
      };
      tmpvar_62 = (tmpvar_62 || (2 == tmpvar_7));
      tmpvar_62 = (tmpvar_62 && !(tmpvar_63));
      if (tmpvar_62) {
        swizzled_factor_56 = 1.0;
        tmpvar_63 = bool(1);
      };
      tmpvar_62 = (tmpvar_62 || (3 == tmpvar_7));
      tmpvar_62 = (tmpvar_62 && !(tmpvar_63));
      if (tmpvar_62) {
        swizzled_factor_56 = (1.0 - mix_factor_2);
        tmpvar_63 = bool(1);
      };
      tmpvar_62 = !(tmpvar_63);
      if (tmpvar_62) {
        swizzled_factor_56 = 0.0;
        tmpvar_63 = bool(1);
      };
      tmpvar_45 = mix (mix (vColor11, tmpvar_45, swizzled_factor_56), mix (tmpvar_45, vColor11, swizzled_factor_56), tmpvar_61);
      tmpvar_47 = bool(1);
    };
    tmpvar_46 = !(tmpvar_47);
    if (tmpvar_46) {
      tmpvar_47 = bool(1);
    };
    color1_3 = tmpvar_45;
  } else {
    vec4 tmpvar_64;
    tmpvar_64 = vColor00;
    vec2 tmpvar_65;
    if ((tmpvar_10.x != 0)) {
      tmpvar_65 = vec2(0.0, 1.0);
    } else {
      tmpvar_65 = vec2(1.0, 0.0);
    };
    float tmpvar_66;
    tmpvar_66 = dot (vPos, tmpvar_65);
    bool tmpvar_67;
    bool tmpvar_68;
    tmpvar_68 = bool(0);
    tmpvar_67 = (2 == tmpvar_9.x);
    if (tmpvar_67) {
      float d_69;
      d_69 = -1.0;
      float tmpvar_70;
      tmpvar_70 = dot (vPartialWidths.xy, tmpvar_65);
      if ((tmpvar_70 >= 1.0)) {
        vec2 tmpvar_71;
        tmpvar_71.x = (dot (vEdgeReference.xy, tmpvar_65) + tmpvar_70);
        tmpvar_71.y = (dot (vEdgeReference.zw, tmpvar_65) - tmpvar_70);
        d_69 = min ((tmpvar_66 - tmpvar_71.x), (tmpvar_71.y - tmpvar_66));
      };
      tmpvar_64 = (vColor00 * min (max (
        (0.5 - (d_69 * tmpvar_6))
      , 0.0), 1.0));
      tmpvar_68 = bool(1);
    };
    tmpvar_67 = (tmpvar_67 || (6 == tmpvar_9.x));
    tmpvar_67 = (tmpvar_67 || (7 == tmpvar_9.x));
    tmpvar_67 = (tmpvar_67 && !(tmpvar_68));
    if (tmpvar_67) {
      tmpvar_64 = mix (tmpvar_64, vColor01, min (max (
        (0.5 - ((tmpvar_66 - dot (
          (vEdgeReference.xy + vPartialWidths.zw)
        , tmpvar_65)) * tmpvar_6))
      , 0.0), 1.0));
      tmpvar_68 = bool(1);
    };
    tmpvar_67 = !(tmpvar_68);
    if (tmpvar_67) {
      tmpvar_68 = bool(1);
    };
    color0_4 = tmpvar_64;
    vec4 tmpvar_72;
    tmpvar_72 = vColor10;
    vec2 tmpvar_73;
    if ((tmpvar_10.y != 0)) {
      tmpvar_73 = vec2(0.0, 1.0);
    } else {
      tmpvar_73 = vec2(1.0, 0.0);
    };
    float tmpvar_74;
    tmpvar_74 = dot (vPos, tmpvar_73);
    bool tmpvar_75;
    bool tmpvar_76;
    tmpvar_76 = bool(0);
    tmpvar_75 = (2 == tmpvar_9.y);
    if (tmpvar_75) {
      float d_77;
      d_77 = -1.0;
      float tmpvar_78;
      tmpvar_78 = dot (vPartialWidths.xy, tmpvar_73);
      if ((tmpvar_78 >= 1.0)) {
        vec2 tmpvar_79;
        tmpvar_79.x = (dot (vEdgeReference.xy, tmpvar_73) + tmpvar_78);
        tmpvar_79.y = (dot (vEdgeReference.zw, tmpvar_73) - tmpvar_78);
        d_77 = min ((tmpvar_74 - tmpvar_79.x), (tmpvar_79.y - tmpvar_74));
      };
      tmpvar_72 = (vColor10 * min (max (
        (0.5 - (d_77 * tmpvar_6))
      , 0.0), 1.0));
      tmpvar_76 = bool(1);
    };
    tmpvar_75 = (tmpvar_75 || (6 == tmpvar_9.y));
    tmpvar_75 = (tmpvar_75 || (7 == tmpvar_9.y));
    tmpvar_75 = (tmpvar_75 && !(tmpvar_76));
    if (tmpvar_75) {
      tmpvar_72 = mix (tmpvar_72, vColor11, min (max (
        (0.5 - ((tmpvar_74 - dot (
          (vEdgeReference.xy + vPartialWidths.zw)
        , tmpvar_73)) * tmpvar_6))
      , 0.0), 1.0));
      tmpvar_76 = bool(1);
    };
    tmpvar_75 = !(tmpvar_76);
    if (tmpvar_75) {
      tmpvar_76 = bool(1);
    };
    color1_3 = tmpvar_72;
  };
  oFragColor = (mix (color0_4, color1_3, mix_factor_2) * min (max (
    (0.5 - (d_1 * tmpvar_6))
  , 0.0), 1.0));
}

#version 150
// cs_border_solid
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
flat out vec4 vColor0;
flat out vec4 vColor1;
flat out vec4 vColorLine;
flat out ivec2 vMixColors;
flat out vec4 vClipCenter_Sign;
flat out vec4 vClipRadii;
flat out vec4 vHorizontalClipCenter_Sign;
flat out vec2 vHorizontalClipRadii;
flat out vec4 vVerticalClipCenter_Sign;
flat out vec2 vVerticalClipRadii;
out vec2 vPos;
in vec2 aTaskOrigin;
in vec4 aRect;
in vec4 aColor0;
in vec4 aColor1;
in int aFlags;
in vec2 aWidths;
in vec2 aRadii;
in vec4 aClipParams1;
in vec4 aClipParams2;
void main ()
{
  int mix_colors_1;
  int tmpvar_2;
  tmpvar_2 = (aFlags & 255);
  bool tmpvar_3;
  tmpvar_3 = (((aFlags >> 24) & 240) != 0);
  vec2 p_4;
  bool tmpvar_5;
  bool tmpvar_6;
  tmpvar_6 = bool(0);
  tmpvar_5 = (0 == tmpvar_2);
  if (tmpvar_5) {
    p_4 = vec2(0.0, 0.0);
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (1 == tmpvar_2));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    p_4 = vec2(1.0, 0.0);
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (2 == tmpvar_2));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    p_4 = vec2(1.0, 1.0);
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (3 == tmpvar_2));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    p_4 = vec2(0.0, 1.0);
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = !(tmpvar_6);
  if (tmpvar_5) {
    p_4 = vec2(0.0, 0.0);
    tmpvar_6 = bool(1);
  };
  vec2 tmpvar_7;
  tmpvar_7 = (aRect.zw - aRect.xy);
  vec2 tmpvar_8;
  tmpvar_8 = (p_4 * tmpvar_7);
  vec2 tmpvar_9;
  tmpvar_9 = (1.0 - (2.0 * p_4));
  bool tmpvar_10;
  bool tmpvar_11;
  tmpvar_11 = bool(0);
  tmpvar_10 = (0 == tmpvar_2);
  tmpvar_10 = (tmpvar_10 || (1 == tmpvar_2));
  tmpvar_10 = (tmpvar_10 || (2 == tmpvar_2));
  tmpvar_10 = (tmpvar_10 || (3 == tmpvar_2));
  if (tmpvar_10) {
    int tmpvar_12;
    if (tmpvar_3) {
      tmpvar_12 = 1;
    } else {
      tmpvar_12 = 2;
    };
    mix_colors_1 = tmpvar_12;
    tmpvar_11 = bool(1);
  };
  tmpvar_10 = !(tmpvar_11);
  if (tmpvar_10) {
    mix_colors_1 = 0;
    tmpvar_11 = bool(1);
  };
  vMixColors.x = mix_colors_1;
  vPos = (tmpvar_7 * aPosition);
  vColor0 = aColor0;
  vColor1 = aColor1;
  vec4 tmpvar_13;
  tmpvar_13.xy = (tmpvar_8 + (tmpvar_9 * aRadii));
  tmpvar_13.zw = tmpvar_9;
  vClipCenter_Sign = tmpvar_13;
  vec4 tmpvar_14;
  tmpvar_14.xy = aRadii;
  tmpvar_14.zw = max ((aRadii - aWidths), 0.0);
  vClipRadii = tmpvar_14;
  vec4 tmpvar_15;
  tmpvar_15.xy = tmpvar_8;
  tmpvar_15.z = (aWidths.y * -(tmpvar_9.y));
  tmpvar_15.w = (aWidths.x * tmpvar_9.x);
  vColorLine = tmpvar_15;
  vec2 tmpvar_16;
  tmpvar_16.x = -(tmpvar_9.x);
  tmpvar_16.y = tmpvar_9.y;
  vec4 tmpvar_17;
  tmpvar_17.xy = (aClipParams1.xy + (tmpvar_16 * aClipParams1.zw));
  tmpvar_17.zw = tmpvar_16;
  vHorizontalClipCenter_Sign = tmpvar_17;
  vHorizontalClipRadii = aClipParams1.zw;
  vec2 tmpvar_18;
  tmpvar_18.x = tmpvar_9.x;
  tmpvar_18.y = -(tmpvar_9.y);
  vec4 tmpvar_19;
  tmpvar_19.xy = (aClipParams2.xy + (tmpvar_18 * aClipParams2.zw));
  tmpvar_19.zw = tmpvar_18;
  vVerticalClipCenter_Sign = tmpvar_19;
  vVerticalClipRadii = aClipParams2.zw;
  vec4 tmpvar_20;
  tmpvar_20.zw = vec2(0.0, 1.0);
  tmpvar_20.xy = ((aTaskOrigin + aRect.xy) + vPos);
  gl_Position = (uTransform * tmpvar_20);
}

#version 150
// cs_border_solid
// features: []

precision highp float;
out vec4 oFragColor;
flat in vec4 vColor0;
flat in vec4 vColor1;
flat in vec4 vColorLine;
flat in ivec2 vMixColors;
flat in vec4 vClipCenter_Sign;
flat in vec4 vClipRadii;
flat in vec4 vHorizontalClipCenter_Sign;
flat in vec2 vHorizontalClipRadii;
flat in vec4 vVerticalClipCenter_Sign;
flat in vec2 vVerticalClipRadii;
in vec2 vPos;
void main ()
{
  float d_1;
  vec2 clip_relative_pos_2;
  float mix_factor_3;
  vec2 tmpvar_4;
  tmpvar_4 = (abs(dFdx(vPos)) + abs(dFdy(vPos)));
  float tmpvar_5;
  tmpvar_5 = inversesqrt((0.5 * dot (tmpvar_4, tmpvar_4)));
  bool tmpvar_6;
  tmpvar_6 = (vMixColors.x != 2);
  mix_factor_3 = 0.0;
  if ((vMixColors.x != 0)) {
    float tmpvar_7;
    tmpvar_7 = dot ((vColorLine.zw * inversesqrt(
      dot (vColorLine.zw, vColorLine.zw)
    )), (vColorLine.xy - vPos));
    if (tmpvar_6) {
      mix_factor_3 = min (max ((0.5 - 
        (-(tmpvar_7) * tmpvar_5)
      ), 0.0), 1.0);
    } else {
      float tmpvar_8;
      if ((tmpvar_7 >= -0.0001)) {
        tmpvar_8 = 1.0;
      } else {
        tmpvar_8 = 0.0;
      };
      mix_factor_3 = tmpvar_8;
    };
  };
  vec2 tmpvar_9;
  tmpvar_9 = (vPos - vClipCenter_Sign.xy);
  clip_relative_pos_2 = tmpvar_9;
  d_1 = -1.0;
  if ((lessThan ((vClipCenter_Sign.zw * tmpvar_9), vec2(0.0, 0.0)) == bvec2(1, 1))) {
    float tmpvar_10;
    tmpvar_10 = float((lessThan (vec2(0.0, 0.0), vClipRadii.xy) == bvec2(1, 1)));
    vec2 tmpvar_11;
    tmpvar_11 = (tmpvar_9 * (1.0/(max (
      (vClipRadii.xy * vClipRadii.xy)
    , 1e-06))));
    vec2 tmpvar_12;
    tmpvar_12 = ((1.0 + tmpvar_10) * tmpvar_11);
    float tmpvar_13;
    tmpvar_13 = float((lessThan (vec2(0.0, 0.0), vClipRadii.zw) == bvec2(1, 1)));
    vec2 tmpvar_14;
    tmpvar_14 = (tmpvar_9 * (1.0/(max (
      (vClipRadii.zw * vClipRadii.zw)
    , 1e-06))));
    vec2 tmpvar_15;
    tmpvar_15 = ((1.0 + tmpvar_13) * tmpvar_14);
    d_1 = max (((
      dot (tmpvar_9, tmpvar_11)
     - tmpvar_10) * inversesqrt(
      dot (tmpvar_12, tmpvar_12)
    )), -((
      (dot (tmpvar_9, tmpvar_14) - tmpvar_13)
     * 
      inversesqrt(dot (tmpvar_15, tmpvar_15))
    )));
  };
  clip_relative_pos_2 = (vPos - vHorizontalClipCenter_Sign.xy);
  if ((lessThan ((vHorizontalClipCenter_Sign.zw * clip_relative_pos_2), vec2(0.0, 0.0)) == bvec2(1, 1))) {
    float tmpvar_16;
    tmpvar_16 = float((lessThan (vec2(0.0, 0.0), vHorizontalClipRadii) == bvec2(1, 1)));
    vec2 tmpvar_17;
    tmpvar_17 = (clip_relative_pos_2 * (1.0/(max (
      (vHorizontalClipRadii * vHorizontalClipRadii)
    , 1e-06))));
    vec2 tmpvar_18;
    tmpvar_18 = ((1.0 + tmpvar_16) * tmpvar_17);
    d_1 = max (((
      dot (clip_relative_pos_2, tmpvar_17)
     - tmpvar_16) * inversesqrt(
      dot (tmpvar_18, tmpvar_18)
    )), d_1);
  };
  clip_relative_pos_2 = (vPos - vVerticalClipCenter_Sign.xy);
  if ((lessThan ((vVerticalClipCenter_Sign.zw * clip_relative_pos_2), vec2(0.0, 0.0)) == bvec2(1, 1))) {
    float tmpvar_19;
    tmpvar_19 = float((lessThan (vec2(0.0, 0.0), vVerticalClipRadii) == bvec2(1, 1)));
    vec2 tmpvar_20;
    tmpvar_20 = (clip_relative_pos_2 * (1.0/(max (
      (vVerticalClipRadii * vVerticalClipRadii)
    , 1e-06))));
    vec2 tmpvar_21;
    tmpvar_21 = ((1.0 + tmpvar_19) * tmpvar_20);
    d_1 = max (((
      dot (clip_relative_pos_2, tmpvar_20)
     - tmpvar_19) * inversesqrt(
      dot (tmpvar_21, tmpvar_21)
    )), d_1);
  };
  float tmpvar_22;
  if (tmpvar_6) {
    tmpvar_22 = min (max ((0.5 - 
      (d_1 * tmpvar_5)
    ), 0.0), 1.0);
  } else {
    tmpvar_22 = 1.0;
  };
  oFragColor = (mix (vColor0, vColor1, mix_factor_3) * tmpvar_22);
}

cs_clip_box_shadow_TEXTURE_2D#version 150
// cs_clip_box_shadow
// features: ["TEXTURE_2D"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
in vec4 aClipDeviceArea;
in vec4 aClipOrigins;
in float aDevicePixelScale;
in ivec2 aTransformIds;
out vec4 vLocalPos;
out vec2 vUv;
flat out vec4 vUvBounds;
flat out vec4 vEdge;
flat out vec4 vUvBounds_NoClamp;
flat out vec2 vClipMode;
in ivec2 aClipDataResourceAddress;
in vec2 aClipSrcRectSize;
in int aClipMode;
in ivec2 aStretchMode;
in vec4 aClipDestRect;
void main ()
{
  mat4 transform_m_1;
  mat4 transform_inv_m_2;
  int tmpvar_3;
  tmpvar_3 = (aTransformIds.x & 16777215);
  ivec2 tmpvar_4;
  tmpvar_4.x = int((8u * (
    uint(tmpvar_3)
   % 128u)));
  tmpvar_4.y = int((uint(tmpvar_3) / 128u));
  transform_m_1[0] = texelFetchOffset (sTransformPalette, tmpvar_4, 0, ivec2(0, 0));
  transform_m_1[1] = texelFetchOffset (sTransformPalette, tmpvar_4, 0, ivec2(1, 0));
  transform_m_1[2] = texelFetchOffset (sTransformPalette, tmpvar_4, 0, ivec2(2, 0));
  transform_m_1[3] = texelFetchOffset (sTransformPalette, tmpvar_4, 0, ivec2(3, 0));
  transform_inv_m_2[0] = texelFetchOffset (sTransformPalette, tmpvar_4, 0, ivec2(4, 0));
  transform_inv_m_2[1] = texelFetchOffset (sTransformPalette, tmpvar_4, 0, ivec2(5, 0));
  transform_inv_m_2[2] = texelFetchOffset (sTransformPalette, tmpvar_4, 0, ivec2(6, 0));
  transform_inv_m_2[3] = texelFetchOffset (sTransformPalette, tmpvar_4, 0, ivec2(7, 0));
  mat4 transform_m_5;
  int tmpvar_6;
  tmpvar_6 = (aTransformIds.y & 16777215);
  ivec2 tmpvar_7;
  tmpvar_7.x = int((8u * (
    uint(tmpvar_6)
   % 128u)));
  tmpvar_7.y = int((uint(tmpvar_6) / 128u));
  transform_m_5[0] = texelFetchOffset (sTransformPalette, tmpvar_7, 0, ivec2(0, 0));
  transform_m_5[1] = texelFetchOffset (sTransformPalette, tmpvar_7, 0, ivec2(1, 0));
  transform_m_5[2] = texelFetchOffset (sTransformPalette, tmpvar_7, 0, ivec2(2, 0));
  transform_m_5[3] = texelFetchOffset (sTransformPalette, tmpvar_7, 0, ivec2(3, 0));
  vec2 tmpvar_8;
  vec2 tmpvar_9;
  tmpvar_8 = aClipDestRect.xy;
  tmpvar_9 = aClipDestRect.zw;
  vec2 uv_rect_p0_10;
  vec2 uv_rect_p1_11;
  vec4 tmpvar_12;
  tmpvar_12 = texelFetchOffset (sGpuCache, aClipDataResourceAddress, 0, ivec2(0, 0));
  uv_rect_p0_10 = tmpvar_12.xy;
  uv_rect_p1_11 = tmpvar_12.zw;
  vec4 pos_13;
  vec4 tmpvar_14;
  tmpvar_14.zw = vec2(0.0, 1.0);
  tmpvar_14.xy = ((aClipOrigins.zw + mix (aClipDeviceArea.xy, aClipDeviceArea.zw, aPosition)) / aDevicePixelScale);
  vec4 tmpvar_15;
  tmpvar_15 = (transform_m_5 * tmpvar_14);
  pos_13.w = tmpvar_15.w;
  pos_13.xyz = (tmpvar_15.xyz / tmpvar_15.w);
  vec2 tmpvar_16;
  tmpvar_16 = pos_13.xy;
  vec4 tmpvar_17;
  tmpvar_17 = (transform_m_1 * vec4(0.0, 0.0, 0.0, 1.0));
  vec3 tmpvar_18;
  vec3 tmpvar_19;
  vec3 tmpvar_20;
  tmpvar_18 = transform_inv_m_2[uint(0)].xyz;
  tmpvar_19 = transform_inv_m_2[1u].xyz;
  tmpvar_20 = transform_inv_m_2[2u].xyz;
  mat3 tmpvar_21;
  tmpvar_21[0].x = tmpvar_18.x;
  tmpvar_21[1].x = tmpvar_18.y;
  tmpvar_21[2].x = tmpvar_18.z;
  tmpvar_21[0].y = tmpvar_19.x;
  tmpvar_21[1].y = tmpvar_19.y;
  tmpvar_21[2].y = tmpvar_19.z;
  tmpvar_21[0].z = tmpvar_20.x;
  tmpvar_21[1].z = tmpvar_20.y;
  tmpvar_21[2].z = tmpvar_20.z;
  vec3 tmpvar_22;
  tmpvar_22.z = -10000.0;
  tmpvar_22.xy = tmpvar_16;
  vec3 tmpvar_23;
  tmpvar_23 = (tmpvar_21 * vec3(0.0, 0.0, 1.0));
  vec3 tmpvar_24;
  tmpvar_24 = (tmpvar_17.xyz / tmpvar_17.w);
  float tmpvar_25;
  float tmpvar_26;
  tmpvar_26 = dot (tmpvar_23, vec3(0.0, 0.0, 1.0));
  float tmpvar_27;
  tmpvar_27 = abs(tmpvar_26);
  if ((1e-06 < tmpvar_27)) {
    tmpvar_25 = (dot ((tmpvar_24 - tmpvar_22), tmpvar_23) / tmpvar_26);
  };
  vec4 tmpvar_28;
  tmpvar_28.w = 1.0;
  tmpvar_28.xy = tmpvar_16;
  tmpvar_28.z = (-10000.0 + tmpvar_25);
  vec4 tmpvar_29;
  tmpvar_29 = ((transform_inv_m_2 * tmpvar_28) * tmpvar_15.w);
  vec4 tmpvar_30;
  tmpvar_30.zw = vec2(0.0, 1.0);
  tmpvar_30.xy = (aClipOrigins.xy + mix (aClipDeviceArea.xy, aClipDeviceArea.zw, aPosition));
  gl_Position = (uTransform * tmpvar_30);
  vec4 tmpvar_31;
  tmpvar_31.xy = tmpvar_8;
  tmpvar_31.zw = tmpvar_9;
  vTransformBounds = tmpvar_31;
  vClipMode.x = float(aClipMode);
  vec2 tmpvar_32;
  tmpvar_32 = vec2(textureSize (sColor0, 0));
  vec2 tmpvar_33;
  tmpvar_33 = (tmpvar_29.xy / tmpvar_29.w);
  vLocalPos = tmpvar_29;
  vec2 tmpvar_34;
  tmpvar_34 = (aClipDestRect.zw - aClipDestRect.xy);
  bool tmpvar_35;
  bool tmpvar_36;
  tmpvar_36 = bool(0);
  tmpvar_35 = (0 == aStretchMode.x);
  if (tmpvar_35) {
    vEdge.x = 0.5;
    vEdge.z = ((tmpvar_34.x / aClipSrcRectSize.x) - 0.5);
    vUv.x = ((tmpvar_33.x - aClipDestRect.x) / aClipSrcRectSize.x);
    tmpvar_36 = bool(1);
  };
  tmpvar_35 = !(tmpvar_36);
  if (tmpvar_35) {
    vEdge.xz = vec2(1.0, 1.0);
    vUv.x = ((tmpvar_33.x - aClipDestRect.x) / tmpvar_34.x);
    tmpvar_36 = bool(1);
  };
  bool tmpvar_37;
  bool tmpvar_38;
  tmpvar_38 = bool(0);
  tmpvar_37 = (0 == aStretchMode.y);
  if (tmpvar_37) {
    vEdge.y = 0.5;
    vEdge.w = ((tmpvar_34.y / aClipSrcRectSize.y) - 0.5);
    vUv.y = ((tmpvar_33.y - aClipDestRect.y) / aClipSrcRectSize.y);
    tmpvar_38 = bool(1);
  };
  tmpvar_37 = !(tmpvar_38);
  if (tmpvar_37) {
    vEdge.yw = vec2(1.0, 1.0);
    vUv.y = ((tmpvar_33.y - aClipDestRect.y) / tmpvar_34.y);
    tmpvar_38 = bool(1);
  };
  vUv = (vUv * tmpvar_29.w);
  vec4 tmpvar_39;
  tmpvar_39.xy = (tmpvar_12.xy + vec2(0.5, 0.5));
  tmpvar_39.zw = (tmpvar_12.zw - vec2(0.5, 0.5));
  vUvBounds = (tmpvar_39 / tmpvar_32.xyxy);
  vec4 tmpvar_40;
  tmpvar_40.xy = uv_rect_p0_10;
  tmpvar_40.zw = uv_rect_p1_11;
  vUvBounds_NoClamp = (tmpvar_40 / tmpvar_32.xyxy);
}

#version 150
// cs_clip_box_shadow
// features: ["TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
flat in vec4 vTransformBounds;
in vec4 vLocalPos;
in vec2 vUv;
flat in vec4 vUvBounds;
flat in vec4 vEdge;
flat in vec4 vUvBounds_NoClamp;
flat in vec2 vClipMode;
void main ()
{
  vec2 uv_1;
  vec2 tmpvar_2;
  tmpvar_2 = (vUv / vLocalPos.w);
  uv_1 = (min (max (tmpvar_2, vec2(0.0, 0.0)), vEdge.xy) + max (vec2(0.0, 0.0), (tmpvar_2 - vEdge.zw)));
  vec2 tmpvar_3;
  tmpvar_3 = min (max (mix (vUvBounds_NoClamp.xy, vUvBounds_NoClamp.zw, uv_1), vUvBounds.xy), vUvBounds.zw);
  uv_1 = tmpvar_3;
  vec2 tmpvar_4;
  tmpvar_4 = (vLocalPos.xy / vLocalPos.w);
  float tmpvar_5;
  vec2 tmpvar_6;
  tmpvar_6.x = float((tmpvar_4.x >= vTransformBounds.z));
  tmpvar_6.y = float((tmpvar_4.y >= vTransformBounds.w));
  vec2 tmpvar_7;
  tmpvar_7 = (vec2(greaterThanEqual (tmpvar_4, vTransformBounds.xy)) - tmpvar_6);
  tmpvar_5 = (tmpvar_7.x * tmpvar_7.y);
  vec4 tmpvar_8;
  tmpvar_8 = texture (sColor0, tmpvar_3);
  float tmpvar_9;
  tmpvar_9 = mix (tmpvar_8.x, (1.0 - tmpvar_8.x), vClipMode.x);
  float tmpvar_10;
  if ((0.0 < vLocalPos.w)) {
    tmpvar_10 = mix (vClipMode.x, tmpvar_9, tmpvar_5);
  } else {
    tmpvar_10 = 0.0;
  };
  oFragColor = vec4(tmpvar_10);
}

cs_clip_image_TEXTURE_2D#version 150
// cs_clip_image
// features: ["TEXTURE_2D"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sGpuCache;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
in vec4 aClipOrigins;
in float aDevicePixelScale;
in ivec2 aTransformIds;
out vec2 vLocalPos;
out vec2 vClipMaskImageUv;
flat out vec4 vClipMaskUvInnerRect;
in vec4 aClipTileRect;
in ivec2 aClipDataResourceAddress;
in vec4 aClipLocalRect;
void main ()
{
  vec2 tmpvar_1;
  vec2 tmpvar_2;
  tmpvar_1 = aClipLocalRect.xy;
  tmpvar_2 = aClipLocalRect.zw;
  mat4 transform_m_3;
  int tmpvar_4;
  tmpvar_4 = (aTransformIds.y & 16777215);
  ivec2 tmpvar_5;
  tmpvar_5.x = int((8u * (
    uint(tmpvar_4)
   % 128u)));
  tmpvar_5.y = int((uint(tmpvar_4) / 128u));
  transform_m_3[0] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(0, 0));
  transform_m_3[1] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(1, 0));
  transform_m_3[2] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(2, 0));
  transform_m_3[3] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(3, 0));
  vec2 uv_rect_p0_6;
  vec2 uv_rect_p1_7;
  vec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sGpuCache, aClipDataResourceAddress, 0, ivec2(0, 0));
  uv_rect_p0_6 = tmpvar_8.xy;
  uv_rect_p1_7 = tmpvar_8.zw;
  vec2 tmpvar_9;
  tmpvar_9 = min (max (mix (aClipTileRect.xy, aClipTileRect.zw, aPosition), aClipLocalRect.xy), aClipLocalRect.zw);
  vec4 tmpvar_10;
  tmpvar_10.zw = vec2(0.0, 1.0);
  tmpvar_10.xy = tmpvar_9;
  vec4 tmpvar_11;
  tmpvar_11 = (transform_m_3 * tmpvar_10);
  vec4 tmpvar_12;
  tmpvar_12.z = 0.0;
  tmpvar_12.xy = ((tmpvar_11.xy * aDevicePixelScale) + ((aClipOrigins.xy - aClipOrigins.zw) * tmpvar_11.w));
  tmpvar_12.w = tmpvar_11.w;
  gl_Position = (uTransform * tmpvar_12);
  vec4 tmpvar_13;
  if (((aTransformIds.x >> 24) == 0)) {
    tmpvar_13 = vec4(-1e+16, -1e+16, 1e+16, 1e+16);
  } else {
    vec4 tmpvar_14;
    tmpvar_14.xy = tmpvar_1;
    tmpvar_14.zw = tmpvar_2;
    tmpvar_13 = tmpvar_14;
  };
  vTransformBounds = tmpvar_13;
  vLocalPos = tmpvar_9;
  vec2 tmpvar_15;
  tmpvar_15 = vec2(textureSize (sColor0, 0));
  vec4 tmpvar_16;
  tmpvar_16.xy = uv_rect_p0_6;
  tmpvar_16.zw = uv_rect_p1_7;
  vClipMaskImageUv = (mix (tmpvar_8.xy, tmpvar_8.zw, (
    (tmpvar_9 - aClipTileRect.xy)
   / 
    (aClipTileRect.zw - aClipTileRect.xy)
  )) / tmpvar_15);
  vClipMaskUvInnerRect = ((tmpvar_16 + vec4(0.5, 0.5, -0.5, -0.5)) / tmpvar_15.xyxy);
}

#version 150
// cs_clip_image
// features: ["TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
flat in vec4 vTransformBounds;
in vec2 vLocalPos;
in vec2 vClipMaskImageUv;
flat in vec4 vClipMaskUvInnerRect;
void main ()
{
  vec2 tmpvar_1;
  tmpvar_1.x = float((vLocalPos.x >= vTransformBounds.z));
  tmpvar_1.y = float((vLocalPos.y >= vTransformBounds.w));
  vec2 tmpvar_2;
  tmpvar_2 = (vec2(greaterThanEqual (vLocalPos, vTransformBounds.xy)) - tmpvar_1);
  vec4 tmpvar_3;
  tmpvar_3.yzw = vec3(0.0, 0.0, 1.0);
  tmpvar_3.x = mix (1.0, texture (sColor0, min (max (vClipMaskImageUv, vClipMaskUvInnerRect.xy), vClipMaskUvInnerRect.zw)).x, (tmpvar_2.x * tmpvar_2.y));
  oFragColor = tmpvar_3;
}

#version 150
// cs_clip_rectangle
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
in vec4 aClipDeviceArea;
in vec4 aClipOrigins;
in float aDevicePixelScale;
in ivec2 aTransformIds;
out vec4 vLocalPos;
flat out vec4 vClipCenter_Radius_TL;
flat out vec4 vClipCenter_Radius_TR;
flat out vec4 vClipCenter_Radius_BL;
flat out vec4 vClipCenter_Radius_BR;
flat out vec2 vClipMode;
in vec2 aClipLocalPos;
in vec4 aClipLocalRect;
in float aClipMode;
in vec4 aClipRadii_TL;
in vec4 aClipRadii_TR;
in vec4 aClipRadii_BL;
in vec4 aClipRadii_BR;
void main ()
{
  vec2 local_rect_p1_1;
  mat4 transform_m_2;
  mat4 transform_inv_m_3;
  int tmpvar_4;
  tmpvar_4 = (aTransformIds.x & 16777215);
  ivec2 tmpvar_5;
  tmpvar_5.x = int((8u * (
    uint(tmpvar_4)
   % 128u)));
  tmpvar_5.y = int((uint(tmpvar_4) / 128u));
  transform_m_2[0] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(0, 0));
  transform_m_2[1] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(1, 0));
  transform_m_2[2] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(2, 0));
  transform_m_2[3] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(3, 0));
  transform_inv_m_3[0] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(4, 0));
  transform_inv_m_3[1] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(5, 0));
  transform_inv_m_3[2] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(6, 0));
  transform_inv_m_3[3] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(7, 0));
  mat4 transform_m_6;
  int tmpvar_7;
  tmpvar_7 = (aTransformIds.y & 16777215);
  ivec2 tmpvar_8;
  tmpvar_8.x = int((8u * (
    uint(tmpvar_7)
   % 128u)));
  tmpvar_8.y = int((uint(tmpvar_7) / 128u));
  transform_m_6[0] = texelFetchOffset (sTransformPalette, tmpvar_8, 0, ivec2(0, 0));
  transform_m_6[1] = texelFetchOffset (sTransformPalette, tmpvar_8, 0, ivec2(1, 0));
  transform_m_6[2] = texelFetchOffset (sTransformPalette, tmpvar_8, 0, ivec2(2, 0));
  transform_m_6[3] = texelFetchOffset (sTransformPalette, tmpvar_8, 0, ivec2(3, 0));
  local_rect_p1_1 = (aClipLocalRect.zw + (aClipLocalPos - aClipLocalRect.xy));
  vec4 pos_9;
  vec4 tmpvar_10;
  tmpvar_10.zw = vec2(0.0, 1.0);
  tmpvar_10.xy = ((aClipOrigins.zw + mix (aClipDeviceArea.xy, aClipDeviceArea.zw, aPosition)) / aDevicePixelScale);
  vec4 tmpvar_11;
  tmpvar_11 = (transform_m_6 * tmpvar_10);
  pos_9.w = tmpvar_11.w;
  pos_9.xyz = (tmpvar_11.xyz / tmpvar_11.w);
  vec2 tmpvar_12;
  tmpvar_12 = pos_9.xy;
  vec4 tmpvar_13;
  tmpvar_13 = (transform_m_2 * vec4(0.0, 0.0, 0.0, 1.0));
  vec3 tmpvar_14;
  vec3 tmpvar_15;
  vec3 tmpvar_16;
  tmpvar_14 = transform_inv_m_3[uint(0)].xyz;
  tmpvar_15 = transform_inv_m_3[1u].xyz;
  tmpvar_16 = transform_inv_m_3[2u].xyz;
  mat3 tmpvar_17;
  tmpvar_17[0].x = tmpvar_14.x;
  tmpvar_17[1].x = tmpvar_14.y;
  tmpvar_17[2].x = tmpvar_14.z;
  tmpvar_17[0].y = tmpvar_15.x;
  tmpvar_17[1].y = tmpvar_15.y;
  tmpvar_17[2].y = tmpvar_15.z;
  tmpvar_17[0].z = tmpvar_16.x;
  tmpvar_17[1].z = tmpvar_16.y;
  tmpvar_17[2].z = tmpvar_16.z;
  vec3 tmpvar_18;
  tmpvar_18.z = -10000.0;
  tmpvar_18.xy = tmpvar_12;
  vec3 tmpvar_19;
  tmpvar_19 = (tmpvar_17 * vec3(0.0, 0.0, 1.0));
  vec3 tmpvar_20;
  tmpvar_20 = (tmpvar_13.xyz / tmpvar_13.w);
  float tmpvar_21;
  float tmpvar_22;
  tmpvar_22 = dot (tmpvar_19, vec3(0.0, 0.0, 1.0));
  float tmpvar_23;
  tmpvar_23 = abs(tmpvar_22);
  if ((1e-06 < tmpvar_23)) {
    tmpvar_21 = (dot ((tmpvar_20 - tmpvar_18), tmpvar_19) / tmpvar_22);
  };
  vec4 tmpvar_24;
  tmpvar_24.w = 1.0;
  tmpvar_24.xy = tmpvar_12;
  tmpvar_24.z = (-10000.0 + tmpvar_21);
  vec4 tmpvar_25;
  tmpvar_25.zw = vec2(0.0, 1.0);
  tmpvar_25.xy = (aClipOrigins.xy + mix (aClipDeviceArea.xy, aClipDeviceArea.zw, aPosition));
  gl_Position = (uTransform * tmpvar_25);
  vec4 tmpvar_26;
  tmpvar_26.xy = aClipLocalPos;
  tmpvar_26.zw = local_rect_p1_1;
  vTransformBounds = tmpvar_26;
  vClipMode.x = aClipMode;
  vLocalPos = ((transform_inv_m_3 * tmpvar_24) * tmpvar_11.w);
  vec4 tmpvar_27;
  tmpvar_27.xy = (aClipLocalPos + aClipRadii_TL.xy);
  tmpvar_27.zw = (1.0/(max ((aClipRadii_TL.xy * aClipRadii_TL.xy), 1e-06)));
  vClipCenter_Radius_TL = tmpvar_27;
  vec4 tmpvar_28;
  tmpvar_28.x = (local_rect_p1_1.x - aClipRadii_TR.x);
  tmpvar_28.y = (aClipLocalPos.y + aClipRadii_TR.y);
  tmpvar_28.zw = (1.0/(max ((aClipRadii_TR.xy * aClipRadii_TR.xy), 1e-06)));
  vClipCenter_Radius_TR = tmpvar_28;
  vec4 tmpvar_29;
  tmpvar_29.xy = (local_rect_p1_1 - aClipRadii_BR.xy);
  tmpvar_29.zw = (1.0/(max ((aClipRadii_BR.xy * aClipRadii_BR.xy), 1e-06)));
  vClipCenter_Radius_BR = tmpvar_29;
  vec4 tmpvar_30;
  tmpvar_30.x = (aClipLocalPos.x + aClipRadii_BL.x);
  tmpvar_30.y = (local_rect_p1_1.y - aClipRadii_BL.y);
  tmpvar_30.zw = (1.0/(max ((aClipRadii_BL.xy * aClipRadii_BL.xy), 1e-06)));
  vClipCenter_Radius_BL = tmpvar_30;
}

#version 150
// cs_clip_rectangle
// features: []

precision highp float;
out vec4 oFragColor;
flat in vec4 vTransformBounds;
in vec4 vLocalPos;
flat in vec4 vClipCenter_Radius_TL;
flat in vec4 vClipCenter_Radius_TR;
flat in vec4 vClipCenter_Radius_BL;
flat in vec4 vClipCenter_Radius_BR;
flat in vec2 vClipMode;
void main ()
{
  vec2 tmpvar_1;
  tmpvar_1 = (vLocalPos.xy / vLocalPos.w);
  vec2 tmpvar_2;
  tmpvar_2 = (abs(dFdx(tmpvar_1)) + abs(dFdy(tmpvar_1)));
  float tmpvar_3;
  tmpvar_3 = inversesqrt((0.5 * dot (tmpvar_2, tmpvar_2)));
  vec4 tmpvar_4;
  tmpvar_4.zw = vClipCenter_Radius_TL.zw;
  vec4 tmpvar_5;
  tmpvar_5.zw = vClipCenter_Radius_TR.zw;
  vec4 tmpvar_6;
  tmpvar_6.zw = vClipCenter_Radius_BR.zw;
  vec4 tmpvar_7;
  tmpvar_7.zw = vClipCenter_Radius_BL.zw;
  vec4 corner_8;
  corner_8 = vec4(1e-06, 1e-06, 1.0, 1.0);
  tmpvar_4.xy = (vClipCenter_Radius_TL.xy - tmpvar_1);
  tmpvar_5.xy = ((vClipCenter_Radius_TR.xy - tmpvar_1) * vec2(-1.0, 1.0));
  tmpvar_6.xy = (tmpvar_1 - vClipCenter_Radius_BR.xy);
  tmpvar_7.xy = ((vClipCenter_Radius_BL.xy - tmpvar_1) * vec2(1.0, -1.0));
  float tmpvar_9;
  tmpvar_9 = min (tmpvar_4.x, tmpvar_4.y);
  if ((1e-06 < tmpvar_9)) {
    corner_8 = tmpvar_4;
  };
  float tmpvar_10;
  tmpvar_10 = min (tmpvar_5.x, tmpvar_5.y);
  float tmpvar_11;
  tmpvar_11 = min (corner_8.x, corner_8.y);
  if ((tmpvar_11 < tmpvar_10)) {
    corner_8 = tmpvar_5;
  };
  float tmpvar_12;
  tmpvar_12 = min (tmpvar_6.x, tmpvar_6.y);
  float tmpvar_13;
  tmpvar_13 = min (corner_8.x, corner_8.y);
  if ((tmpvar_13 < tmpvar_12)) {
    corner_8 = tmpvar_6;
  };
  float tmpvar_14;
  tmpvar_14 = min (tmpvar_7.x, tmpvar_7.y);
  float tmpvar_15;
  tmpvar_15 = min (corner_8.x, corner_8.y);
  if ((tmpvar_15 < tmpvar_14)) {
    corner_8 = tmpvar_7;
  };
  vec2 tmpvar_16;
  tmpvar_16 = (corner_8.xy * corner_8.zw);
  vec2 tmpvar_17;
  tmpvar_17 = (2.0 * tmpvar_16);
  vec2 tmpvar_18;
  tmpvar_18 = max ((vTransformBounds.xy - tmpvar_1), (tmpvar_1 - vTransformBounds.zw));
  float tmpvar_19;
  tmpvar_19 = min (max ((0.5 - 
    (max (((
      dot (corner_8.xy, tmpvar_16)
     - 1.0) * inversesqrt(
      dot (tmpvar_17, tmpvar_17)
    )), max (tmpvar_18.x, tmpvar_18.y)) * tmpvar_3)
  ), 0.0), 1.0);
  float tmpvar_20;
  tmpvar_20 = mix (tmpvar_19, (1.0 - tmpvar_19), vClipMode.x);
  float tmpvar_21;
  if ((0.0 < vLocalPos.w)) {
    tmpvar_21 = tmpvar_20;
  } else {
    tmpvar_21 = 0.0;
  };
  vec4 tmpvar_22;
  tmpvar_22.yzw = vec3(0.0, 0.0, 1.0);
  tmpvar_22.x = tmpvar_21;
  oFragColor = tmpvar_22;
}

cs_clip_rectangle_FAST_PATH#version 150
// cs_clip_rectangle
// features: ["FAST_PATH"]

uniform mat4 uTransform;
in vec2 aPosition;
flat out vec4 vTransformBounds;
uniform sampler2D sTransformPalette;
in vec4 aClipDeviceArea;
in vec4 aClipOrigins;
in float aDevicePixelScale;
in ivec2 aTransformIds;
out vec4 vLocalPos;
flat out vec3 vClipParams;
flat out vec2 vClipMode;
in vec2 aClipLocalPos;
in vec4 aClipLocalRect;
in float aClipMode;
in vec4 aClipRadii_TL;
void main ()
{
  vec2 local_rect_p1_1;
  mat4 transform_m_2;
  mat4 transform_inv_m_3;
  int tmpvar_4;
  tmpvar_4 = (aTransformIds.x & 16777215);
  ivec2 tmpvar_5;
  tmpvar_5.x = int((8u * (
    uint(tmpvar_4)
   % 128u)));
  tmpvar_5.y = int((uint(tmpvar_4) / 128u));
  transform_m_2[0] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(0, 0));
  transform_m_2[1] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(1, 0));
  transform_m_2[2] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(2, 0));
  transform_m_2[3] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(3, 0));
  transform_inv_m_3[0] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(4, 0));
  transform_inv_m_3[1] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(5, 0));
  transform_inv_m_3[2] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(6, 0));
  transform_inv_m_3[3] = texelFetchOffset (sTransformPalette, tmpvar_5, 0, ivec2(7, 0));
  mat4 transform_m_6;
  int tmpvar_7;
  tmpvar_7 = (aTransformIds.y & 16777215);
  ivec2 tmpvar_8;
  tmpvar_8.x = int((8u * (
    uint(tmpvar_7)
   % 128u)));
  tmpvar_8.y = int((uint(tmpvar_7) / 128u));
  transform_m_6[0] = texelFetchOffset (sTransformPalette, tmpvar_8, 0, ivec2(0, 0));
  transform_m_6[1] = texelFetchOffset (sTransformPalette, tmpvar_8, 0, ivec2(1, 0));
  transform_m_6[2] = texelFetchOffset (sTransformPalette, tmpvar_8, 0, ivec2(2, 0));
  transform_m_6[3] = texelFetchOffset (sTransformPalette, tmpvar_8, 0, ivec2(3, 0));
  local_rect_p1_1 = (aClipLocalRect.zw + (aClipLocalPos - aClipLocalRect.xy));
  vec4 pos_9;
  vec4 tmpvar_10;
  tmpvar_10.zw = vec2(0.0, 1.0);
  tmpvar_10.xy = ((aClipOrigins.zw + mix (aClipDeviceArea.xy, aClipDeviceArea.zw, aPosition)) / aDevicePixelScale);
  vec4 tmpvar_11;
  tmpvar_11 = (transform_m_6 * tmpvar_10);
  pos_9.w = tmpvar_11.w;
  pos_9.xyz = (tmpvar_11.xyz / tmpvar_11.w);
  vec2 tmpvar_12;
  tmpvar_12 = pos_9.xy;
  vec4 tmpvar_13;
  tmpvar_13 = (transform_m_2 * vec4(0.0, 0.0, 0.0, 1.0));
  vec3 tmpvar_14;
  vec3 tmpvar_15;
  vec3 tmpvar_16;
  tmpvar_14 = transform_inv_m_3[uint(0)].xyz;
  tmpvar_15 = transform_inv_m_3[1u].xyz;
  tmpvar_16 = transform_inv_m_3[2u].xyz;
  mat3 tmpvar_17;
  tmpvar_17[0].x = tmpvar_14.x;
  tmpvar_17[1].x = tmpvar_14.y;
  tmpvar_17[2].x = tmpvar_14.z;
  tmpvar_17[0].y = tmpvar_15.x;
  tmpvar_17[1].y = tmpvar_15.y;
  tmpvar_17[2].y = tmpvar_15.z;
  tmpvar_17[0].z = tmpvar_16.x;
  tmpvar_17[1].z = tmpvar_16.y;
  tmpvar_17[2].z = tmpvar_16.z;
  vec3 tmpvar_18;
  tmpvar_18.z = -10000.0;
  tmpvar_18.xy = tmpvar_12;
  vec3 tmpvar_19;
  tmpvar_19 = (tmpvar_17 * vec3(0.0, 0.0, 1.0));
  vec3 tmpvar_20;
  tmpvar_20 = (tmpvar_13.xyz / tmpvar_13.w);
  float tmpvar_21;
  float tmpvar_22;
  tmpvar_22 = dot (tmpvar_19, vec3(0.0, 0.0, 1.0));
  float tmpvar_23;
  tmpvar_23 = abs(tmpvar_22);
  if ((1e-06 < tmpvar_23)) {
    tmpvar_21 = (dot ((tmpvar_20 - tmpvar_18), tmpvar_19) / tmpvar_22);
  };
  vec4 tmpvar_24;
  tmpvar_24.w = 1.0;
  tmpvar_24.xy = tmpvar_12;
  tmpvar_24.z = (-10000.0 + tmpvar_21);
  vec4 tmpvar_25;
  tmpvar_25 = ((transform_inv_m_3 * tmpvar_24) * tmpvar_11.w);
  vec4 tmpvar_26;
  tmpvar_26.zw = vec2(0.0, 1.0);
  tmpvar_26.xy = (aClipOrigins.xy + mix (aClipDeviceArea.xy, aClipDeviceArea.zw, aPosition));
  gl_Position = (uTransform * tmpvar_26);
  vec4 tmpvar_27;
  tmpvar_27.xy = aClipLocalPos;
  tmpvar_27.zw = local_rect_p1_1;
  vTransformBounds = tmpvar_27;
  vClipMode.x = aClipMode;
  vLocalPos.zw = tmpvar_25.zw;
  vec2 tmpvar_28;
  tmpvar_28 = (0.5 * (local_rect_p1_1 - aClipLocalPos));
  vLocalPos.xy = (tmpvar_25.xy - ((tmpvar_28 + aClipLocalPos) * tmpvar_25.w));
  vec3 tmpvar_29;
  tmpvar_29.xy = (tmpvar_28 - aClipRadii_TL.xx);
  tmpvar_29.z = aClipRadii_TL.x;
  vClipParams = tmpvar_29;
}

#version 150
// cs_clip_rectangle
// features: ["FAST_PATH"]

precision highp float;
out vec4 oFragColor;
in vec4 vLocalPos;
flat in vec3 vClipParams;
flat in vec2 vClipMode;
void main ()
{
  vec2 tmpvar_1;
  tmpvar_1 = (vLocalPos.xy / vLocalPos.w);
  vec2 tmpvar_2;
  tmpvar_2 = (abs(dFdx(tmpvar_1)) + abs(dFdy(tmpvar_1)));
  vec2 tmpvar_3;
  tmpvar_3 = (abs(tmpvar_1) - vClipParams.xy);
  vec2 tmpvar_4;
  tmpvar_4 = max (tmpvar_3, vec2(0.0, 0.0));
  float tmpvar_5;
  tmpvar_5 = min (max ((0.5 - 
    (((sqrt(
      dot (tmpvar_4, tmpvar_4)
    ) + min (
      max (tmpvar_3.x, tmpvar_3.y)
    , 0.0)) - vClipParams.z) * inversesqrt((0.5 * dot (tmpvar_2, tmpvar_2))))
  ), 0.0), 1.0);
  float tmpvar_6;
  tmpvar_6 = mix (tmpvar_5, (1.0 - tmpvar_5), vClipMode.x);
  float tmpvar_7;
  if ((0.0 < vLocalPos.w)) {
    tmpvar_7 = tmpvar_6;
  } else {
    tmpvar_7 = 0.0;
  };
  vec4 tmpvar_8;
  tmpvar_8.yzw = vec3(0.0, 0.0, 1.0);
  tmpvar_8.x = tmpvar_7;
  oFragColor = tmpvar_8;
}

#version 150
// cs_conic_gradient
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
flat out ivec2 v_gradient_address;
flat out vec2 v_gradient_repeat;
out vec2 v_pos;
flat out vec2 v_center;
flat out vec3 v_start_offset_offset_scale_angle_vec;
in vec4 aTaskRect;
in vec2 aCenter;
in vec2 aScale;
in float aStartOffset;
in float aEndOffset;
in float aAngle;
in int aExtendMode;
in int aGradientStopsAddress;
void main ()
{
  float tmpvar_1;
  tmpvar_1 = (aEndOffset - aStartOffset);
  float tmpvar_2;
  if ((tmpvar_1 != 0.0)) {
    tmpvar_2 = (1.0/(tmpvar_1));
  } else {
    tmpvar_2 = 0.0;
  };
  v_start_offset_offset_scale_angle_vec.y = tmpvar_2;
  vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = mix (aTaskRect.xy, aTaskRect.zw, aPosition);
  gl_Position = (uTransform * tmpvar_3);
  v_start_offset_offset_scale_angle_vec.z = (1.570796 - aAngle);
  v_start_offset_offset_scale_angle_vec.x = (aStartOffset * tmpvar_2);
  v_center = (aCenter * tmpvar_2);
  v_pos = (((
    (aTaskRect.zw - aTaskRect.xy)
   * aPosition) * tmpvar_2) * aScale);
  v_gradient_repeat.x = float((aExtendMode == 1));
  v_gradient_address.x = aGradientStopsAddress;
}

#version 150
// cs_conic_gradient
// features: []

precision highp float;
out vec4 oFragColor;
uniform sampler2D sGpuCache;
flat in ivec2 v_gradient_address;
flat in vec2 v_gradient_repeat;
in vec2 v_pos;
flat in vec2 v_center;
flat in vec3 v_start_offset_offset_scale_angle_vec;
void main ()
{
  vec2 tmpvar_1;
  tmpvar_1 = (v_pos - v_center);
  float tmpvar_2;
  tmpvar_2 = ((fract(
    ((atan (tmpvar_1.y, tmpvar_1.x) + v_start_offset_offset_scale_angle_vec.z) / 6.283185)
  ) * v_start_offset_offset_scale_angle_vec.y) - v_start_offset_offset_scale_angle_vec.x);
  float tmpvar_3;
  tmpvar_3 = min (max ((1.0 + 
    ((tmpvar_2 - (floor(tmpvar_2) * v_gradient_repeat.x)) * 128.0)
  ), 0.0), 129.0);
  float tmpvar_4;
  tmpvar_4 = floor(tmpvar_3);
  int tmpvar_5;
  tmpvar_5 = (v_gradient_address.x + (2 * int(tmpvar_4)));
  ivec2 tmpvar_6;
  tmpvar_6.x = int((uint(tmpvar_5) % 1024u));
  tmpvar_6.y = int((uint(tmpvar_5) / 1024u));
  oFragColor = (texelFetchOffset (sGpuCache, tmpvar_6, 0, ivec2(0, 0)) + (texelFetchOffset (sGpuCache, tmpvar_6, 0, ivec2(1, 0)) * (tmpvar_3 - tmpvar_4)));
}

#version 150
// cs_fast_linear_gradient
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
out float vPos;
flat out vec4 vColor0;
flat out vec4 vColor1;
in vec4 aTaskRect;
in vec4 aColor0;
in vec4 aColor1;
in float aAxisSelect;
void main ()
{
  vPos = mix (aPosition.x, aPosition.y, aAxisSelect);
  vColor0 = aColor0;
  vColor1 = aColor1;
  vec4 tmpvar_1;
  tmpvar_1.zw = vec2(0.0, 1.0);
  tmpvar_1.xy = mix (aTaskRect.xy, aTaskRect.zw, aPosition);
  gl_Position = (uTransform * tmpvar_1);
}

#version 150
// cs_fast_linear_gradient
// features: []

precision highp float;
out vec4 oFragColor;
in float vPos;
flat in vec4 vColor0;
flat in vec4 vColor1;
void main ()
{
  oFragColor = mix (vColor0, vColor1, vPos);
}

#version 150
// cs_line_decoration
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
out vec2 vLocalPos;
flat out ivec2 vStyle;
flat out vec4 vParams;
in vec4 aTaskRect;
in vec2 aLocalSize;
in int aStyle;
in float aAxisSelect;
in float aWavyLineThickness;
void main ()
{
  vec2 tmpvar_1;
  tmpvar_1 = mix (aLocalSize, aLocalSize.yx, aAxisSelect);
  vStyle.x = aStyle;
  bool tmpvar_2;
  bool tmpvar_3;
  tmpvar_3 = bool(0);
  tmpvar_2 = (0 == aStyle);
  if (tmpvar_2) {
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (2 == aStyle));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    vec4 tmpvar_4;
    tmpvar_4.zw = vec2(0.0, 0.0);
    tmpvar_4.x = tmpvar_1.x;
    tmpvar_4.y = (0.5 * tmpvar_1.x);
    vParams = tmpvar_4;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (1 == aStyle));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    vec4 tmpvar_5;
    tmpvar_5.w = 0.0;
    tmpvar_5.x = (tmpvar_1.y * 2.0);
    tmpvar_5.y = (tmpvar_1.y / 2.0);
    tmpvar_5.z = (0.5 * tmpvar_1.y);
    vParams = tmpvar_5;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = (tmpvar_2 || (3 == aStyle));
  tmpvar_2 = (tmpvar_2 && !(tmpvar_3));
  if (tmpvar_2) {
    float tmpvar_6;
    tmpvar_6 = max (aWavyLineThickness, 1.0);
    vec4 tmpvar_7;
    tmpvar_7.x = (tmpvar_6 / 2.0);
    tmpvar_7.y = (tmpvar_1.y - tmpvar_6);
    tmpvar_7.z = max (((tmpvar_6 - 1.0) * 2.0), 1.0);
    tmpvar_7.w = tmpvar_1.y;
    vParams = tmpvar_7;
    tmpvar_3 = bool(1);
  };
  tmpvar_2 = !(tmpvar_3);
  if (tmpvar_2) {
    vParams = vec4(0.0, 0.0, 0.0, 0.0);
  };
  vLocalPos = (mix (aPosition, aPosition.yx, aAxisSelect) * tmpvar_1);
  vec4 tmpvar_8;
  tmpvar_8.zw = vec2(0.0, 1.0);
  tmpvar_8.xy = mix (aTaskRect.xy, aTaskRect.zw, aPosition);
  gl_Position = (uTransform * tmpvar_8);
}

#version 150
// cs_line_decoration
// features: []

precision highp float;
out vec4 oFragColor;
in vec2 vLocalPos;
flat in ivec2 vStyle;
flat in vec4 vParams;
void main ()
{
  float alpha_1;
  vec2 pos_2;
  pos_2 = vLocalPos;
  vec2 tmpvar_3;
  tmpvar_3 = (abs(dFdx(vLocalPos)) + abs(dFdy(vLocalPos)));
  float tmpvar_4;
  tmpvar_4 = inversesqrt((0.5 * dot (tmpvar_3, tmpvar_3)));
  alpha_1 = 1.0;
  bool tmpvar_5;
  bool tmpvar_6;
  tmpvar_6 = bool(0);
  tmpvar_5 = (0 == vStyle.x);
  if (tmpvar_5) {
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (2 == vStyle.x));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    alpha_1 = float((vParams.y >= floor(
      (vLocalPos.x + 0.5)
    )));
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (1 == vStyle.x));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    vec2 tmpvar_7;
    tmpvar_7 = (vLocalPos - vParams.yz);
    alpha_1 = min (max ((0.5 - 
      ((sqrt(dot (tmpvar_7, tmpvar_7)) - vParams.y) * tmpvar_4)
    ), 0.0), 1.0);
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = (tmpvar_5 || (3 == vStyle.x));
  tmpvar_5 = (tmpvar_5 && !(tmpvar_6));
  if (tmpvar_5) {
    float tmpvar_8;
    tmpvar_8 = (vParams.y + vParams.z);
    float tmpvar_9;
    tmpvar_9 = (vParams.w / 2.0);
    float tmpvar_10;
    tmpvar_10 = (-2.0 * (float(
      (tmpvar_8 >= (float(mod (vLocalPos.x, (2.0 * tmpvar_8)))))
    ) - 0.5));
    float tmpvar_11;
    tmpvar_11 = (tmpvar_9 + ((tmpvar_9 - vParams.x) * tmpvar_10));
    pos_2.x = (float(mod (vLocalPos.x, tmpvar_8)));
    vec2 tmpvar_12;
    tmpvar_12.x = 0.0;
    tmpvar_12.y = tmpvar_11;
    vec2 tmpvar_13;
    tmpvar_13.x = 1.0;
    tmpvar_13.y = -(tmpvar_10);
    vec2 tmpvar_14;
    tmpvar_14.x = 0.0;
    tmpvar_14.y = tmpvar_11;
    vec2 tmpvar_15;
    tmpvar_15.x = 0.0;
    tmpvar_15.y = -(tmpvar_10);
    vec2 tmpvar_16;
    tmpvar_16.x = vParams.z;
    tmpvar_16.y = tmpvar_11;
    vec2 tmpvar_17;
    tmpvar_17.x = -1.0;
    tmpvar_17.y = -(tmpvar_10);
    float tmpvar_18;
    tmpvar_18 = min (max ((0.5 - 
      ((abs(max (
        max (dot ((tmpvar_13 * inversesqrt(
          dot (tmpvar_13, tmpvar_13)
        )), (tmpvar_12 - pos_2)), dot ((tmpvar_15 * inversesqrt(
          dot (tmpvar_15, tmpvar_15)
        )), (tmpvar_14 - pos_2)))
      , 
        dot ((tmpvar_17 * inversesqrt(dot (tmpvar_17, tmpvar_17))), (tmpvar_16 - pos_2))
      )) - vParams.x) * tmpvar_4)
    ), 0.0), 1.0);
    alpha_1 = tmpvar_18;
    if ((1.0 >= vParams.x)) {
      alpha_1 = (1.0 - float((0.5 >= tmpvar_18)));
    };
    tmpvar_6 = bool(1);
  };
  tmpvar_5 = !(tmpvar_6);
  if (tmpvar_5) {
    tmpvar_6 = bool(1);
  };
  oFragColor = vec4(alpha_1);
}

#version 150
// cs_linear_gradient
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
flat out ivec2 v_gradient_address;
flat out vec2 v_gradient_repeat;
out vec2 v_pos;
flat out vec2 v_scale_dir;
flat out vec2 v_start_offset;
in vec4 aTaskRect;
in vec2 aStartPoint;
in vec2 aEndPoint;
in vec2 aScale;
in int aExtendMode;
in int aGradientStopsAddress;
void main ()
{
  vec4 tmpvar_1;
  tmpvar_1.zw = vec2(0.0, 1.0);
  tmpvar_1.xy = mix (aTaskRect.xy, aTaskRect.zw, aPosition);
  gl_Position = (uTransform * tmpvar_1);
  v_pos = (aPosition * aScale);
  vec2 tmpvar_2;
  tmpvar_2 = (aEndPoint - aStartPoint);
  v_scale_dir = (tmpvar_2 / dot (tmpvar_2, tmpvar_2));
  v_start_offset.x = dot (aStartPoint, v_scale_dir);
  v_scale_dir = (v_scale_dir * (aTaskRect.zw - aTaskRect.xy));
  v_gradient_repeat.x = float((aExtendMode == 1));
  v_gradient_address.x = aGradientStopsAddress;
}

#version 150
// cs_linear_gradient
// features: []

precision highp float;
out vec4 oFragColor;
uniform sampler2D sGpuCache;
flat in ivec2 v_gradient_address;
flat in vec2 v_gradient_repeat;
in vec2 v_pos;
flat in vec2 v_scale_dir;
flat in vec2 v_start_offset;
void main ()
{
  float tmpvar_1;
  tmpvar_1 = (dot (v_pos, v_scale_dir) - v_start_offset.x);
  float tmpvar_2;
  tmpvar_2 = min (max ((1.0 + 
    ((tmpvar_1 - (floor(tmpvar_1) * v_gradient_repeat.x)) * 128.0)
  ), 0.0), 129.0);
  float tmpvar_3;
  tmpvar_3 = floor(tmpvar_2);
  int tmpvar_4;
  tmpvar_4 = (v_gradient_address.x + (2 * int(tmpvar_3)));
  ivec2 tmpvar_5;
  tmpvar_5.x = int((uint(tmpvar_4) % 1024u));
  tmpvar_5.y = int((uint(tmpvar_4) / 1024u));
  oFragColor = (texelFetchOffset (sGpuCache, tmpvar_5, 0, ivec2(0, 0)) + (texelFetchOffset (sGpuCache, tmpvar_5, 0, ivec2(1, 0)) * (tmpvar_2 - tmpvar_3)));
}

#version 150
// cs_radial_gradient
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
flat out ivec2 v_gradient_address;
flat out vec2 v_gradient_repeat;
out vec2 v_pos;
flat out vec2 v_start_radius;
in vec4 aTaskRect;
in vec2 aCenter;
in vec2 aScale;
in float aStartRadius;
in float aEndRadius;
in float aXYRatio;
in int aExtendMode;
in int aGradientStopsAddress;
void main ()
{
  float tmpvar_1;
  tmpvar_1 = (aEndRadius - aStartRadius);
  float tmpvar_2;
  if ((tmpvar_1 != 0.0)) {
    tmpvar_2 = (1.0/(tmpvar_1));
  } else {
    tmpvar_2 = 0.0;
  };
  vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = mix (aTaskRect.xy, aTaskRect.zw, aPosition);
  gl_Position = (uTransform * tmpvar_3);
  v_start_radius.x = (aStartRadius * tmpvar_2);
  v_pos = (((
    ((aTaskRect.zw - aTaskRect.xy) * aPosition)
   * aScale) - aCenter) * tmpvar_2);
  v_pos.y = (v_pos.y * aXYRatio);
  v_gradient_repeat.x = float((aExtendMode == 1));
  v_gradient_address.x = aGradientStopsAddress;
}

#version 150
// cs_radial_gradient
// features: []

precision highp float;
out vec4 oFragColor;
uniform sampler2D sGpuCache;
flat in ivec2 v_gradient_address;
flat in vec2 v_gradient_repeat;
in vec2 v_pos;
flat in vec2 v_start_radius;
void main ()
{
  float tmpvar_1;
  tmpvar_1 = (sqrt(dot (v_pos, v_pos)) - v_start_radius.x);
  float tmpvar_2;
  tmpvar_2 = min (max ((1.0 + 
    ((tmpvar_1 - (floor(tmpvar_1) * v_gradient_repeat.x)) * 128.0)
  ), 0.0), 129.0);
  float tmpvar_3;
  tmpvar_3 = floor(tmpvar_2);
  int tmpvar_4;
  tmpvar_4 = (v_gradient_address.x + (2 * int(tmpvar_3)));
  ivec2 tmpvar_5;
  tmpvar_5.x = int((uint(tmpvar_4) % 1024u));
  tmpvar_5.y = int((uint(tmpvar_4) / 1024u));
  oFragColor = (texelFetchOffset (sGpuCache, tmpvar_5, 0, ivec2(0, 0)) + (texelFetchOffset (sGpuCache, tmpvar_5, 0, ivec2(1, 0)) * (tmpvar_2 - tmpvar_3)));
}

cs_scale_TEXTURE_2D#version 150
// cs_scale
// features: ["TEXTURE_2D"]

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
out vec2 vUv;
flat out vec4 vUvRect;
in vec4 aScaleTargetRect;
in vec4 aScaleSourceRect;
void main ()
{
  vec2 tmpvar_1;
  tmpvar_1 = (aScaleSourceRect.zw - aScaleSourceRect.xy);
  vec2 tmpvar_2;
  tmpvar_2 = vec2(textureSize (sColor0, 0));
  vec4 tmpvar_3;
  tmpvar_3.xy = (aScaleSourceRect.xy + vec2(0.5, 0.5));
  tmpvar_3.zw = ((aScaleSourceRect.xy + tmpvar_1) - vec2(0.5, 0.5));
  vUvRect = (tmpvar_3 / tmpvar_2.xyxy);
  vUv = ((aScaleSourceRect.xy + (tmpvar_1 * aPosition)) / tmpvar_2);
  vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = mix (aScaleTargetRect.xy, aScaleTargetRect.zw, aPosition);
  gl_Position = (uTransform * tmpvar_4);
}

#version 150
// cs_scale
// features: ["TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
in vec2 vUv;
flat in vec4 vUvRect;
void main ()
{
  oFragColor = texture (sColor0, min (max (vUv, vUvRect.xy), vUvRect.zw));
}

cs_scale_TEXTURE_RECT#version 150
// cs_scale
// features: ["TEXTURE_RECT"]

uniform mat4 uTransform;
in vec2 aPosition;
out vec2 vUv;
flat out vec4 vUvRect;
in vec4 aScaleTargetRect;
in vec4 aScaleSourceRect;
void main ()
{
  vec2 tmpvar_1;
  tmpvar_1 = (aScaleSourceRect.zw - aScaleSourceRect.xy);
  vec4 tmpvar_2;
  tmpvar_2.xy = (aScaleSourceRect.xy + vec2(0.5, 0.5));
  tmpvar_2.zw = ((aScaleSourceRect.xy + tmpvar_1) - vec2(0.5, 0.5));
  vUvRect = tmpvar_2;
  vUv = (aScaleSourceRect.xy + (tmpvar_1 * aPosition));
  vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = mix (aScaleTargetRect.xy, aScaleTargetRect.zw, aPosition);
  gl_Position = (uTransform * tmpvar_3);
}

#version 150
// cs_scale
// features: ["TEXTURE_RECT"]

precision highp float;
out vec4 oFragColor;
uniform sampler2DRect sColor0;
in vec2 vUv;
flat in vec4 vUvRect;
void main ()
{
  oFragColor = texture (sColor0, min (max (vUv, vUvRect.xy), vUvRect.zw));
}

#version 150
// cs_svg_filter
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
out vec2 vInput1Uv;
out vec2 vInput2Uv;
flat out vec4 vInput1UvRect;
flat out vec4 vInput2UvRect;
flat out ivec4 vData;
flat out vec4 vFilterData0;
flat out vec4 vFilterData1;
flat out ivec2 vFilterInputCountFilterKindVec;
flat out vec2 vFloat0;
flat out mat4 vColorMat;
flat out ivec4 vFuncs;
in int aFilterRenderTaskAddress;
in int aFilterInput1TaskAddress;
in int aFilterInput2TaskAddress;
in int aFilterKind;
in int aFilterInputCount;
in int aFilterGenericInt;
in ivec2 aFilterExtraDataAddress;
void main ()
{
  vec2 input_1_task_p0_1;
  vec2 input_1_task_p1_2;
  ivec2 tmpvar_3;
  tmpvar_3.x = int((2u * (
    uint(aFilterRenderTaskAddress)
   % 512u)));
  tmpvar_3.y = int((uint(aFilterRenderTaskAddress) / 512u));
  vec4 tmpvar_4;
  tmpvar_4 = texelFetchOffset (sRenderTasks, tmpvar_3, 0, ivec2(0, 0));
  vec4 tmpvar_5;
  tmpvar_5 = texelFetchOffset (sRenderTasks, tmpvar_3, 0, ivec2(1, 0));
  vec3 tmpvar_6;
  tmpvar_6 = tmpvar_5.xyz;
  vec2 tmpvar_7;
  tmpvar_7 = mix (tmpvar_4.xy, tmpvar_4.zw, aPosition);
  if ((0 < aFilterInputCount)) {
    vec2 tmpvar_8;
    tmpvar_8 = vec2(textureSize (sColor0, 0));
    ivec2 tmpvar_9;
    tmpvar_9.x = int((2u * (
      uint(aFilterInput1TaskAddress)
     % 512u)));
    tmpvar_9.y = int((uint(aFilterInput1TaskAddress) / 512u));
    vec4 tmpvar_10;
    tmpvar_10 = texelFetchOffset (sRenderTasks, tmpvar_9, 0, ivec2(0, 0));
    input_1_task_p0_1 = tmpvar_10.xy;
    input_1_task_p1_2 = tmpvar_10.zw;
    vec4 tmpvar_11;
    tmpvar_11.xy = (tmpvar_10.xy + vec2(0.5, 0.5));
    tmpvar_11.zw = (tmpvar_10.zw - vec2(0.5, 0.5));
    vInput1UvRect = (tmpvar_11 / tmpvar_8.xyxy);
    vInput1Uv = mix ((tmpvar_10.xy / tmpvar_8), (floor(tmpvar_10.zw) / tmpvar_8), aPosition);
  };
  if ((1 < aFilterInputCount)) {
    vec2 tmpvar_12;
    tmpvar_12 = vec2(textureSize (sColor1, 0));
    ivec2 tmpvar_13;
    tmpvar_13.x = int((2u * (
      uint(aFilterInput2TaskAddress)
     % 512u)));
    tmpvar_13.y = int((uint(aFilterInput2TaskAddress) / 512u));
    vec4 tmpvar_14;
    tmpvar_14 = texelFetchOffset (sRenderTasks, tmpvar_13, 0, ivec2(0, 0));
    vec4 tmpvar_15;
    tmpvar_15.xy = (tmpvar_14.xy + vec2(0.5, 0.5));
    tmpvar_15.zw = (tmpvar_14.zw - vec2(0.5, 0.5));
    vInput2UvRect = (tmpvar_15 / tmpvar_12.xyxy);
    vInput2Uv = mix ((tmpvar_14.xy / tmpvar_12), (floor(tmpvar_14.zw) / tmpvar_12), aPosition);
  };
  vFilterInputCountFilterKindVec.x = aFilterInputCount;
  vFilterInputCountFilterKindVec.y = aFilterKind;
  vFuncs.x = ((aFilterGenericInt >> 12) & 15);
  vFuncs.y = ((aFilterGenericInt >> 8) & 15);
  vFuncs.z = ((aFilterGenericInt >> 4) & 15);
  vFuncs.w = (aFilterGenericInt & 15);
  bool tmpvar_16;
  bool tmpvar_17;
  tmpvar_17 = bool(0);
  tmpvar_16 = (0 == aFilterKind);
  if (tmpvar_16) {
    ivec4 tmpvar_18;
    tmpvar_18.yzw = ivec3(0, 0, 0);
    tmpvar_18.x = aFilterGenericInt;
    vData = tmpvar_18;
    tmpvar_17 = bool(1);
  };
  tmpvar_16 = (tmpvar_16 || (1 == aFilterKind));
  tmpvar_16 = (tmpvar_16 && !(tmpvar_17));
  if (tmpvar_16) {
    vFilterData0 = texelFetch (sGpuCache, aFilterExtraDataAddress, 0);
    tmpvar_17 = bool(1);
  };
  tmpvar_16 = (tmpvar_16 || (4 == aFilterKind));
  tmpvar_16 = (tmpvar_16 && !(tmpvar_17));
  if (tmpvar_16) {
    vFloat0.x = tmpvar_6.x;
    tmpvar_17 = bool(1);
  };
  tmpvar_16 = (tmpvar_16 || (5 == aFilterKind));
  tmpvar_16 = (tmpvar_16 && !(tmpvar_17));
  if (tmpvar_16) {
    mat4 tmpvar_19;
    tmpvar_19[uint(0)] = texelFetchOffset (sGpuCache, aFilterExtraDataAddress, 0, ivec2(0, 0));
    tmpvar_19[1u] = texelFetchOffset (sGpuCache, aFilterExtraDataAddress, 0, ivec2(1, 0));
    tmpvar_19[2u] = texelFetchOffset (sGpuCache, aFilterExtraDataAddress, 0, ivec2(2, 0));
    tmpvar_19[3u] = texelFetchOffset (sGpuCache, aFilterExtraDataAddress, 0, ivec2(3, 0));
    vColorMat = tmpvar_19;
    vFilterData0 = texelFetch (sGpuCache, (aFilterExtraDataAddress + ivec2(4, 0)), 0);
    tmpvar_17 = bool(1);
  };
  tmpvar_16 = (tmpvar_16 || (6 == aFilterKind));
  tmpvar_16 = (tmpvar_16 && !(tmpvar_17));
  if (tmpvar_16) {
    vFilterData0 = texelFetch (sGpuCache, aFilterExtraDataAddress, 0);
    tmpvar_17 = bool(1);
  };
  tmpvar_16 = (tmpvar_16 || (7 == aFilterKind));
  tmpvar_16 = (tmpvar_16 && !(tmpvar_17));
  if (tmpvar_16) {
    vec2 tmpvar_20;
    tmpvar_20 = vec2(textureSize (sColor0, 0));
    vec4 tmpvar_21;
    tmpvar_21.zw = vec2(0.0, 0.0);
    tmpvar_21.xy = (-(tmpvar_5.xy) / tmpvar_20);
    vFilterData0 = tmpvar_21;
    vec4 tmpvar_22;
    tmpvar_22.xy = input_1_task_p0_1;
    tmpvar_22.zw = input_1_task_p1_2;
    vFilterData1 = (tmpvar_22 / tmpvar_20.xyxy);
    tmpvar_17 = bool(1);
  };
  tmpvar_16 = (tmpvar_16 || (8 == aFilterKind));
  tmpvar_16 = (tmpvar_16 && !(tmpvar_17));
  if (tmpvar_16) {
    ivec4 tmpvar_23;
    tmpvar_23.zw = ivec2(0, 0);
    tmpvar_23.xy = aFilterExtraDataAddress;
    vData = tmpvar_23;
    tmpvar_17 = bool(1);
  };
  tmpvar_16 = (tmpvar_16 || (10 == aFilterKind));
  tmpvar_16 = (tmpvar_16 && !(tmpvar_17));
  if (tmpvar_16) {
    ivec4 tmpvar_24;
    tmpvar_24.yzw = ivec3(0, 0, 0);
    tmpvar_24.x = aFilterGenericInt;
    vData = tmpvar_24;
    if ((aFilterGenericInt == 6)) {
      vFilterData0 = texelFetch (sGpuCache, aFilterExtraDataAddress, 0);
    };
    tmpvar_17 = bool(1);
  };
  tmpvar_16 = !(tmpvar_17);
  if (tmpvar_16) {
    tmpvar_17 = bool(1);
  };
  vec4 tmpvar_25;
  tmpvar_25.zw = vec2(0.0, 1.0);
  tmpvar_25.xy = tmpvar_7;
  gl_Position = (uTransform * tmpvar_25);
}

#version 150
// cs_svg_filter
// features: []

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sColor1;
uniform sampler2D sGpuCache;
in vec2 vInput1Uv;
in vec2 vInput2Uv;
flat in vec4 vInput1UvRect;
flat in vec4 vInput2UvRect;
flat in ivec4 vData;
flat in vec4 vFilterData0;
flat in vec4 vFilterData1;
flat in ivec2 vFilterInputCountFilterKindVec;
flat in vec2 vFloat0;
flat in mat4 vColorMat;
flat in ivec4 vFuncs;
void main ()
{
  bool needsPremul_1;
  vec4 result_2;
  vec4 Cb_3;
  vec4 Ca_4;
  Ca_4 = vec4(0.0, 0.0, 0.0, 0.0);
  Cb_3 = vec4(0.0, 0.0, 0.0, 0.0);
  if ((0 < vFilterInputCountFilterKindVec.x)) {
    vec4 tmpvar_5;
    tmpvar_5 = texture (sColor0, min (max (vInput1Uv, vInput1UvRect.xy), vInput1UvRect.zw));
    Ca_4 = tmpvar_5;
    if ((tmpvar_5.w != 0.0)) {
      Ca_4.xyz = (tmpvar_5.xyz / tmpvar_5.w);
    };
  };
  if ((1 < vFilterInputCountFilterKindVec.x)) {
    vec4 tmpvar_6;
    tmpvar_6 = texture (sColor1, min (max (vInput2Uv, vInput2UvRect.xy), vInput2UvRect.zw));
    Cb_3 = tmpvar_6;
    if ((tmpvar_6.w != 0.0)) {
      Cb_3.xyz = (tmpvar_6.xyz / tmpvar_6.w);
    };
  };
  result_2 = vec4(1.0, 0.0, 0.0, 1.0);
  needsPremul_1 = bool(1);
  bool tmpvar_7;
  bool tmpvar_8;
  tmpvar_8 = bool(0);
  tmpvar_7 = (0 == vFilterInputCountFilterKindVec.y);
  if (tmpvar_7) {
    vec4 result_9;
    result_9 = vec4(1.0, 0.0, 0.0, 1.0);
    bool tmpvar_10;
    bool tmpvar_11;
    tmpvar_11 = bool(0);
    tmpvar_10 = (0 == vData.x);
    if (tmpvar_10) {
      result_9.xyz = Ca_4.xyz;
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (1 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      result_9.xyz = (Cb_3.xyz * Ca_4.xyz);
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (2 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      result_9.xyz = ((Cb_3.xyz + Ca_4.xyz) - (Cb_3.xyz * Ca_4.xyz));
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (3 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      vec3 tmpvar_12;
      tmpvar_12 = ((2.0 * Cb_3.xyz) - 1.0);
      result_9.xyz = mix ((Ca_4.xyz * (2.0 * Cb_3.xyz)), ((Ca_4.xyz + tmpvar_12) - (Ca_4.xyz * tmpvar_12)), vec3(greaterThanEqual (Cb_3.xyz, vec3(0.5, 0.5, 0.5))));
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (4 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      result_9.xyz = min (Ca_4.xyz, Cb_3.xyz);
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (5 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      result_9.xyz = max (Ca_4.xyz, Cb_3.xyz);
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (6 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      float tmpvar_13;
      if ((Cb_3.x == 0.0)) {
        tmpvar_13 = 0.0;
      } else {
        if ((Ca_4.x == 1.0)) {
          tmpvar_13 = 1.0;
        } else {
          tmpvar_13 = min (1.0, (Cb_3.x / (1.0 - Ca_4.x)));
        };
      };
      result_9.x = tmpvar_13;
      float tmpvar_14;
      if ((Cb_3.y == 0.0)) {
        tmpvar_14 = 0.0;
      } else {
        if ((Ca_4.y == 1.0)) {
          tmpvar_14 = 1.0;
        } else {
          tmpvar_14 = min (1.0, (Cb_3.y / (1.0 - Ca_4.y)));
        };
      };
      result_9.y = tmpvar_14;
      float tmpvar_15;
      if ((Cb_3.z == 0.0)) {
        tmpvar_15 = 0.0;
      } else {
        if ((Ca_4.z == 1.0)) {
          tmpvar_15 = 1.0;
        } else {
          tmpvar_15 = min (1.0, (Cb_3.z / (1.0 - Ca_4.z)));
        };
      };
      result_9.z = tmpvar_15;
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (7 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      float tmpvar_16;
      if ((Cb_3.x == 1.0)) {
        tmpvar_16 = 1.0;
      } else {
        if ((Ca_4.x == 0.0)) {
          tmpvar_16 = 0.0;
        } else {
          tmpvar_16 = (1.0 - min (1.0, (
            (1.0 - Cb_3.x)
           / Ca_4.x)));
        };
      };
      result_9.x = tmpvar_16;
      float tmpvar_17;
      if ((Cb_3.y == 1.0)) {
        tmpvar_17 = 1.0;
      } else {
        if ((Ca_4.y == 0.0)) {
          tmpvar_17 = 0.0;
        } else {
          tmpvar_17 = (1.0 - min (1.0, (
            (1.0 - Cb_3.y)
           / Ca_4.y)));
        };
      };
      result_9.y = tmpvar_17;
      float tmpvar_18;
      if ((Cb_3.z == 1.0)) {
        tmpvar_18 = 1.0;
      } else {
        if ((Ca_4.z == 0.0)) {
          tmpvar_18 = 0.0;
        } else {
          tmpvar_18 = (1.0 - min (1.0, (
            (1.0 - Cb_3.z)
           / Ca_4.z)));
        };
      };
      result_9.z = tmpvar_18;
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (8 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      vec3 tmpvar_19;
      tmpvar_19 = ((2.0 * Ca_4.xyz) - 1.0);
      result_9.xyz = mix ((Cb_3.xyz * (2.0 * Ca_4.xyz)), ((Cb_3.xyz + tmpvar_19) - (Cb_3.xyz * tmpvar_19)), vec3(greaterThanEqual (Ca_4.xyz, vec3(0.5, 0.5, 0.5))));
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (9 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      float tmpvar_20;
      if ((0.5 >= Ca_4.x)) {
        tmpvar_20 = (Cb_3.x - ((
          (1.0 - (2.0 * Ca_4.x))
         * Cb_3.x) * (1.0 - Cb_3.x)));
      } else {
        float D_21;
        if ((0.25 >= Cb_3.x)) {
          D_21 = (((
            ((16.0 * Cb_3.x) - 12.0)
           * Cb_3.x) + 4.0) * Cb_3.x);
        } else {
          D_21 = sqrt(Cb_3.x);
        };
        tmpvar_20 = (Cb_3.x + ((
          (2.0 * Ca_4.x)
         - 1.0) * (D_21 - Cb_3.x)));
      };
      result_9.x = tmpvar_20;
      float tmpvar_22;
      if ((0.5 >= Ca_4.y)) {
        tmpvar_22 = (Cb_3.y - ((
          (1.0 - (2.0 * Ca_4.y))
         * Cb_3.y) * (1.0 - Cb_3.y)));
      } else {
        float D_23;
        if ((0.25 >= Cb_3.y)) {
          D_23 = (((
            ((16.0 * Cb_3.y) - 12.0)
           * Cb_3.y) + 4.0) * Cb_3.y);
        } else {
          D_23 = sqrt(Cb_3.y);
        };
        tmpvar_22 = (Cb_3.y + ((
          (2.0 * Ca_4.y)
         - 1.0) * (D_23 - Cb_3.y)));
      };
      result_9.y = tmpvar_22;
      float tmpvar_24;
      if ((0.5 >= Ca_4.z)) {
        tmpvar_24 = (Cb_3.z - ((
          (1.0 - (2.0 * Ca_4.z))
         * Cb_3.z) * (1.0 - Cb_3.z)));
      } else {
        float D_25;
        if ((0.25 >= Cb_3.z)) {
          D_25 = (((
            ((16.0 * Cb_3.z) - 12.0)
           * Cb_3.z) + 4.0) * Cb_3.z);
        } else {
          D_25 = sqrt(Cb_3.z);
        };
        tmpvar_24 = (Cb_3.z + ((
          (2.0 * Ca_4.z)
         - 1.0) * (D_25 - Cb_3.z)));
      };
      result_9.z = tmpvar_24;
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (10 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      result_9.xyz = abs((Cb_3.xyz - Ca_4.xyz));
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (11 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      result_9.xyz = ((Cb_3.xyz + Ca_4.xyz) - ((2.0 * Cb_3.xyz) * Ca_4.xyz));
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (12 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      vec3 tmpvar_26;
      tmpvar_26 = Ca_4.xyz;
      float tmpvar_27;
      tmpvar_27 = (max (Cb_3.x, max (Cb_3.y, Cb_3.z)) - min (Cb_3.x, min (Cb_3.y, Cb_3.z)));
      vec3 tmpvar_28;
      tmpvar_28 = tmpvar_26;
      if ((Ca_4.y >= Ca_4.x)) {
        if ((Ca_4.z >= Ca_4.y)) {
          float tmpvar_29;
          tmpvar_29 = tmpvar_26.x;
          float tmpvar_30;
          tmpvar_30 = tmpvar_26.y;
          float tmpvar_31;
          tmpvar_31 = tmpvar_26.z;
          float tmpvar_32;
          tmpvar_32 = tmpvar_29;
          float tmpvar_33;
          tmpvar_33 = tmpvar_30;
          float tmpvar_34;
          tmpvar_34 = tmpvar_31;
          if ((Ca_4.x < Ca_4.z)) {
            tmpvar_33 = (((Ca_4.y - Ca_4.x) * tmpvar_27) / (Ca_4.z - Ca_4.x));
            tmpvar_34 = tmpvar_27;
          } else {
            tmpvar_33 = 0.0;
            tmpvar_34 = 0.0;
          };
          tmpvar_32 = 0.0;
          tmpvar_29 = tmpvar_32;
          tmpvar_30 = tmpvar_33;
          tmpvar_31 = tmpvar_34;
          tmpvar_28.x = 0.0;
          tmpvar_28.y = tmpvar_33;
          tmpvar_28.z = tmpvar_34;
        } else {
          if ((Ca_4.z >= Ca_4.x)) {
            float tmpvar_35;
            tmpvar_35 = tmpvar_26.x;
            float tmpvar_36;
            tmpvar_36 = tmpvar_26.z;
            float tmpvar_37;
            tmpvar_37 = tmpvar_26.y;
            float tmpvar_38;
            tmpvar_38 = tmpvar_35;
            float tmpvar_39;
            tmpvar_39 = tmpvar_36;
            float tmpvar_40;
            tmpvar_40 = tmpvar_37;
            if ((Ca_4.x < Ca_4.y)) {
              tmpvar_39 = (((Ca_4.z - Ca_4.x) * tmpvar_27) / (Ca_4.y - Ca_4.x));
              tmpvar_40 = tmpvar_27;
            } else {
              tmpvar_39 = 0.0;
              tmpvar_40 = 0.0;
            };
            tmpvar_38 = 0.0;
            tmpvar_35 = tmpvar_38;
            tmpvar_36 = tmpvar_39;
            tmpvar_37 = tmpvar_40;
            tmpvar_28.x = 0.0;
            tmpvar_28.z = tmpvar_39;
            tmpvar_28.y = tmpvar_40;
          } else {
            float tmpvar_41;
            tmpvar_41 = tmpvar_26.z;
            float tmpvar_42;
            tmpvar_42 = tmpvar_26.x;
            float tmpvar_43;
            tmpvar_43 = tmpvar_26.y;
            float tmpvar_44;
            tmpvar_44 = tmpvar_41;
            float tmpvar_45;
            tmpvar_45 = tmpvar_42;
            float tmpvar_46;
            tmpvar_46 = tmpvar_43;
            if ((Ca_4.z < Ca_4.y)) {
              tmpvar_45 = (((Ca_4.x - Ca_4.z) * tmpvar_27) / (Ca_4.y - Ca_4.z));
              tmpvar_46 = tmpvar_27;
            } else {
              tmpvar_45 = 0.0;
              tmpvar_46 = 0.0;
            };
            tmpvar_44 = 0.0;
            tmpvar_41 = tmpvar_44;
            tmpvar_42 = tmpvar_45;
            tmpvar_43 = tmpvar_46;
            tmpvar_28.z = 0.0;
            tmpvar_28.x = tmpvar_45;
            tmpvar_28.y = tmpvar_46;
          };
        };
      } else {
        if ((Ca_4.z >= Ca_4.x)) {
          float tmpvar_47;
          tmpvar_47 = tmpvar_26.y;
          float tmpvar_48;
          tmpvar_48 = tmpvar_26.x;
          float tmpvar_49;
          tmpvar_49 = tmpvar_26.z;
          float tmpvar_50;
          tmpvar_50 = tmpvar_47;
          float tmpvar_51;
          tmpvar_51 = tmpvar_48;
          float tmpvar_52;
          tmpvar_52 = tmpvar_49;
          if ((Ca_4.y < Ca_4.z)) {
            tmpvar_51 = (((Ca_4.x - Ca_4.y) * tmpvar_27) / (Ca_4.z - Ca_4.y));
            tmpvar_52 = tmpvar_27;
          } else {
            tmpvar_51 = 0.0;
            tmpvar_52 = 0.0;
          };
          tmpvar_50 = 0.0;
          tmpvar_47 = tmpvar_50;
          tmpvar_48 = tmpvar_51;
          tmpvar_49 = tmpvar_52;
          tmpvar_28.y = 0.0;
          tmpvar_28.x = tmpvar_51;
          tmpvar_28.z = tmpvar_52;
        } else {
          if ((Ca_4.z >= Ca_4.y)) {
            float tmpvar_53;
            tmpvar_53 = tmpvar_26.y;
            float tmpvar_54;
            tmpvar_54 = tmpvar_26.z;
            float tmpvar_55;
            tmpvar_55 = tmpvar_26.x;
            float tmpvar_56;
            tmpvar_56 = tmpvar_53;
            float tmpvar_57;
            tmpvar_57 = tmpvar_54;
            float tmpvar_58;
            tmpvar_58 = tmpvar_55;
            if ((Ca_4.y < Ca_4.x)) {
              tmpvar_57 = (((Ca_4.z - Ca_4.y) * tmpvar_27) / (Ca_4.x - Ca_4.y));
              tmpvar_58 = tmpvar_27;
            } else {
              tmpvar_57 = 0.0;
              tmpvar_58 = 0.0;
            };
            tmpvar_56 = 0.0;
            tmpvar_53 = tmpvar_56;
            tmpvar_54 = tmpvar_57;
            tmpvar_55 = tmpvar_58;
            tmpvar_28.y = 0.0;
            tmpvar_28.z = tmpvar_57;
            tmpvar_28.x = tmpvar_58;
          } else {
            float tmpvar_59;
            tmpvar_59 = tmpvar_26.z;
            float tmpvar_60;
            tmpvar_60 = tmpvar_26.y;
            float tmpvar_61;
            tmpvar_61 = tmpvar_26.x;
            float tmpvar_62;
            tmpvar_62 = tmpvar_59;
            float tmpvar_63;
            tmpvar_63 = tmpvar_60;
            float tmpvar_64;
            tmpvar_64 = tmpvar_61;
            if ((Ca_4.z < Ca_4.x)) {
              tmpvar_63 = (((Ca_4.y - Ca_4.z) * tmpvar_27) / (Ca_4.x - Ca_4.z));
              tmpvar_64 = tmpvar_27;
            } else {
              tmpvar_63 = 0.0;
              tmpvar_64 = 0.0;
            };
            tmpvar_62 = 0.0;
            tmpvar_59 = tmpvar_62;
            tmpvar_60 = tmpvar_63;
            tmpvar_61 = tmpvar_64;
            tmpvar_28.z = 0.0;
            tmpvar_28.y = tmpvar_63;
            tmpvar_28.x = tmpvar_64;
          };
        };
      };
      vec3 tmpvar_65;
      tmpvar_65 = (tmpvar_28 + (dot (Cb_3.xyz, vec3(0.3, 0.59, 0.11)) - dot (tmpvar_28, vec3(0.3, 0.59, 0.11))));
      float tmpvar_66;
      tmpvar_66 = dot (tmpvar_65, vec3(0.3, 0.59, 0.11));
      float tmpvar_67;
      tmpvar_67 = min (tmpvar_65.x, min (tmpvar_65.y, tmpvar_65.z));
      float tmpvar_68;
      tmpvar_68 = max (tmpvar_65.x, max (tmpvar_65.y, tmpvar_65.z));
      if ((tmpvar_67 < 0.0)) {
        tmpvar_65 = (tmpvar_66 + ((
          (tmpvar_65 - tmpvar_66)
         * tmpvar_66) / (tmpvar_66 - tmpvar_67)));
      };
      if ((1.0 < tmpvar_68)) {
        tmpvar_65 = (tmpvar_66 + ((
          (tmpvar_65 - tmpvar_66)
         * 
          (1.0 - tmpvar_66)
        ) / (tmpvar_68 - tmpvar_66)));
      };
      result_9.xyz = tmpvar_65;
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (13 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      vec3 tmpvar_69;
      tmpvar_69 = Cb_3.xyz;
      float tmpvar_70;
      tmpvar_70 = (max (Ca_4.x, max (Ca_4.y, Ca_4.z)) - min (Ca_4.x, min (Ca_4.y, Ca_4.z)));
      vec3 tmpvar_71;
      tmpvar_71 = tmpvar_69;
      if ((Cb_3.y >= Cb_3.x)) {
        if ((Cb_3.z >= Cb_3.y)) {
          float tmpvar_72;
          tmpvar_72 = tmpvar_69.x;
          float tmpvar_73;
          tmpvar_73 = tmpvar_69.y;
          float tmpvar_74;
          tmpvar_74 = tmpvar_69.z;
          float tmpvar_75;
          tmpvar_75 = tmpvar_72;
          float tmpvar_76;
          tmpvar_76 = tmpvar_73;
          float tmpvar_77;
          tmpvar_77 = tmpvar_74;
          if ((Cb_3.x < Cb_3.z)) {
            tmpvar_76 = (((Cb_3.y - Cb_3.x) * tmpvar_70) / (Cb_3.z - Cb_3.x));
            tmpvar_77 = tmpvar_70;
          } else {
            tmpvar_76 = 0.0;
            tmpvar_77 = 0.0;
          };
          tmpvar_75 = 0.0;
          tmpvar_72 = tmpvar_75;
          tmpvar_73 = tmpvar_76;
          tmpvar_74 = tmpvar_77;
          tmpvar_71.x = 0.0;
          tmpvar_71.y = tmpvar_76;
          tmpvar_71.z = tmpvar_77;
        } else {
          if ((Cb_3.z >= Cb_3.x)) {
            float tmpvar_78;
            tmpvar_78 = tmpvar_69.x;
            float tmpvar_79;
            tmpvar_79 = tmpvar_69.z;
            float tmpvar_80;
            tmpvar_80 = tmpvar_69.y;
            float tmpvar_81;
            tmpvar_81 = tmpvar_78;
            float tmpvar_82;
            tmpvar_82 = tmpvar_79;
            float tmpvar_83;
            tmpvar_83 = tmpvar_80;
            if ((Cb_3.x < Cb_3.y)) {
              tmpvar_82 = (((Cb_3.z - Cb_3.x) * tmpvar_70) / (Cb_3.y - Cb_3.x));
              tmpvar_83 = tmpvar_70;
            } else {
              tmpvar_82 = 0.0;
              tmpvar_83 = 0.0;
            };
            tmpvar_81 = 0.0;
            tmpvar_78 = tmpvar_81;
            tmpvar_79 = tmpvar_82;
            tmpvar_80 = tmpvar_83;
            tmpvar_71.x = 0.0;
            tmpvar_71.z = tmpvar_82;
            tmpvar_71.y = tmpvar_83;
          } else {
            float tmpvar_84;
            tmpvar_84 = tmpvar_69.z;
            float tmpvar_85;
            tmpvar_85 = tmpvar_69.x;
            float tmpvar_86;
            tmpvar_86 = tmpvar_69.y;
            float tmpvar_87;
            tmpvar_87 = tmpvar_84;
            float tmpvar_88;
            tmpvar_88 = tmpvar_85;
            float tmpvar_89;
            tmpvar_89 = tmpvar_86;
            if ((Cb_3.z < Cb_3.y)) {
              tmpvar_88 = (((Cb_3.x - Cb_3.z) * tmpvar_70) / (Cb_3.y - Cb_3.z));
              tmpvar_89 = tmpvar_70;
            } else {
              tmpvar_88 = 0.0;
              tmpvar_89 = 0.0;
            };
            tmpvar_87 = 0.0;
            tmpvar_84 = tmpvar_87;
            tmpvar_85 = tmpvar_88;
            tmpvar_86 = tmpvar_89;
            tmpvar_71.z = 0.0;
            tmpvar_71.x = tmpvar_88;
            tmpvar_71.y = tmpvar_89;
          };
        };
      } else {
        if ((Cb_3.z >= Cb_3.x)) {
          float tmpvar_90;
          tmpvar_90 = tmpvar_69.y;
          float tmpvar_91;
          tmpvar_91 = tmpvar_69.x;
          float tmpvar_92;
          tmpvar_92 = tmpvar_69.z;
          float tmpvar_93;
          tmpvar_93 = tmpvar_90;
          float tmpvar_94;
          tmpvar_94 = tmpvar_91;
          float tmpvar_95;
          tmpvar_95 = tmpvar_92;
          if ((Cb_3.y < Cb_3.z)) {
            tmpvar_94 = (((Cb_3.x - Cb_3.y) * tmpvar_70) / (Cb_3.z - Cb_3.y));
            tmpvar_95 = tmpvar_70;
          } else {
            tmpvar_94 = 0.0;
            tmpvar_95 = 0.0;
          };
          tmpvar_93 = 0.0;
          tmpvar_90 = tmpvar_93;
          tmpvar_91 = tmpvar_94;
          tmpvar_92 = tmpvar_95;
          tmpvar_71.y = 0.0;
          tmpvar_71.x = tmpvar_94;
          tmpvar_71.z = tmpvar_95;
        } else {
          if ((Cb_3.z >= Cb_3.y)) {
            float tmpvar_96;
            tmpvar_96 = tmpvar_69.y;
            float tmpvar_97;
            tmpvar_97 = tmpvar_69.z;
            float tmpvar_98;
            tmpvar_98 = tmpvar_69.x;
            float tmpvar_99;
            tmpvar_99 = tmpvar_96;
            float tmpvar_100;
            tmpvar_100 = tmpvar_97;
            float tmpvar_101;
            tmpvar_101 = tmpvar_98;
            if ((Cb_3.y < Cb_3.x)) {
              tmpvar_100 = (((Cb_3.z - Cb_3.y) * tmpvar_70) / (Cb_3.x - Cb_3.y));
              tmpvar_101 = tmpvar_70;
            } else {
              tmpvar_100 = 0.0;
              tmpvar_101 = 0.0;
            };
            tmpvar_99 = 0.0;
            tmpvar_96 = tmpvar_99;
            tmpvar_97 = tmpvar_100;
            tmpvar_98 = tmpvar_101;
            tmpvar_71.y = 0.0;
            tmpvar_71.z = tmpvar_100;
            tmpvar_71.x = tmpvar_101;
          } else {
            float tmpvar_102;
            tmpvar_102 = tmpvar_69.z;
            float tmpvar_103;
            tmpvar_103 = tmpvar_69.y;
            float tmpvar_104;
            tmpvar_104 = tmpvar_69.x;
            float tmpvar_105;
            tmpvar_105 = tmpvar_102;
            float tmpvar_106;
            tmpvar_106 = tmpvar_103;
            float tmpvar_107;
            tmpvar_107 = tmpvar_104;
            if ((Cb_3.z < Cb_3.x)) {
              tmpvar_106 = (((Cb_3.y - Cb_3.z) * tmpvar_70) / (Cb_3.x - Cb_3.z));
              tmpvar_107 = tmpvar_70;
            } else {
              tmpvar_106 = 0.0;
              tmpvar_107 = 0.0;
            };
            tmpvar_105 = 0.0;
            tmpvar_102 = tmpvar_105;
            tmpvar_103 = tmpvar_106;
            tmpvar_104 = tmpvar_107;
            tmpvar_71.z = 0.0;
            tmpvar_71.y = tmpvar_106;
            tmpvar_71.x = tmpvar_107;
          };
        };
      };
      vec3 tmpvar_108;
      tmpvar_108 = (tmpvar_71 + (dot (Cb_3.xyz, vec3(0.3, 0.59, 0.11)) - dot (tmpvar_71, vec3(0.3, 0.59, 0.11))));
      float tmpvar_109;
      tmpvar_109 = dot (tmpvar_108, vec3(0.3, 0.59, 0.11));
      float tmpvar_110;
      tmpvar_110 = min (tmpvar_108.x, min (tmpvar_108.y, tmpvar_108.z));
      float tmpvar_111;
      tmpvar_111 = max (tmpvar_108.x, max (tmpvar_108.y, tmpvar_108.z));
      if ((tmpvar_110 < 0.0)) {
        tmpvar_108 = (tmpvar_109 + ((
          (tmpvar_108 - tmpvar_109)
         * tmpvar_109) / (tmpvar_109 - tmpvar_110)));
      };
      if ((1.0 < tmpvar_111)) {
        tmpvar_108 = (tmpvar_109 + ((
          (tmpvar_108 - tmpvar_109)
         * 
          (1.0 - tmpvar_109)
        ) / (tmpvar_111 - tmpvar_109)));
      };
      result_9.xyz = tmpvar_108;
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (14 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      vec3 tmpvar_112;
      tmpvar_112 = (Ca_4.xyz + (dot (Cb_3.xyz, vec3(0.3, 0.59, 0.11)) - dot (Ca_4.xyz, vec3(0.3, 0.59, 0.11))));
      float tmpvar_113;
      tmpvar_113 = dot (tmpvar_112, vec3(0.3, 0.59, 0.11));
      float tmpvar_114;
      tmpvar_114 = min (tmpvar_112.x, min (tmpvar_112.y, tmpvar_112.z));
      float tmpvar_115;
      tmpvar_115 = max (tmpvar_112.x, max (tmpvar_112.y, tmpvar_112.z));
      if ((tmpvar_114 < 0.0)) {
        tmpvar_112 = (tmpvar_113 + ((
          (tmpvar_112 - tmpvar_113)
         * tmpvar_113) / (tmpvar_113 - tmpvar_114)));
      };
      if ((1.0 < tmpvar_115)) {
        tmpvar_112 = (tmpvar_113 + ((
          (tmpvar_112 - tmpvar_113)
         * 
          (1.0 - tmpvar_113)
        ) / (tmpvar_115 - tmpvar_113)));
      };
      result_9.xyz = tmpvar_112;
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = (tmpvar_10 || (15 == vData.x));
    tmpvar_10 = (tmpvar_10 && !(tmpvar_11));
    if (tmpvar_10) {
      vec3 tmpvar_116;
      tmpvar_116 = (Cb_3.xyz + (dot (Ca_4.xyz, vec3(0.3, 0.59, 0.11)) - dot (Cb_3.xyz, vec3(0.3, 0.59, 0.11))));
      float tmpvar_117;
      tmpvar_117 = dot (tmpvar_116, vec3(0.3, 0.59, 0.11));
      float tmpvar_118;
      tmpvar_118 = min (tmpvar_116.x, min (tmpvar_116.y, tmpvar_116.z));
      float tmpvar_119;
      tmpvar_119 = max (tmpvar_116.x, max (tmpvar_116.y, tmpvar_116.z));
      if ((tmpvar_118 < 0.0)) {
        tmpvar_116 = (tmpvar_117 + ((
          (tmpvar_116 - tmpvar_117)
         * tmpvar_117) / (tmpvar_117 - tmpvar_118)));
      };
      if ((1.0 < tmpvar_119)) {
        tmpvar_116 = (tmpvar_117 + ((
          (tmpvar_116 - tmpvar_117)
         * 
          (1.0 - tmpvar_117)
        ) / (tmpvar_119 - tmpvar_117)));
      };
      result_9.xyz = tmpvar_116;
      tmpvar_11 = bool(1);
    };
    tmpvar_10 = !(tmpvar_11);
    if (tmpvar_10) {
      tmpvar_11 = bool(1);
    };
    vec4 tmpvar_120;
    tmpvar_120.xyz = (Cb_3.xyz * Cb_3.w);
    tmpvar_120.w = Cb_3.w;
    vec4 tmpvar_121;
    tmpvar_121.w = 1.0;
    tmpvar_121.xyz = (((1.0 - Cb_3.w) * Ca_4.xyz) + (Cb_3.w * result_9.xyz));
    vec4 tmpvar_122;
    tmpvar_122 = mix (tmpvar_120, tmpvar_121, Ca_4.w);
    result_9 = tmpvar_122;
    result_2 = tmpvar_122;
    needsPremul_1 = bool(0);
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (1 == vFilterInputCountFilterKindVec.y));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    result_2 = vFilterData0;
    needsPremul_1 = bool(0);
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (2 == vFilterInputCountFilterKindVec.y));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    result_2.xyz = mix(((vec3(1.055, 1.055, 1.055) * 
      pow (Ca_4.xyz, vec3(0.4166667, 0.4166667, 0.4166667))
    ) - vec3(0.055, 0.055, 0.055)), (Ca_4.xyz * 12.92), bvec3(greaterThanEqual (vec3(0.0031308, 0.0031308, 0.0031308), Ca_4.xyz)));
    result_2.w = Ca_4.w;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (3 == vFilterInputCountFilterKindVec.y));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    result_2.xyz = mix(pow ((
      (Ca_4.xyz / 1.055)
     + vec3(0.0521327, 0.0521327, 0.0521327)), vec3(2.4, 2.4, 2.4)), (Ca_4.xyz / 12.92), bvec3(greaterThanEqual (vec3(0.04045, 0.04045, 0.04045), Ca_4.xyz)));
    result_2.w = Ca_4.w;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (4 == vFilterInputCountFilterKindVec.y));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    result_2.xyz = Ca_4.xyz;
    result_2.w = (Ca_4.w * vFloat0.x);
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (5 == vFilterInputCountFilterKindVec.y));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    result_2 = ((vColorMat * Ca_4) + vFilterData0);
    result_2 = min (max (result_2, 0.0), 1.0);
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (6 == vFilterInputCountFilterKindVec.y));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    vec4 tmpvar_123;
    tmpvar_123.xyz = vFilterData0.xyz;
    tmpvar_123.w = (Cb_3.w * vFilterData0.w);
    vec4 tmpvar_124;
    tmpvar_124.xyz = (vFilterData0.xyz * tmpvar_123.w);
    tmpvar_124.w = tmpvar_123.w;
    vec4 tmpvar_125;
    tmpvar_125.w = 1.0;
    tmpvar_125.xyz = (((1.0 - tmpvar_123.w) * Ca_4.xyz) + (tmpvar_123.w * Ca_4.xyz));
    result_2 = mix (tmpvar_124, tmpvar_125, Ca_4.w);
    needsPremul_1 = bool(0);
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (7 == vFilterInputCountFilterKindVec.y));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    vec2 tmpvar_126;
    tmpvar_126 = (vInput1Uv + vFilterData0.xy);
    vec2 tmpvar_127;
    tmpvar_127.x = float((tmpvar_126.x >= vFilterData1.z));
    tmpvar_127.y = float((tmpvar_126.y >= vFilterData1.w));
    vec2 tmpvar_128;
    tmpvar_128 = (vec2(greaterThanEqual (tmpvar_126, vFilterData1.xy)) - tmpvar_127);
    result_2 = (texture (sColor0, min (max (tmpvar_126, vInput1UvRect.xy), vInput1UvRect.zw)) * (tmpvar_128.x * tmpvar_128.y));
    needsPremul_1 = bool(0);
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (8 == vFilterInputCountFilterKindVec.y));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    vec4 tmpvar_129;
    tmpvar_129 = Ca_4;
    int k_130;
    int offset_131;
    offset_131 = 0;
    bool tmpvar_132;
    bool tmpvar_133;
    tmpvar_133 = bool(0);
    tmpvar_132 = (0 == vFuncs.x);
    if (tmpvar_132) {
      tmpvar_133 = bool(1);
    };
    tmpvar_132 = (tmpvar_132 || (1 == vFuncs.x));
    tmpvar_132 = (tmpvar_132 || (2 == vFuncs.x));
    tmpvar_132 = (tmpvar_132 && !(tmpvar_133));
    if (tmpvar_132) {
      k_130 = int(floor((
        (Ca_4[0] * 255.0)
       + 0.5)));
      ivec2 tmpvar_134;
      tmpvar_134.y = 0;
      tmpvar_134.x = (k_130 / 4);
      vec4 tmpvar_135;
      tmpvar_135 = texelFetch (sGpuCache, (vData.xy + tmpvar_134), 0);
      tmpvar_129[0] = min (max (tmpvar_135[(k_130 % 4)], 0.0), 1.0);
      offset_131 = 64;
      tmpvar_133 = bool(1);
    };
    tmpvar_132 = (tmpvar_132 || (3 == vFuncs.x));
    tmpvar_132 = (tmpvar_132 && !(tmpvar_133));
    if (tmpvar_132) {
      ivec2 tmpvar_136;
      tmpvar_136.y = 0;
      tmpvar_136.x = offset_131;
      vec4 tmpvar_137;
      tmpvar_137 = texelFetch (sGpuCache, (vData.xy + tmpvar_136), 0);
      tmpvar_129[0] = min (max ((
        (tmpvar_137[0] * tmpvar_129[0])
       + tmpvar_137[1]), 0.0), 1.0);
      offset_131++;
      tmpvar_133 = bool(1);
    };
    tmpvar_132 = (tmpvar_132 || (4 == vFuncs.x));
    tmpvar_132 = (tmpvar_132 && !(tmpvar_133));
    if (tmpvar_132) {
      ivec2 tmpvar_138;
      tmpvar_138.y = 0;
      tmpvar_138.x = offset_131;
      vec4 tmpvar_139;
      tmpvar_139 = texelFetch (sGpuCache, (vData.xy + tmpvar_138), 0);
      tmpvar_129[0] = min (max ((
        (tmpvar_139[0] * pow (tmpvar_129[0], tmpvar_139[1]))
       + tmpvar_139[2]), 0.0), 1.0);
      offset_131++;
      tmpvar_133 = bool(1);
    };
    tmpvar_132 = !(tmpvar_133);
    if (tmpvar_132) {
      tmpvar_133 = bool(1);
    };
    bool tmpvar_140;
    bool tmpvar_141;
    tmpvar_141 = bool(0);
    tmpvar_140 = (0 == vFuncs.y);
    if (tmpvar_140) {
      tmpvar_141 = bool(1);
    };
    tmpvar_140 = (tmpvar_140 || (1 == vFuncs.y));
    tmpvar_140 = (tmpvar_140 || (2 == vFuncs.y));
    tmpvar_140 = (tmpvar_140 && !(tmpvar_141));
    if (tmpvar_140) {
      k_130 = int(floor((
        (tmpvar_129[1] * 255.0)
       + 0.5)));
      ivec2 tmpvar_142;
      tmpvar_142.y = 0;
      tmpvar_142.x = (offset_131 + (k_130 / 4));
      vec4 tmpvar_143;
      tmpvar_143 = texelFetch (sGpuCache, (vData.xy + tmpvar_142), 0);
      tmpvar_129[1] = min (max (tmpvar_143[(k_130 % 4)], 0.0), 1.0);
      offset_131 += 64;
      tmpvar_141 = bool(1);
    };
    tmpvar_140 = (tmpvar_140 || (3 == vFuncs.y));
    tmpvar_140 = (tmpvar_140 && !(tmpvar_141));
    if (tmpvar_140) {
      ivec2 tmpvar_144;
      tmpvar_144.y = 0;
      tmpvar_144.x = offset_131;
      vec4 tmpvar_145;
      tmpvar_145 = texelFetch (sGpuCache, (vData.xy + tmpvar_144), 0);
      tmpvar_129[1] = min (max ((
        (tmpvar_145[0] * tmpvar_129[1])
       + tmpvar_145[1]), 0.0), 1.0);
      offset_131++;
      tmpvar_141 = bool(1);
    };
    tmpvar_140 = (tmpvar_140 || (4 == vFuncs.y));
    tmpvar_140 = (tmpvar_140 && !(tmpvar_141));
    if (tmpvar_140) {
      ivec2 tmpvar_146;
      tmpvar_146.y = 0;
      tmpvar_146.x = offset_131;
      vec4 tmpvar_147;
      tmpvar_147 = texelFetch (sGpuCache, (vData.xy + tmpvar_146), 0);
      tmpvar_129[1] = min (max ((
        (tmpvar_147[0] * pow (tmpvar_129[1], tmpvar_147[1]))
       + tmpvar_147[2]), 0.0), 1.0);
      offset_131++;
      tmpvar_141 = bool(1);
    };
    tmpvar_140 = !(tmpvar_141);
    if (tmpvar_140) {
      tmpvar_141 = bool(1);
    };
    bool tmpvar_148;
    bool tmpvar_149;
    tmpvar_149 = bool(0);
    tmpvar_148 = (0 == vFuncs.z);
    if (tmpvar_148) {
      tmpvar_149 = bool(1);
    };
    tmpvar_148 = (tmpvar_148 || (1 == vFuncs.z));
    tmpvar_148 = (tmpvar_148 || (2 == vFuncs.z));
    tmpvar_148 = (tmpvar_148 && !(tmpvar_149));
    if (tmpvar_148) {
      k_130 = int(floor((
        (tmpvar_129[2] * 255.0)
       + 0.5)));
      ivec2 tmpvar_150;
      tmpvar_150.y = 0;
      tmpvar_150.x = (offset_131 + (k_130 / 4));
      vec4 tmpvar_151;
      tmpvar_151 = texelFetch (sGpuCache, (vData.xy + tmpvar_150), 0);
      tmpvar_129[2] = min (max (tmpvar_151[(k_130 % 4)], 0.0), 1.0);
      offset_131 += 64;
      tmpvar_149 = bool(1);
    };
    tmpvar_148 = (tmpvar_148 || (3 == vFuncs.z));
    tmpvar_148 = (tmpvar_148 && !(tmpvar_149));
    if (tmpvar_148) {
      ivec2 tmpvar_152;
      tmpvar_152.y = 0;
      tmpvar_152.x = offset_131;
      vec4 tmpvar_153;
      tmpvar_153 = texelFetch (sGpuCache, (vData.xy + tmpvar_152), 0);
      tmpvar_129[2] = min (max ((
        (tmpvar_153[0] * tmpvar_129[2])
       + tmpvar_153[1]), 0.0), 1.0);
      offset_131++;
      tmpvar_149 = bool(1);
    };
    tmpvar_148 = (tmpvar_148 || (4 == vFuncs.z));
    tmpvar_148 = (tmpvar_148 && !(tmpvar_149));
    if (tmpvar_148) {
      ivec2 tmpvar_154;
      tmpvar_154.y = 0;
      tmpvar_154.x = offset_131;
      vec4 tmpvar_155;
      tmpvar_155 = texelFetch (sGpuCache, (vData.xy + tmpvar_154), 0);
      tmpvar_129[2] = min (max ((
        (tmpvar_155[0] * pow (tmpvar_129[2], tmpvar_155[1]))
       + tmpvar_155[2]), 0.0), 1.0);
      offset_131++;
      tmpvar_149 = bool(1);
    };
    tmpvar_148 = !(tmpvar_149);
    if (tmpvar_148) {
      tmpvar_149 = bool(1);
    };
    bool tmpvar_156;
    bool tmpvar_157;
    tmpvar_157 = bool(0);
    tmpvar_156 = (0 == vFuncs.w);
    if (tmpvar_156) {
      tmpvar_157 = bool(1);
    };
    tmpvar_156 = (tmpvar_156 || (1 == vFuncs.w));
    tmpvar_156 = (tmpvar_156 || (2 == vFuncs.w));
    tmpvar_156 = (tmpvar_156 && !(tmpvar_157));
    if (tmpvar_156) {
      k_130 = int(floor((
        (tmpvar_129[3] * 255.0)
       + 0.5)));
      ivec2 tmpvar_158;
      tmpvar_158.y = 0;
      tmpvar_158.x = (offset_131 + (k_130 / 4));
      vec4 tmpvar_159;
      tmpvar_159 = texelFetch (sGpuCache, (vData.xy + tmpvar_158), 0);
      tmpvar_129[3] = min (max (tmpvar_159[(k_130 % 4)], 0.0), 1.0);
      offset_131 += 64;
      tmpvar_157 = bool(1);
    };
    tmpvar_156 = (tmpvar_156 || (3 == vFuncs.w));
    tmpvar_156 = (tmpvar_156 && !(tmpvar_157));
    if (tmpvar_156) {
      ivec2 tmpvar_160;
      tmpvar_160.y = 0;
      tmpvar_160.x = offset_131;
      vec4 tmpvar_161;
      tmpvar_161 = texelFetch (sGpuCache, (vData.xy + tmpvar_160), 0);
      tmpvar_129[3] = min (max ((
        (tmpvar_161[0] * tmpvar_129[3])
       + tmpvar_161[1]), 0.0), 1.0);
      offset_131++;
      tmpvar_157 = bool(1);
    };
    tmpvar_156 = (tmpvar_156 || (4 == vFuncs.w));
    tmpvar_156 = (tmpvar_156 && !(tmpvar_157));
    if (tmpvar_156) {
      ivec2 tmpvar_162;
      tmpvar_162.y = 0;
      tmpvar_162.x = offset_131;
      vec4 tmpvar_163;
      tmpvar_163 = texelFetch (sGpuCache, (vData.xy + tmpvar_162), 0);
      tmpvar_129[3] = min (max ((
        (tmpvar_163[0] * pow (tmpvar_129[3], tmpvar_163[1]))
       + tmpvar_163[2]), 0.0), 1.0);
      offset_131++;
      tmpvar_157 = bool(1);
    };
    tmpvar_156 = !(tmpvar_157);
    if (tmpvar_156) {
      tmpvar_157 = bool(1);
    };
    result_2 = tmpvar_129;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (9 == vFilterInputCountFilterKindVec.y));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    result_2 = Ca_4;
    tmpvar_8 = bool(1);
  };
  tmpvar_7 = (tmpvar_7 || (10 == vFilterInputCountFilterKindVec.y));
  tmpvar_7 = (tmpvar_7 && !(tmpvar_8));
  if (tmpvar_7) {
    vec4 Cr_164;
    Cr_164 = vec4(0.0, 1.0, 0.0, 1.0);
    bool tmpvar_165;
    bool tmpvar_166;
    tmpvar_166 = bool(0);
    tmpvar_165 = (0 == vData.x);
    if (tmpvar_165) {
      Cr_164.xyz = ((Ca_4.w * Ca_4.xyz) + ((Cb_3.w * Cb_3.xyz) * (1.0 - Ca_4.w)));
      Cr_164.w = (Ca_4.w + (Cb_3.w * (1.0 - Ca_4.w)));
      tmpvar_166 = bool(1);
    };
    tmpvar_165 = (tmpvar_165 || (1 == vData.x));
    tmpvar_165 = (tmpvar_165 && !(tmpvar_166));
    if (tmpvar_165) {
      Cr_164.xyz = ((Ca_4.w * Ca_4.xyz) * Cb_3.w);
      Cr_164.w = (Ca_4.w * Cb_3.w);
      tmpvar_166 = bool(1);
    };
    tmpvar_165 = (tmpvar_165 || (2 == vData.x));
    tmpvar_165 = (tmpvar_165 && !(tmpvar_166));
    if (tmpvar_165) {
      Cr_164.xyz = ((Ca_4.w * Ca_4.xyz) * (1.0 - Cb_3.w));
      Cr_164.w = (Ca_4.w * (1.0 - Cb_3.w));
      tmpvar_166 = bool(1);
    };
    tmpvar_165 = (tmpvar_165 || (3 == vData.x));
    tmpvar_165 = (tmpvar_165 && !(tmpvar_166));
    if (tmpvar_165) {
      Cr_164.xyz = (((Ca_4.w * Ca_4.xyz) * Cb_3.w) + ((Cb_3.w * Cb_3.xyz) * (1.0 - Ca_4.w)));
      Cr_164.w = ((Ca_4.w * Cb_3.w) + (Cb_3.w * (1.0 - Ca_4.w)));
      tmpvar_166 = bool(1);
    };
    tmpvar_165 = (tmpvar_165 || (4 == vData.x));
    tmpvar_165 = (tmpvar_165 && !(tmpvar_166));
    if (tmpvar_165) {
      Cr_164.xyz = (((Ca_4.w * Ca_4.xyz) * (1.0 - Cb_3.w)) + ((Cb_3.w * Cb_3.xyz) * (1.0 - Ca_4.w)));
      Cr_164.w = ((Ca_4.w * (1.0 - Cb_3.w)) + (Cb_3.w * (1.0 - Ca_4.w)));
      tmpvar_166 = bool(1);
    };
    tmpvar_165 = (tmpvar_165 || (5 == vData.x));
    tmpvar_165 = (tmpvar_165 && !(tmpvar_166));
    if (tmpvar_165) {
      Cr_164.xyz = ((Ca_4.w * Ca_4.xyz) + (Cb_3.w * Cb_3.xyz));
      Cr_164.w = (Ca_4.w + Cb_3.w);
      Cr_164 = min (max (Cr_164, 0.0), 1.0);
      tmpvar_166 = bool(1);
    };
    tmpvar_165 = (tmpvar_165 || (6 == vData.x));
    tmpvar_165 = (tmpvar_165 && !(tmpvar_166));
    if (tmpvar_165) {
      Cr_164 = (((
        ((vFilterData0.xxxx * Ca_4) * Cb_3)
       + 
        (vFilterData0.yyyy * Ca_4)
      ) + (vFilterData0.zzzz * Cb_3)) + vFilterData0.wwww);
      Cr_164 = min (max (Cr_164, 0.0), 1.0);
      tmpvar_166 = bool(1);
    };
    tmpvar_165 = !(tmpvar_166);
    if (tmpvar_165) {
      tmpvar_166 = bool(1);
    };
    result_2 = Cr_164;
    needsPremul_1 = bool(0);
  };
  tmpvar_7 = !(tmpvar_8);
  if (tmpvar_7) {
    tmpvar_8 = bool(1);
  };
  if (needsPremul_1) {
    result_2.xyz = (result_2.xyz * result_2.w);
  };
  oFragColor = result_2;
}

#version 150
// debug_color
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
out vec4 vColor;
in vec4 aColor;
void main ()
{
  vec4 pos_1;
  vec4 tmpvar_2;
  tmpvar_2.xyz = (aColor.xyz * aColor.w);
  tmpvar_2.w = aColor.w;
  vColor = tmpvar_2;
  vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = aPosition;
  pos_1.zw = tmpvar_3.zw;
  pos_1.xy = floor((aPosition + 0.5));
  gl_Position = (uTransform * pos_1);
}

#version 150
// debug_color
// features: []

precision highp float;
out vec4 oFragColor;
in vec4 vColor;
void main ()
{
  oFragColor = vColor;
}

#version 150
// debug_font
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
out vec2 vColorTexCoord;
out vec4 vColor;
in vec4 aColor;
in vec2 aColorTexCoord;
void main ()
{
  vec4 pos_1;
  vColor = aColor;
  vColorTexCoord = aColorTexCoord;
  vec4 tmpvar_2;
  tmpvar_2.zw = vec2(0.0, 1.0);
  tmpvar_2.xy = aPosition;
  pos_1.zw = tmpvar_2.zw;
  pos_1.xy = floor((aPosition + 0.5));
  gl_Position = (uTransform * pos_1);
}

#version 150
// debug_font
// features: []

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
in vec2 vColorTexCoord;
in vec4 vColor;
void main ()
{
  oFragColor = (vColor * texture (sColor0, vColorTexCoord).x);
}

#version 150
// ps_clear
// features: []

uniform mat4 uTransform;
in vec2 aPosition;
out vec4 vColor;
in vec4 aRect;
in vec4 aColor;
void main ()
{
  vec4 tmpvar_1;
  tmpvar_1.zw = vec2(0.0, 1.0);
  tmpvar_1.xy = mix (aRect.xy, aRect.zw, aPosition);
  gl_Position = (uTransform * tmpvar_1);
  gl_Position.z = gl_Position.w;
  vColor = aColor;
}

#version 150
// ps_clear
// features: []

precision highp float;
out vec4 oFragColor;
in vec4 vColor;
void main ()
{
  oFragColor = vColor;
}

#version 150
// ps_copy
// features: []

in vec2 aPosition;
in vec4 a_src_rect;
in vec4 a_dst_rect;
in vec2 a_dst_texture_size;
out vec2 v_uv;
void main ()
{
  v_uv = mix (a_src_rect.xy, a_src_rect.zw, aPosition);
  vec4 tmpvar_1;
  tmpvar_1.zw = vec2(0.0, 1.0);
  tmpvar_1.xy = ((mix (a_dst_rect.xy, a_dst_rect.zw, aPosition) / (a_dst_texture_size * 0.5)) - vec2(1.0, 1.0));
  gl_Position = tmpvar_1;
}

#version 150
// ps_copy
// features: []

precision highp float;
out vec4 oFragColor;
in vec2 v_uv;
uniform sampler2D sColor0;
void main ()
{
  oFragColor = texelFetch (sColor0, ivec2(v_uv), 0);
}

#version 150
// ps_split_composite
// features: []

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
out vec2 vUv;
flat out vec2 vPerspective;
flat out vec4 vUvSampleBounds;
void main ()
{
  float ci_z_1;
  ci_z_1 = float(aData.z);
  ivec2 tmpvar_2;
  tmpvar_2.x = int((uint(aData.y) % 1024u));
  tmpvar_2.y = int((uint(aData.y) / 1024u));
  vec4 tmpvar_3;
  tmpvar_3 = texelFetchOffset (sGpuCache, tmpvar_2, 0, ivec2(0, 0));
  vec4 tmpvar_4;
  tmpvar_4 = texelFetchOffset (sGpuCache, tmpvar_2, 0, ivec2(1, 0));
  ivec2 tmpvar_5;
  tmpvar_5.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_5.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_6;
  tmpvar_6 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_5, 0, ivec2(0, 0));
  ivec2 tmpvar_7;
  tmpvar_7.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_7.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_8;
  tmpvar_8 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_7, 0, ivec2(1, 0));
  ivec2 tmpvar_9;
  tmpvar_9.x = int((2u * (
    uint(aData.w)
   % 512u)));
  tmpvar_9.y = int((uint(aData.w) / 512u));
  vec4 tmpvar_10;
  tmpvar_10 = texelFetchOffset (sRenderTasks, tmpvar_9, 0, ivec2(0, 0));
  vec4 tmpvar_11;
  tmpvar_11 = texelFetchOffset (sRenderTasks, tmpvar_9, 0, ivec2(1, 0));
  mat4 transform_m_12;
  int tmpvar_13;
  tmpvar_13 = (texelFetchOffset (sPrimitiveHeadersI, tmpvar_7, 0, ivec2(0, 0)).z & 16777215);
  ivec2 tmpvar_14;
  tmpvar_14.x = int((8u * (
    uint(tmpvar_13)
   % 128u)));
  tmpvar_14.y = int((uint(tmpvar_13) / 128u));
  transform_m_12[0] = texelFetchOffset (sTransformPalette, tmpvar_14, 0, ivec2(0, 0));
  transform_m_12[1] = texelFetchOffset (sTransformPalette, tmpvar_14, 0, ivec2(1, 0));
  transform_m_12[2] = texelFetchOffset (sTransformPalette, tmpvar_14, 0, ivec2(2, 0));
  transform_m_12[3] = texelFetchOffset (sTransformPalette, tmpvar_14, 0, ivec2(3, 0));
  ivec2 tmpvar_15;
  tmpvar_15.x = int((uint(tmpvar_8.x) % 1024u));
  tmpvar_15.y = int((uint(tmpvar_8.x) / 1024u));
  vec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sGpuCache, tmpvar_15, 0, ivec2(0, 0));
  RectWithEndpoint area_task_rect_17;
  float area_device_pixel_scale_18;
  vec2 area_screen_origin_19;
  if ((tmpvar_8.w >= 32767)) {
    area_task_rect_17 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_18 = 0.0;
    area_screen_origin_19 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_20;
    tmpvar_20.x = int((2u * (
      uint(tmpvar_8.w)
     % 512u)));
    tmpvar_20.y = int((uint(tmpvar_8.w) / 512u));
    vec4 tmpvar_21;
    tmpvar_21 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(0, 0));
    vec4 tmpvar_22;
    tmpvar_22 = texelFetchOffset (sRenderTasks, tmpvar_20, 0, ivec2(1, 0));
    area_task_rect_17.p0 = tmpvar_21.xy;
    area_task_rect_17.p1 = tmpvar_21.zw;
    area_device_pixel_scale_18 = tmpvar_22.x;
    area_screen_origin_19 = tmpvar_22.yz;
  };
  vec2 tmpvar_23;
  tmpvar_23 = mix (mix (tmpvar_3.xy, tmpvar_3.zw, aPosition.x), mix (tmpvar_4.zw, tmpvar_4.xy, aPosition.x), aPosition.y);
  vec4 tmpvar_24;
  tmpvar_24.zw = vec2(0.0, 1.0);
  tmpvar_24.xy = tmpvar_23;
  vec4 tmpvar_25;
  tmpvar_25 = (transform_m_12 * tmpvar_24);
  vec4 tmpvar_26;
  tmpvar_26.xy = (((tmpvar_10.xy - tmpvar_11.yz) * tmpvar_25.w) + (tmpvar_25.xy * tmpvar_11.x));
  tmpvar_26.z = (tmpvar_25.w * ci_z_1);
  tmpvar_26.w = tmpvar_25.w;
  vec4 tmpvar_27;
  tmpvar_27.xy = area_task_rect_17.p0;
  tmpvar_27.zw = area_task_rect_17.p1;
  vClipMaskUvBounds = tmpvar_27;
  vClipMaskUv = ((tmpvar_25.xy * area_device_pixel_scale_18) + (tmpvar_25.w * (area_task_rect_17.p0 - area_screen_origin_19)));
  gl_Position = (uTransform * tmpvar_26);
  vec2 tmpvar_28;
  tmpvar_28 = vec2(textureSize (sColor0, 0));
  vec4 tmpvar_29;
  tmpvar_29.xy = (min (tmpvar_16.xy, tmpvar_16.zw) + vec2(0.5, 0.5));
  tmpvar_29.zw = (max (tmpvar_16.xy, tmpvar_16.zw) - vec2(0.5, 0.5));
  vUvSampleBounds = (tmpvar_29 / tmpvar_28.xyxy);
  vec2 tmpvar_30;
  tmpvar_30 = ((tmpvar_23 - tmpvar_6.xy) / (tmpvar_6.zw - tmpvar_6.xy));
  int tmpvar_31;
  tmpvar_31 = (tmpvar_8.x + 2);
  ivec2 tmpvar_32;
  tmpvar_32.x = int((uint(tmpvar_31) % 1024u));
  tmpvar_32.y = int((uint(tmpvar_31) / 1024u));
  vec4 tmpvar_33;
  tmpvar_33 = mix (mix (texelFetchOffset (sGpuCache, tmpvar_32, 0, ivec2(0, 0)), texelFetchOffset (sGpuCache, tmpvar_32, 0, ivec2(1, 0)), tmpvar_30.x), mix (texelFetchOffset (sGpuCache, tmpvar_32, 0, ivec2(2, 0)), texelFetchOffset (sGpuCache, tmpvar_32, 0, ivec2(3, 0)), tmpvar_30.x), tmpvar_30.y);
  float tmpvar_34;
  tmpvar_34 = float(tmpvar_8.y);
  vUv = ((mix (tmpvar_16.xy, tmpvar_16.zw, 
    (tmpvar_33.xy / tmpvar_33.w)
  ) / tmpvar_28) * mix (gl_Position.w, 1.0, tmpvar_34));
  vPerspective.x = tmpvar_34;
}

#version 150
// ps_split_composite
// features: []

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
in vec2 vUv;
flat in vec2 vPerspective;
flat in vec4 vUvSampleBounds;
void main ()
{
  float tmpvar_1;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_1 = 1.0;
  } else {
    vec2 tmpvar_2;
    tmpvar_2 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_3;
    tmpvar_3.xy = greaterThanEqual (tmpvar_2, vClipMaskUvBounds.xy);
    tmpvar_3.zw = lessThan (tmpvar_2, vClipMaskUvBounds.zw);
    bool tmpvar_4;
    tmpvar_4 = (tmpvar_3 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_4)) {
      tmpvar_1 = 0.0;
    } else {
      tmpvar_1 = texelFetch (sClipMask, ivec2(tmpvar_2), 0).x;
    };
  };
  oFragColor = (tmpvar_1 * texture (sColor0, min (max (
    (vUv * mix (gl_FragCoord.w, 1.0, vPerspective.x))
  , vUvSampleBounds.xy), vUvSampleBounds.zw)));
}

ps_text_run_ALPHA_PASS_DUAL_SOURCE_BLENDING_GLYPH_TRANSFORM_TEXTURE_2D#version 150
// ps_text_run
// features: ["ALPHA_PASS", "DUAL_SOURCE_BLENDING", "GLYPH_TRANSFORM", "TEXTURE_2D"]

#extension GL_ARB_explicit_attrib_location : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
flat out vec4 v_color;
flat out vec3 v_mask_swizzle;
flat out vec4 v_uv_bounds;
out vec2 v_uv;
out vec4 v_uv_clip;
void main ()
{
  vec2 local_pos_1;
  vec2 glyph_offset_2;
  int color_mode_3;
  vec2 clip_area_task_rect_p0_4;
  vec2 clip_area_task_rect_p1_5;
  float ph_z_6;
  int instance_picture_task_address_7;
  int instance_clip_address_8;
  int instance_segment_index_9;
  int instance_flags_10;
  int instance_resource_address_11;
  instance_picture_task_address_7 = (aData.y >> 16);
  instance_clip_address_8 = (aData.y & 65535);
  instance_segment_index_9 = (aData.z & 65535);
  instance_flags_10 = (aData.z >> 16);
  instance_resource_address_11 = (aData.w & 16777215);
  ivec2 tmpvar_12;
  tmpvar_12.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_12.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(0, 0));
  vec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(1, 0));
  vec2 tmpvar_15;
  vec2 tmpvar_16;
  tmpvar_15 = tmpvar_14.xy;
  tmpvar_16 = tmpvar_14.zw;
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_17.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_17, 0, ivec2(0, 0));
  ph_z_6 = float(tmpvar_18.x);
  mat4 transform_m_19;
  int tmpvar_20;
  tmpvar_20 = (tmpvar_18.z & 16777215);
  ivec2 tmpvar_21;
  tmpvar_21.x = int((8u * (
    uint(tmpvar_20)
   % 128u)));
  tmpvar_21.y = int((uint(tmpvar_20) / 128u));
  transform_m_19[0] = texelFetchOffset (sTransformPalette, tmpvar_21, 0, ivec2(0, 0));
  transform_m_19[1] = texelFetchOffset (sTransformPalette, tmpvar_21, 0, ivec2(1, 0));
  transform_m_19[2] = texelFetchOffset (sTransformPalette, tmpvar_21, 0, ivec2(2, 0));
  transform_m_19[3] = texelFetchOffset (sTransformPalette, tmpvar_21, 0, ivec2(3, 0));
  RectWithEndpoint area_task_rect_22;
  float area_device_pixel_scale_23;
  vec2 area_screen_origin_24;
  if ((instance_clip_address_8 >= 32767)) {
    area_task_rect_22 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_23 = 0.0;
    area_screen_origin_24 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_25;
    tmpvar_25.x = int((2u * (
      uint(instance_clip_address_8)
     % 512u)));
    tmpvar_25.y = int((uint(instance_clip_address_8) / 512u));
    vec4 tmpvar_26;
    tmpvar_26 = texelFetchOffset (sRenderTasks, tmpvar_25, 0, ivec2(0, 0));
    vec4 tmpvar_27;
    tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_25, 0, ivec2(1, 0));
    area_task_rect_22.p0 = tmpvar_26.xy;
    area_task_rect_22.p1 = tmpvar_26.zw;
    area_device_pixel_scale_23 = tmpvar_27.x;
    area_screen_origin_24 = tmpvar_27.yz;
  };
  clip_area_task_rect_p0_4 = area_task_rect_22.p0;
  clip_area_task_rect_p1_5 = area_task_rect_22.p1;
  ivec2 tmpvar_28;
  tmpvar_28.x = int((2u * (
    uint(instance_picture_task_address_7)
   % 512u)));
  tmpvar_28.y = int((uint(instance_picture_task_address_7) / 512u));
  vec4 tmpvar_29;
  tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_28, 0, ivec2(0, 0));
  vec4 tmpvar_30;
  tmpvar_30 = texelFetchOffset (sRenderTasks, tmpvar_28, 0, ivec2(1, 0));
  int tmpvar_31;
  tmpvar_31 = ((instance_flags_10 >> 8) & 255);
  int tmpvar_32;
  tmpvar_32 = (instance_flags_10 & 255);
  color_mode_3 = tmpvar_32;
  ivec2 tmpvar_33;
  tmpvar_33.x = int((uint(tmpvar_18.y) % 1024u));
  tmpvar_33.y = int((uint(tmpvar_18.y) / 1024u));
  vec4 tmpvar_34;
  vec4 tmpvar_35;
  tmpvar_34 = texelFetchOffset (sGpuCache, tmpvar_33, 0, ivec2(0, 0));
  tmpvar_35 = texelFetchOffset (sGpuCache, tmpvar_33, 0, ivec2(1, 0));
  if ((tmpvar_32 == 0)) {
    color_mode_3 = uMode;
  };
  int tmpvar_36;
  tmpvar_36 = ((tmpvar_18.y + 2) + int((
    uint(instance_segment_index_9)
   / 2u)));
  ivec2 tmpvar_37;
  tmpvar_37.x = int((uint(tmpvar_36) % 1024u));
  tmpvar_37.y = int((uint(tmpvar_36) / 1024u));
  vec4 tmpvar_38;
  tmpvar_38 = texelFetch (sGpuCache, tmpvar_37, 0);
  glyph_offset_2 = (mix(tmpvar_38.xy, tmpvar_38.zw, bvec2((
    (uint(instance_segment_index_9) % 2u)
   == 1u))) + tmpvar_13.xy);
  ivec2 tmpvar_39;
  tmpvar_39.x = int((uint(instance_resource_address_11) % 1024u));
  tmpvar_39.y = int((uint(instance_resource_address_11) / 1024u));
  vec4 tmpvar_40;
  vec4 tmpvar_41;
  tmpvar_40 = texelFetchOffset (sGpuCache, tmpvar_39, 0, ivec2(0, 0));
  tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_39, 0, ivec2(1, 0));
  vec2 tmpvar_42;
  bool tmpvar_43;
  tmpvar_43 = (0 == tmpvar_31);
  tmpvar_43 = (tmpvar_43 || !((
    ((1 == tmpvar_31) || (2 == tmpvar_31))
   || 
    (3 == tmpvar_31)
  )));
  if (tmpvar_43) {
    tmpvar_42 = vec2(0.5, 0.5);
  } else {
    tmpvar_43 = (tmpvar_43 || (1 == tmpvar_31));
    if (tmpvar_43) {
      tmpvar_42 = vec2(0.125, 0.5);
    } else {
      tmpvar_43 = (tmpvar_43 || (2 == tmpvar_31));
      if (tmpvar_43) {
        tmpvar_42 = vec2(0.5, 0.125);
      } else {
        tmpvar_43 = (tmpvar_43 || (3 == tmpvar_31));
        if (tmpvar_43) {
          tmpvar_42 = vec2(0.125, 0.125);
        };
      };
    };
  };
  mat2 tmpvar_44;
  tmpvar_44[uint(0)] = transform_m_19[uint(0)].xy;
  tmpvar_44[1u] = transform_m_19[1u].xy;
  mat2 tmpvar_45;
  tmpvar_45 = (tmpvar_44 * tmpvar_30.x);
  vec2 tmpvar_46;
  tmpvar_46 = (transform_m_19[3].xy * tmpvar_30.x);
  mat2 tmpvar_47;
  mat2 tmpvar_48;
  tmpvar_48[0].x = tmpvar_45[1].y;
  tmpvar_48[0].y = -(tmpvar_45[0].y);
  tmpvar_48[1].x = -(tmpvar_45[1].x);
  tmpvar_48[1].y = tmpvar_45[0].x;
  tmpvar_47 = (tmpvar_48 / ((tmpvar_45[0].x * tmpvar_45[1].y) - (tmpvar_45[1].x * tmpvar_45[0].y)));
  vec2 tmpvar_49;
  tmpvar_49 = ((tmpvar_41.xy + floor(
    ((tmpvar_45 * glyph_offset_2) + tmpvar_42)
  )) + (floor(
    (((tmpvar_45 * tmpvar_13.zw) + tmpvar_46) + 0.5)
  ) - tmpvar_46));
  vec2 tmpvar_50;
  tmpvar_50 = ((tmpvar_49 + tmpvar_40.zw) - tmpvar_40.xy);
  vec2 tmpvar_51;
  tmpvar_51 = (tmpvar_50 - tmpvar_49);
  vec2 tmpvar_52;
  tmpvar_52 = (tmpvar_47 * (tmpvar_49 + (tmpvar_51 * 0.5)));
  mat2 tmpvar_53;
  tmpvar_53[uint(0)] = abs(tmpvar_47[0]);
  tmpvar_53[1u] = abs(tmpvar_47[1]);
  vec2 tmpvar_54;
  tmpvar_54 = (tmpvar_53 * (tmpvar_51 * 0.5));
  vec2 tmpvar_55;
  vec2 tmpvar_56;
  tmpvar_55 = (tmpvar_52 - tmpvar_54);
  tmpvar_56 = (tmpvar_52 + tmpvar_54);
  local_pos_1 = mix (tmpvar_55, tmpvar_56, aPosition);
  vec4 tmpvar_57;
  tmpvar_57.xy = tmpvar_15;
  tmpvar_57.zw = tmpvar_56;
  vec4 tmpvar_58;
  tmpvar_58.xy = tmpvar_55;
  tmpvar_58.zw = tmpvar_16;
  if ((greaterThanEqual (tmpvar_58, tmpvar_57) == bvec4(1, 1, 1, 1))) {
    local_pos_1 = (tmpvar_47 * mix (tmpvar_49, tmpvar_50, aPosition));
  };
  vec2 tmpvar_59;
  tmpvar_59 = min (max (local_pos_1, tmpvar_14.xy), tmpvar_14.zw);
  vec4 tmpvar_60;
  tmpvar_60.zw = vec2(0.0, 1.0);
  tmpvar_60.xy = tmpvar_59;
  vec4 tmpvar_61;
  tmpvar_61 = (transform_m_19 * tmpvar_60);
  vec4 tmpvar_62;
  tmpvar_62.xy = ((tmpvar_61.xy * tmpvar_30.x) + ((
    -(tmpvar_30.yz)
   + tmpvar_29.xy) * tmpvar_61.w));
  tmpvar_62.z = (ph_z_6 * tmpvar_61.w);
  tmpvar_62.w = tmpvar_61.w;
  gl_Position = (uTransform * tmpvar_62);
  vec2 tmpvar_63;
  tmpvar_63 = (((tmpvar_45 * tmpvar_59) - tmpvar_49) / (tmpvar_50 - tmpvar_49));
  vec4 tmpvar_64;
  tmpvar_64.xy = tmpvar_63;
  tmpvar_64.zw = (1.0 - tmpvar_63);
  v_uv_clip = tmpvar_64;
  vec4 tmpvar_65;
  tmpvar_65.xy = clip_area_task_rect_p0_4;
  tmpvar_65.zw = clip_area_task_rect_p1_5;
  vClipMaskUvBounds = tmpvar_65;
  vClipMaskUv = ((tmpvar_61.xy * area_device_pixel_scale_23) + (tmpvar_61.w * (clip_area_task_rect_p0_4 - area_screen_origin_24)));
  bool tmpvar_66;
  bool tmpvar_67;
  tmpvar_67 = bool(0);
  tmpvar_66 = (1 == color_mode_3);
  if (tmpvar_66) {
    v_mask_swizzle = vec3(0.0, 1.0, 1.0);
    v_color = tmpvar_34;
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = (tmpvar_66 || (7 == color_mode_3));
  tmpvar_66 = (tmpvar_66 && !(tmpvar_67));
  if (tmpvar_66) {
    v_mask_swizzle = vec3(0.0, 1.0, 0.0);
    v_color = tmpvar_34;
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = (tmpvar_66 || (5 == color_mode_3));
  tmpvar_66 = (tmpvar_66 && !(tmpvar_67));
  if (tmpvar_66) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_34;
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = (tmpvar_66 || (2 == color_mode_3));
  tmpvar_66 = (tmpvar_66 || (3 == color_mode_3));
  tmpvar_66 = (tmpvar_66 || (8 == color_mode_3));
  tmpvar_66 = (tmpvar_66 && !(tmpvar_67));
  if (tmpvar_66) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_34.wwww;
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = (tmpvar_66 || (4 == color_mode_3));
  tmpvar_66 = (tmpvar_66 && !(tmpvar_67));
  if (tmpvar_66) {
    v_mask_swizzle = vec3(-1.0, 1.0, 0.0);
    v_color = (tmpvar_34.wwww * tmpvar_35);
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = (tmpvar_66 || (6 == color_mode_3));
  tmpvar_66 = (tmpvar_66 && !(tmpvar_67));
  if (tmpvar_66) {
    vec3 tmpvar_68;
    tmpvar_68.yz = vec2(0.0, 0.0);
    tmpvar_68.x = tmpvar_34.w;
    v_mask_swizzle = tmpvar_68;
    v_color = tmpvar_34;
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = !(tmpvar_67);
  if (tmpvar_66) {
    v_mask_swizzle = vec3(0.0, 0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  vec2 tmpvar_69;
  tmpvar_69 = vec2(textureSize (sColor0, 0));
  v_uv = mix ((tmpvar_40.xy / tmpvar_69), (tmpvar_40.zw / tmpvar_69), tmpvar_63);
  v_uv_bounds = ((tmpvar_40 + vec4(0.5, 0.5, -0.5, -0.5)) / tmpvar_69.xyxy);
}

#version 150
// ps_text_run
// features: ["ALPHA_PASS", "DUAL_SOURCE_BLENDING", "GLYPH_TRANSFORM", "TEXTURE_2D"]

#extension GL_ARB_explicit_attrib_location : enable
precision highp float;
layout(location=0, index=0) out vec4 oFragColor;
layout(location=0, index=1) out vec4 oFragBlend;
uniform sampler2D sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
flat in vec4 v_color;
flat in vec3 v_mask_swizzle;
flat in vec4 v_uv_bounds;
in vec2 v_uv;
in vec4 v_uv_clip;
void main ()
{
  vec4 frag_color_1;
  vec4 frag_blend_2;
  vec4 mask_3;
  vec4 tmpvar_4;
  tmpvar_4 = texture (sColor0, min (max (v_uv, v_uv_bounds.xy), v_uv_bounds.zw));
  mask_3 = (mix(tmpvar_4, tmpvar_4.xxxx, bvec4((v_mask_swizzle.z != 0.0))) * float((
    greaterThanEqual (v_uv_clip, vec4(0.0, 0.0, 0.0, 0.0))
   == bvec4(1, 1, 1, 1))));
  frag_color_1 = (v_color * mask_3);
  frag_blend_2 = ((mask_3 * v_mask_swizzle.x) + (mask_3.wwww * v_mask_swizzle.y));
  float tmpvar_5;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_5 = 1.0;
  } else {
    vec2 tmpvar_6;
    tmpvar_6 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_7;
    tmpvar_7.xy = greaterThanEqual (tmpvar_6, vClipMaskUvBounds.xy);
    tmpvar_7.zw = lessThan (tmpvar_6, vClipMaskUvBounds.zw);
    bool tmpvar_8;
    tmpvar_8 = (tmpvar_7 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_8)) {
      tmpvar_5 = 0.0;
    } else {
      tmpvar_5 = texelFetch (sClipMask, ivec2(tmpvar_6), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_5);
  oFragColor = frag_color_1;
  oFragBlend = (frag_blend_2 * tmpvar_5);
}

ps_text_run_ALPHA_PASS_DUAL_SOURCE_BLENDING_TEXTURE_2D#version 150
// ps_text_run
// features: ["ALPHA_PASS", "DUAL_SOURCE_BLENDING", "TEXTURE_2D"]

#extension GL_ARB_explicit_attrib_location : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
flat out vec4 v_color;
flat out vec3 v_mask_swizzle;
flat out vec4 v_uv_bounds;
out vec2 v_uv;
void main ()
{
  vec2 glyph_offset_1;
  int color_mode_2;
  vec2 clip_area_task_rect_p0_3;
  vec2 clip_area_task_rect_p1_4;
  float ph_z_5;
  ivec4 ph_user_data_6;
  int instance_picture_task_address_7;
  int instance_clip_address_8;
  int instance_segment_index_9;
  int instance_flags_10;
  int instance_resource_address_11;
  instance_picture_task_address_7 = (aData.y >> 16);
  instance_clip_address_8 = (aData.y & 65535);
  instance_segment_index_9 = (aData.z & 65535);
  instance_flags_10 = (aData.z >> 16);
  instance_resource_address_11 = (aData.w & 16777215);
  ivec2 tmpvar_12;
  tmpvar_12.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_12.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(0, 0));
  vec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(1, 0));
  ivec2 tmpvar_15;
  tmpvar_15.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_15.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_15, 0, ivec2(0, 0));
  ph_z_5 = float(tmpvar_16.x);
  ph_user_data_6 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_15, 0, ivec2(1, 0));
  mat4 transform_m_17;
  int tmpvar_18;
  tmpvar_18 = (tmpvar_16.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  RectWithEndpoint area_task_rect_20;
  float area_device_pixel_scale_21;
  vec2 area_screen_origin_22;
  if ((instance_clip_address_8 >= 32767)) {
    area_task_rect_20 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_21 = 0.0;
    area_screen_origin_22 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_23;
    tmpvar_23.x = int((2u * (
      uint(instance_clip_address_8)
     % 512u)));
    tmpvar_23.y = int((uint(instance_clip_address_8) / 512u));
    vec4 tmpvar_24;
    tmpvar_24 = texelFetchOffset (sRenderTasks, tmpvar_23, 0, ivec2(0, 0));
    vec4 tmpvar_25;
    tmpvar_25 = texelFetchOffset (sRenderTasks, tmpvar_23, 0, ivec2(1, 0));
    area_task_rect_20.p0 = tmpvar_24.xy;
    area_task_rect_20.p1 = tmpvar_24.zw;
    area_device_pixel_scale_21 = tmpvar_25.x;
    area_screen_origin_22 = tmpvar_25.yz;
  };
  clip_area_task_rect_p0_3 = area_task_rect_20.p0;
  clip_area_task_rect_p1_4 = area_task_rect_20.p1;
  ivec2 tmpvar_26;
  tmpvar_26.x = int((2u * (
    uint(instance_picture_task_address_7)
   % 512u)));
  tmpvar_26.y = int((uint(instance_picture_task_address_7) / 512u));
  vec4 tmpvar_27;
  tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
  vec4 tmpvar_28;
  tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
  int tmpvar_29;
  tmpvar_29 = ((instance_flags_10 >> 8) & 255);
  int tmpvar_30;
  tmpvar_30 = (instance_flags_10 & 255);
  color_mode_2 = tmpvar_30;
  ivec2 tmpvar_31;
  tmpvar_31.x = int((uint(tmpvar_16.y) % 1024u));
  tmpvar_31.y = int((uint(tmpvar_16.y) / 1024u));
  vec4 tmpvar_32;
  vec4 tmpvar_33;
  tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
  tmpvar_33 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  if ((tmpvar_30 == 0)) {
    color_mode_2 = uMode;
  };
  int tmpvar_34;
  tmpvar_34 = ((tmpvar_16.y + 2) + int((
    uint(instance_segment_index_9)
   / 2u)));
  ivec2 tmpvar_35;
  tmpvar_35.x = int((uint(tmpvar_34) % 1024u));
  tmpvar_35.y = int((uint(tmpvar_34) / 1024u));
  vec4 tmpvar_36;
  tmpvar_36 = texelFetch (sGpuCache, tmpvar_35, 0);
  glyph_offset_1 = (mix(tmpvar_36.xy, tmpvar_36.zw, bvec2((
    (uint(instance_segment_index_9) % 2u)
   == 1u))) + tmpvar_13.xy);
  ivec2 tmpvar_37;
  tmpvar_37.x = int((uint(instance_resource_address_11) % 1024u));
  tmpvar_37.y = int((uint(instance_resource_address_11) / 1024u));
  vec4 tmpvar_38;
  vec4 tmpvar_39;
  tmpvar_38 = texelFetchOffset (sGpuCache, tmpvar_37, 0, ivec2(0, 0));
  tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_37, 0, ivec2(1, 0));
  vec2 tmpvar_40;
  bool tmpvar_41;
  tmpvar_41 = (0 == tmpvar_29);
  tmpvar_41 = (tmpvar_41 || !((
    ((1 == tmpvar_29) || (2 == tmpvar_29))
   || 
    (3 == tmpvar_29)
  )));
  if (tmpvar_41) {
    tmpvar_40 = vec2(0.5, 0.5);
  } else {
    tmpvar_41 = (tmpvar_41 || (1 == tmpvar_29));
    if (tmpvar_41) {
      tmpvar_40 = vec2(0.125, 0.5);
    } else {
      tmpvar_41 = (tmpvar_41 || (2 == tmpvar_29));
      if (tmpvar_41) {
        tmpvar_40 = vec2(0.5, 0.125);
      } else {
        tmpvar_41 = (tmpvar_41 || (3 == tmpvar_29));
        if (tmpvar_41) {
          tmpvar_40 = vec2(0.125, 0.125);
        };
      };
    };
  };
  float tmpvar_42;
  tmpvar_42 = ((float(ph_user_data_6.x) / 65535.0) * tmpvar_28.x);
  float tmpvar_43;
  tmpvar_43 = (tmpvar_39.z / tmpvar_42);
  vec2 tmpvar_44;
  tmpvar_44 = ((tmpvar_43 * (tmpvar_39.xy + 
    (floor(((glyph_offset_1 * tmpvar_42) + tmpvar_40)) / tmpvar_39.z)
  )) + tmpvar_13.zw);
  vec2 tmpvar_45;
  tmpvar_45 = (tmpvar_44 + (tmpvar_43 * (tmpvar_38.zw - tmpvar_38.xy)));
  vec2 tmpvar_46;
  tmpvar_46 = min (max (mix (tmpvar_44, tmpvar_45, aPosition), tmpvar_14.xy), tmpvar_14.zw);
  vec4 tmpvar_47;
  tmpvar_47.zw = vec2(0.0, 1.0);
  tmpvar_47.xy = tmpvar_46;
  vec4 tmpvar_48;
  tmpvar_48 = (transform_m_17 * tmpvar_47);
  vec4 tmpvar_49;
  tmpvar_49.xy = ((tmpvar_48.xy * tmpvar_28.x) + ((
    -(tmpvar_28.yz)
   + tmpvar_27.xy) * tmpvar_48.w));
  tmpvar_49.z = (ph_z_5 * tmpvar_48.w);
  tmpvar_49.w = tmpvar_48.w;
  gl_Position = (uTransform * tmpvar_49);
  vec2 tmpvar_50;
  tmpvar_50 = ((tmpvar_46 - tmpvar_44) / (tmpvar_45 - tmpvar_44));
  vec4 tmpvar_51;
  tmpvar_51.xy = clip_area_task_rect_p0_3;
  tmpvar_51.zw = clip_area_task_rect_p1_4;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_48.xy * area_device_pixel_scale_21) + (tmpvar_48.w * (clip_area_task_rect_p0_3 - area_screen_origin_22)));
  bool tmpvar_52;
  bool tmpvar_53;
  tmpvar_53 = bool(0);
  tmpvar_52 = (1 == color_mode_2);
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 1.0, 1.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (7 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 1.0, 0.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (5 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (2 == color_mode_2));
  tmpvar_52 = (tmpvar_52 || (3 == color_mode_2));
  tmpvar_52 = (tmpvar_52 || (8 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_32.wwww;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (4 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(-1.0, 1.0, 0.0);
    v_color = (tmpvar_32.wwww * tmpvar_33);
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (6 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    vec3 tmpvar_54;
    tmpvar_54.yz = vec2(0.0, 0.0);
    tmpvar_54.x = tmpvar_32.w;
    v_mask_swizzle = tmpvar_54;
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = !(tmpvar_53);
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  vec2 tmpvar_55;
  tmpvar_55 = vec2(textureSize (sColor0, 0));
  v_uv = mix ((tmpvar_38.xy / tmpvar_55), (tmpvar_38.zw / tmpvar_55), tmpvar_50);
  v_uv_bounds = ((tmpvar_38 + vec4(0.5, 0.5, -0.5, -0.5)) / tmpvar_55.xyxy);
}

#version 150
// ps_text_run
// features: ["ALPHA_PASS", "DUAL_SOURCE_BLENDING", "TEXTURE_2D"]

#extension GL_ARB_explicit_attrib_location : enable
precision highp float;
layout(location=0, index=0) out vec4 oFragColor;
layout(location=0, index=1) out vec4 oFragBlend;
uniform sampler2D sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
flat in vec4 v_color;
flat in vec3 v_mask_swizzle;
flat in vec4 v_uv_bounds;
in vec2 v_uv;
void main ()
{
  vec4 frag_color_1;
  vec4 frag_blend_2;
  vec4 tmpvar_3;
  tmpvar_3 = texture (sColor0, min (max (v_uv, v_uv_bounds.xy), v_uv_bounds.zw));
  vec4 tmpvar_4;
  tmpvar_4 = mix(tmpvar_3, tmpvar_3.xxxx, bvec4((v_mask_swizzle.z != 0.0)));
  frag_color_1 = (v_color * tmpvar_4);
  frag_blend_2 = ((tmpvar_4 * v_mask_swizzle.x) + (tmpvar_4.wwww * v_mask_swizzle.y));
  float tmpvar_5;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_5 = 1.0;
  } else {
    vec2 tmpvar_6;
    tmpvar_6 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_7;
    tmpvar_7.xy = greaterThanEqual (tmpvar_6, vClipMaskUvBounds.xy);
    tmpvar_7.zw = lessThan (tmpvar_6, vClipMaskUvBounds.zw);
    bool tmpvar_8;
    tmpvar_8 = (tmpvar_7 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_8)) {
      tmpvar_5 = 0.0;
    } else {
      tmpvar_5 = texelFetch (sClipMask, ivec2(tmpvar_6), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_5);
  oFragColor = frag_color_1;
  oFragBlend = (frag_blend_2 * tmpvar_5);
}

ps_text_run_ALPHA_PASS_GLYPH_TRANSFORM_TEXTURE_2D#version 150
// ps_text_run
// features: ["ALPHA_PASS", "GLYPH_TRANSFORM", "TEXTURE_2D"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
flat out vec4 v_color;
flat out vec3 v_mask_swizzle;
flat out vec4 v_uv_bounds;
out vec2 v_uv;
out vec4 v_uv_clip;
void main ()
{
  vec2 local_pos_1;
  vec2 glyph_offset_2;
  int color_mode_3;
  vec2 clip_area_task_rect_p0_4;
  vec2 clip_area_task_rect_p1_5;
  float ph_z_6;
  int instance_picture_task_address_7;
  int instance_clip_address_8;
  int instance_segment_index_9;
  int instance_flags_10;
  int instance_resource_address_11;
  instance_picture_task_address_7 = (aData.y >> 16);
  instance_clip_address_8 = (aData.y & 65535);
  instance_segment_index_9 = (aData.z & 65535);
  instance_flags_10 = (aData.z >> 16);
  instance_resource_address_11 = (aData.w & 16777215);
  ivec2 tmpvar_12;
  tmpvar_12.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_12.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(0, 0));
  vec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(1, 0));
  vec2 tmpvar_15;
  vec2 tmpvar_16;
  tmpvar_15 = tmpvar_14.xy;
  tmpvar_16 = tmpvar_14.zw;
  ivec2 tmpvar_17;
  tmpvar_17.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_17.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_18;
  tmpvar_18 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_17, 0, ivec2(0, 0));
  ph_z_6 = float(tmpvar_18.x);
  mat4 transform_m_19;
  int tmpvar_20;
  tmpvar_20 = (tmpvar_18.z & 16777215);
  ivec2 tmpvar_21;
  tmpvar_21.x = int((8u * (
    uint(tmpvar_20)
   % 128u)));
  tmpvar_21.y = int((uint(tmpvar_20) / 128u));
  transform_m_19[0] = texelFetchOffset (sTransformPalette, tmpvar_21, 0, ivec2(0, 0));
  transform_m_19[1] = texelFetchOffset (sTransformPalette, tmpvar_21, 0, ivec2(1, 0));
  transform_m_19[2] = texelFetchOffset (sTransformPalette, tmpvar_21, 0, ivec2(2, 0));
  transform_m_19[3] = texelFetchOffset (sTransformPalette, tmpvar_21, 0, ivec2(3, 0));
  RectWithEndpoint area_task_rect_22;
  float area_device_pixel_scale_23;
  vec2 area_screen_origin_24;
  if ((instance_clip_address_8 >= 32767)) {
    area_task_rect_22 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_23 = 0.0;
    area_screen_origin_24 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_25;
    tmpvar_25.x = int((2u * (
      uint(instance_clip_address_8)
     % 512u)));
    tmpvar_25.y = int((uint(instance_clip_address_8) / 512u));
    vec4 tmpvar_26;
    tmpvar_26 = texelFetchOffset (sRenderTasks, tmpvar_25, 0, ivec2(0, 0));
    vec4 tmpvar_27;
    tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_25, 0, ivec2(1, 0));
    area_task_rect_22.p0 = tmpvar_26.xy;
    area_task_rect_22.p1 = tmpvar_26.zw;
    area_device_pixel_scale_23 = tmpvar_27.x;
    area_screen_origin_24 = tmpvar_27.yz;
  };
  clip_area_task_rect_p0_4 = area_task_rect_22.p0;
  clip_area_task_rect_p1_5 = area_task_rect_22.p1;
  ivec2 tmpvar_28;
  tmpvar_28.x = int((2u * (
    uint(instance_picture_task_address_7)
   % 512u)));
  tmpvar_28.y = int((uint(instance_picture_task_address_7) / 512u));
  vec4 tmpvar_29;
  tmpvar_29 = texelFetchOffset (sRenderTasks, tmpvar_28, 0, ivec2(0, 0));
  vec4 tmpvar_30;
  tmpvar_30 = texelFetchOffset (sRenderTasks, tmpvar_28, 0, ivec2(1, 0));
  int tmpvar_31;
  tmpvar_31 = ((instance_flags_10 >> 8) & 255);
  int tmpvar_32;
  tmpvar_32 = (instance_flags_10 & 255);
  color_mode_3 = tmpvar_32;
  ivec2 tmpvar_33;
  tmpvar_33.x = int((uint(tmpvar_18.y) % 1024u));
  tmpvar_33.y = int((uint(tmpvar_18.y) / 1024u));
  vec4 tmpvar_34;
  vec4 tmpvar_35;
  tmpvar_34 = texelFetchOffset (sGpuCache, tmpvar_33, 0, ivec2(0, 0));
  tmpvar_35 = texelFetchOffset (sGpuCache, tmpvar_33, 0, ivec2(1, 0));
  if ((tmpvar_32 == 0)) {
    color_mode_3 = uMode;
  };
  int tmpvar_36;
  tmpvar_36 = ((tmpvar_18.y + 2) + int((
    uint(instance_segment_index_9)
   / 2u)));
  ivec2 tmpvar_37;
  tmpvar_37.x = int((uint(tmpvar_36) % 1024u));
  tmpvar_37.y = int((uint(tmpvar_36) / 1024u));
  vec4 tmpvar_38;
  tmpvar_38 = texelFetch (sGpuCache, tmpvar_37, 0);
  glyph_offset_2 = (mix(tmpvar_38.xy, tmpvar_38.zw, bvec2((
    (uint(instance_segment_index_9) % 2u)
   == 1u))) + tmpvar_13.xy);
  ivec2 tmpvar_39;
  tmpvar_39.x = int((uint(instance_resource_address_11) % 1024u));
  tmpvar_39.y = int((uint(instance_resource_address_11) / 1024u));
  vec4 tmpvar_40;
  vec4 tmpvar_41;
  tmpvar_40 = texelFetchOffset (sGpuCache, tmpvar_39, 0, ivec2(0, 0));
  tmpvar_41 = texelFetchOffset (sGpuCache, tmpvar_39, 0, ivec2(1, 0));
  vec2 tmpvar_42;
  bool tmpvar_43;
  tmpvar_43 = (0 == tmpvar_31);
  tmpvar_43 = (tmpvar_43 || !((
    ((1 == tmpvar_31) || (2 == tmpvar_31))
   || 
    (3 == tmpvar_31)
  )));
  if (tmpvar_43) {
    tmpvar_42 = vec2(0.5, 0.5);
  } else {
    tmpvar_43 = (tmpvar_43 || (1 == tmpvar_31));
    if (tmpvar_43) {
      tmpvar_42 = vec2(0.125, 0.5);
    } else {
      tmpvar_43 = (tmpvar_43 || (2 == tmpvar_31));
      if (tmpvar_43) {
        tmpvar_42 = vec2(0.5, 0.125);
      } else {
        tmpvar_43 = (tmpvar_43 || (3 == tmpvar_31));
        if (tmpvar_43) {
          tmpvar_42 = vec2(0.125, 0.125);
        };
      };
    };
  };
  mat2 tmpvar_44;
  tmpvar_44[uint(0)] = transform_m_19[uint(0)].xy;
  tmpvar_44[1u] = transform_m_19[1u].xy;
  mat2 tmpvar_45;
  tmpvar_45 = (tmpvar_44 * tmpvar_30.x);
  vec2 tmpvar_46;
  tmpvar_46 = (transform_m_19[3].xy * tmpvar_30.x);
  mat2 tmpvar_47;
  mat2 tmpvar_48;
  tmpvar_48[0].x = tmpvar_45[1].y;
  tmpvar_48[0].y = -(tmpvar_45[0].y);
  tmpvar_48[1].x = -(tmpvar_45[1].x);
  tmpvar_48[1].y = tmpvar_45[0].x;
  tmpvar_47 = (tmpvar_48 / ((tmpvar_45[0].x * tmpvar_45[1].y) - (tmpvar_45[1].x * tmpvar_45[0].y)));
  vec2 tmpvar_49;
  tmpvar_49 = ((tmpvar_41.xy + floor(
    ((tmpvar_45 * glyph_offset_2) + tmpvar_42)
  )) + (floor(
    (((tmpvar_45 * tmpvar_13.zw) + tmpvar_46) + 0.5)
  ) - tmpvar_46));
  vec2 tmpvar_50;
  tmpvar_50 = ((tmpvar_49 + tmpvar_40.zw) - tmpvar_40.xy);
  vec2 tmpvar_51;
  tmpvar_51 = (tmpvar_50 - tmpvar_49);
  vec2 tmpvar_52;
  tmpvar_52 = (tmpvar_47 * (tmpvar_49 + (tmpvar_51 * 0.5)));
  mat2 tmpvar_53;
  tmpvar_53[uint(0)] = abs(tmpvar_47[0]);
  tmpvar_53[1u] = abs(tmpvar_47[1]);
  vec2 tmpvar_54;
  tmpvar_54 = (tmpvar_53 * (tmpvar_51 * 0.5));
  vec2 tmpvar_55;
  vec2 tmpvar_56;
  tmpvar_55 = (tmpvar_52 - tmpvar_54);
  tmpvar_56 = (tmpvar_52 + tmpvar_54);
  local_pos_1 = mix (tmpvar_55, tmpvar_56, aPosition);
  vec4 tmpvar_57;
  tmpvar_57.xy = tmpvar_15;
  tmpvar_57.zw = tmpvar_56;
  vec4 tmpvar_58;
  tmpvar_58.xy = tmpvar_55;
  tmpvar_58.zw = tmpvar_16;
  if ((greaterThanEqual (tmpvar_58, tmpvar_57) == bvec4(1, 1, 1, 1))) {
    local_pos_1 = (tmpvar_47 * mix (tmpvar_49, tmpvar_50, aPosition));
  };
  vec2 tmpvar_59;
  tmpvar_59 = min (max (local_pos_1, tmpvar_14.xy), tmpvar_14.zw);
  vec4 tmpvar_60;
  tmpvar_60.zw = vec2(0.0, 1.0);
  tmpvar_60.xy = tmpvar_59;
  vec4 tmpvar_61;
  tmpvar_61 = (transform_m_19 * tmpvar_60);
  vec4 tmpvar_62;
  tmpvar_62.xy = ((tmpvar_61.xy * tmpvar_30.x) + ((
    -(tmpvar_30.yz)
   + tmpvar_29.xy) * tmpvar_61.w));
  tmpvar_62.z = (ph_z_6 * tmpvar_61.w);
  tmpvar_62.w = tmpvar_61.w;
  gl_Position = (uTransform * tmpvar_62);
  vec2 tmpvar_63;
  tmpvar_63 = (((tmpvar_45 * tmpvar_59) - tmpvar_49) / (tmpvar_50 - tmpvar_49));
  vec4 tmpvar_64;
  tmpvar_64.xy = tmpvar_63;
  tmpvar_64.zw = (1.0 - tmpvar_63);
  v_uv_clip = tmpvar_64;
  vec4 tmpvar_65;
  tmpvar_65.xy = clip_area_task_rect_p0_4;
  tmpvar_65.zw = clip_area_task_rect_p1_5;
  vClipMaskUvBounds = tmpvar_65;
  vClipMaskUv = ((tmpvar_61.xy * area_device_pixel_scale_23) + (tmpvar_61.w * (clip_area_task_rect_p0_4 - area_screen_origin_24)));
  bool tmpvar_66;
  bool tmpvar_67;
  tmpvar_67 = bool(0);
  tmpvar_66 = (1 == color_mode_3);
  if (tmpvar_66) {
    v_mask_swizzle = vec3(0.0, 1.0, 1.0);
    v_color = tmpvar_34;
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = (tmpvar_66 || (7 == color_mode_3));
  tmpvar_66 = (tmpvar_66 && !(tmpvar_67));
  if (tmpvar_66) {
    v_mask_swizzle = vec3(0.0, 1.0, 0.0);
    v_color = tmpvar_34;
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = (tmpvar_66 || (5 == color_mode_3));
  tmpvar_66 = (tmpvar_66 && !(tmpvar_67));
  if (tmpvar_66) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_34;
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = (tmpvar_66 || (2 == color_mode_3));
  tmpvar_66 = (tmpvar_66 || (3 == color_mode_3));
  tmpvar_66 = (tmpvar_66 || (8 == color_mode_3));
  tmpvar_66 = (tmpvar_66 && !(tmpvar_67));
  if (tmpvar_66) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_34.wwww;
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = (tmpvar_66 || (4 == color_mode_3));
  tmpvar_66 = (tmpvar_66 && !(tmpvar_67));
  if (tmpvar_66) {
    v_mask_swizzle = vec3(-1.0, 1.0, 0.0);
    v_color = (tmpvar_34.wwww * tmpvar_35);
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = (tmpvar_66 || (6 == color_mode_3));
  tmpvar_66 = (tmpvar_66 && !(tmpvar_67));
  if (tmpvar_66) {
    vec3 tmpvar_68;
    tmpvar_68.yz = vec2(0.0, 0.0);
    tmpvar_68.x = tmpvar_34.w;
    v_mask_swizzle = tmpvar_68;
    v_color = tmpvar_34;
    tmpvar_67 = bool(1);
  };
  tmpvar_66 = !(tmpvar_67);
  if (tmpvar_66) {
    v_mask_swizzle = vec3(0.0, 0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  vec2 tmpvar_69;
  tmpvar_69 = vec2(textureSize (sColor0, 0));
  v_uv = mix ((tmpvar_40.xy / tmpvar_69), (tmpvar_40.zw / tmpvar_69), tmpvar_63);
  v_uv_bounds = ((tmpvar_40 + vec4(0.5, 0.5, -0.5, -0.5)) / tmpvar_69.xyxy);
}

#version 150
// ps_text_run
// features: ["ALPHA_PASS", "GLYPH_TRANSFORM", "TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
flat in vec4 v_color;
flat in vec3 v_mask_swizzle;
flat in vec4 v_uv_bounds;
in vec2 v_uv;
in vec4 v_uv_clip;
void main ()
{
  vec4 frag_color_1;
  vec4 mask_2;
  vec4 tmpvar_3;
  tmpvar_3 = texture (sColor0, min (max (v_uv, v_uv_bounds.xy), v_uv_bounds.zw));
  vec4 tmpvar_4;
  tmpvar_4 = mix(tmpvar_3, tmpvar_3.xxxx, bvec4((v_mask_swizzle.z != 0.0)));
  mask_2.w = tmpvar_4.w;
  mask_2.xyz = ((tmpvar_4.xyz * v_mask_swizzle.x) + (tmpvar_4.www * v_mask_swizzle.y));
  mask_2 = (mask_2 * float((
    greaterThanEqual (v_uv_clip, vec4(0.0, 0.0, 0.0, 0.0))
   == bvec4(1, 1, 1, 1))));
  frag_color_1 = (v_color * mask_2);
  float tmpvar_5;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_5 = 1.0;
  } else {
    vec2 tmpvar_6;
    tmpvar_6 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_7;
    tmpvar_7.xy = greaterThanEqual (tmpvar_6, vClipMaskUvBounds.xy);
    tmpvar_7.zw = lessThan (tmpvar_6, vClipMaskUvBounds.zw);
    bool tmpvar_8;
    tmpvar_8 = (tmpvar_7 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_8)) {
      tmpvar_5 = 0.0;
    } else {
      tmpvar_5 = texelFetch (sClipMask, ivec2(tmpvar_6), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_5);
  oFragColor = frag_color_1;
}

ps_text_run_ALPHA_PASS_TEXTURE_2D#version 150
// ps_text_run
// features: ["ALPHA_PASS", "TEXTURE_2D"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
flat out vec4 v_color;
flat out vec3 v_mask_swizzle;
flat out vec4 v_uv_bounds;
out vec2 v_uv;
void main ()
{
  vec2 glyph_offset_1;
  int color_mode_2;
  vec2 clip_area_task_rect_p0_3;
  vec2 clip_area_task_rect_p1_4;
  float ph_z_5;
  ivec4 ph_user_data_6;
  int instance_picture_task_address_7;
  int instance_clip_address_8;
  int instance_segment_index_9;
  int instance_flags_10;
  int instance_resource_address_11;
  instance_picture_task_address_7 = (aData.y >> 16);
  instance_clip_address_8 = (aData.y & 65535);
  instance_segment_index_9 = (aData.z & 65535);
  instance_flags_10 = (aData.z >> 16);
  instance_resource_address_11 = (aData.w & 16777215);
  ivec2 tmpvar_12;
  tmpvar_12.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_12.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(0, 0));
  vec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(1, 0));
  ivec2 tmpvar_15;
  tmpvar_15.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_15.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_15, 0, ivec2(0, 0));
  ph_z_5 = float(tmpvar_16.x);
  ph_user_data_6 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_15, 0, ivec2(1, 0));
  mat4 transform_m_17;
  int tmpvar_18;
  tmpvar_18 = (tmpvar_16.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  RectWithEndpoint area_task_rect_20;
  float area_device_pixel_scale_21;
  vec2 area_screen_origin_22;
  if ((instance_clip_address_8 >= 32767)) {
    area_task_rect_20 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_21 = 0.0;
    area_screen_origin_22 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_23;
    tmpvar_23.x = int((2u * (
      uint(instance_clip_address_8)
     % 512u)));
    tmpvar_23.y = int((uint(instance_clip_address_8) / 512u));
    vec4 tmpvar_24;
    tmpvar_24 = texelFetchOffset (sRenderTasks, tmpvar_23, 0, ivec2(0, 0));
    vec4 tmpvar_25;
    tmpvar_25 = texelFetchOffset (sRenderTasks, tmpvar_23, 0, ivec2(1, 0));
    area_task_rect_20.p0 = tmpvar_24.xy;
    area_task_rect_20.p1 = tmpvar_24.zw;
    area_device_pixel_scale_21 = tmpvar_25.x;
    area_screen_origin_22 = tmpvar_25.yz;
  };
  clip_area_task_rect_p0_3 = area_task_rect_20.p0;
  clip_area_task_rect_p1_4 = area_task_rect_20.p1;
  ivec2 tmpvar_26;
  tmpvar_26.x = int((2u * (
    uint(instance_picture_task_address_7)
   % 512u)));
  tmpvar_26.y = int((uint(instance_picture_task_address_7) / 512u));
  vec4 tmpvar_27;
  tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
  vec4 tmpvar_28;
  tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
  int tmpvar_29;
  tmpvar_29 = ((instance_flags_10 >> 8) & 255);
  int tmpvar_30;
  tmpvar_30 = (instance_flags_10 & 255);
  color_mode_2 = tmpvar_30;
  ivec2 tmpvar_31;
  tmpvar_31.x = int((uint(tmpvar_16.y) % 1024u));
  tmpvar_31.y = int((uint(tmpvar_16.y) / 1024u));
  vec4 tmpvar_32;
  vec4 tmpvar_33;
  tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
  tmpvar_33 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  if ((tmpvar_30 == 0)) {
    color_mode_2 = uMode;
  };
  int tmpvar_34;
  tmpvar_34 = ((tmpvar_16.y + 2) + int((
    uint(instance_segment_index_9)
   / 2u)));
  ivec2 tmpvar_35;
  tmpvar_35.x = int((uint(tmpvar_34) % 1024u));
  tmpvar_35.y = int((uint(tmpvar_34) / 1024u));
  vec4 tmpvar_36;
  tmpvar_36 = texelFetch (sGpuCache, tmpvar_35, 0);
  glyph_offset_1 = (mix(tmpvar_36.xy, tmpvar_36.zw, bvec2((
    (uint(instance_segment_index_9) % 2u)
   == 1u))) + tmpvar_13.xy);
  ivec2 tmpvar_37;
  tmpvar_37.x = int((uint(instance_resource_address_11) % 1024u));
  tmpvar_37.y = int((uint(instance_resource_address_11) / 1024u));
  vec4 tmpvar_38;
  vec4 tmpvar_39;
  tmpvar_38 = texelFetchOffset (sGpuCache, tmpvar_37, 0, ivec2(0, 0));
  tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_37, 0, ivec2(1, 0));
  vec2 tmpvar_40;
  bool tmpvar_41;
  tmpvar_41 = (0 == tmpvar_29);
  tmpvar_41 = (tmpvar_41 || !((
    ((1 == tmpvar_29) || (2 == tmpvar_29))
   || 
    (3 == tmpvar_29)
  )));
  if (tmpvar_41) {
    tmpvar_40 = vec2(0.5, 0.5);
  } else {
    tmpvar_41 = (tmpvar_41 || (1 == tmpvar_29));
    if (tmpvar_41) {
      tmpvar_40 = vec2(0.125, 0.5);
    } else {
      tmpvar_41 = (tmpvar_41 || (2 == tmpvar_29));
      if (tmpvar_41) {
        tmpvar_40 = vec2(0.5, 0.125);
      } else {
        tmpvar_41 = (tmpvar_41 || (3 == tmpvar_29));
        if (tmpvar_41) {
          tmpvar_40 = vec2(0.125, 0.125);
        };
      };
    };
  };
  float tmpvar_42;
  tmpvar_42 = ((float(ph_user_data_6.x) / 65535.0) * tmpvar_28.x);
  float tmpvar_43;
  tmpvar_43 = (tmpvar_39.z / tmpvar_42);
  vec2 tmpvar_44;
  tmpvar_44 = ((tmpvar_43 * (tmpvar_39.xy + 
    (floor(((glyph_offset_1 * tmpvar_42) + tmpvar_40)) / tmpvar_39.z)
  )) + tmpvar_13.zw);
  vec2 tmpvar_45;
  tmpvar_45 = (tmpvar_44 + (tmpvar_43 * (tmpvar_38.zw - tmpvar_38.xy)));
  vec2 tmpvar_46;
  tmpvar_46 = min (max (mix (tmpvar_44, tmpvar_45, aPosition), tmpvar_14.xy), tmpvar_14.zw);
  vec4 tmpvar_47;
  tmpvar_47.zw = vec2(0.0, 1.0);
  tmpvar_47.xy = tmpvar_46;
  vec4 tmpvar_48;
  tmpvar_48 = (transform_m_17 * tmpvar_47);
  vec4 tmpvar_49;
  tmpvar_49.xy = ((tmpvar_48.xy * tmpvar_28.x) + ((
    -(tmpvar_28.yz)
   + tmpvar_27.xy) * tmpvar_48.w));
  tmpvar_49.z = (ph_z_5 * tmpvar_48.w);
  tmpvar_49.w = tmpvar_48.w;
  gl_Position = (uTransform * tmpvar_49);
  vec2 tmpvar_50;
  tmpvar_50 = ((tmpvar_46 - tmpvar_44) / (tmpvar_45 - tmpvar_44));
  vec4 tmpvar_51;
  tmpvar_51.xy = clip_area_task_rect_p0_3;
  tmpvar_51.zw = clip_area_task_rect_p1_4;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_48.xy * area_device_pixel_scale_21) + (tmpvar_48.w * (clip_area_task_rect_p0_3 - area_screen_origin_22)));
  bool tmpvar_52;
  bool tmpvar_53;
  tmpvar_53 = bool(0);
  tmpvar_52 = (1 == color_mode_2);
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 1.0, 1.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (7 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 1.0, 0.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (5 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (2 == color_mode_2));
  tmpvar_52 = (tmpvar_52 || (3 == color_mode_2));
  tmpvar_52 = (tmpvar_52 || (8 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_32.wwww;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (4 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(-1.0, 1.0, 0.0);
    v_color = (tmpvar_32.wwww * tmpvar_33);
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (6 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    vec3 tmpvar_54;
    tmpvar_54.yz = vec2(0.0, 0.0);
    tmpvar_54.x = tmpvar_32.w;
    v_mask_swizzle = tmpvar_54;
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = !(tmpvar_53);
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  vec2 tmpvar_55;
  tmpvar_55 = vec2(textureSize (sColor0, 0));
  v_uv = mix ((tmpvar_38.xy / tmpvar_55), (tmpvar_38.zw / tmpvar_55), tmpvar_50);
  v_uv_bounds = ((tmpvar_38 + vec4(0.5, 0.5, -0.5, -0.5)) / tmpvar_55.xyxy);
}

#version 150
// ps_text_run
// features: ["ALPHA_PASS", "TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
flat in vec4 v_color;
flat in vec3 v_mask_swizzle;
flat in vec4 v_uv_bounds;
in vec2 v_uv;
void main ()
{
  vec4 frag_color_1;
  vec4 mask_2;
  vec4 tmpvar_3;
  tmpvar_3 = texture (sColor0, min (max (v_uv, v_uv_bounds.xy), v_uv_bounds.zw));
  vec4 tmpvar_4;
  tmpvar_4 = mix(tmpvar_3, tmpvar_3.xxxx, bvec4((v_mask_swizzle.z != 0.0)));
  mask_2.w = tmpvar_4.w;
  mask_2.xyz = ((tmpvar_4.xyz * v_mask_swizzle.x) + (tmpvar_4.www * v_mask_swizzle.y));
  frag_color_1 = (v_color * mask_2);
  float tmpvar_5;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_5 = 1.0;
  } else {
    vec2 tmpvar_6;
    tmpvar_6 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_7;
    tmpvar_7.xy = greaterThanEqual (tmpvar_6, vClipMaskUvBounds.xy);
    tmpvar_7.zw = lessThan (tmpvar_6, vClipMaskUvBounds.zw);
    bool tmpvar_8;
    tmpvar_8 = (tmpvar_7 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_8)) {
      tmpvar_5 = 0.0;
    } else {
      tmpvar_5 = texelFetch (sClipMask, ivec2(tmpvar_6), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_5);
  oFragColor = frag_color_1;
}

ps_text_run_DEBUG_OVERDRAW_DUAL_SOURCE_BLENDING_TEXTURE_2D#version 150
// ps_text_run
// features: ["DEBUG_OVERDRAW", "DUAL_SOURCE_BLENDING", "TEXTURE_2D"]

#extension GL_ARB_explicit_attrib_location : enable
struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
flat out vec4 v_color;
flat out vec3 v_mask_swizzle;
flat out vec4 v_uv_bounds;
out vec2 v_uv;
void main ()
{
  vec2 glyph_offset_1;
  int color_mode_2;
  vec2 clip_area_task_rect_p0_3;
  vec2 clip_area_task_rect_p1_4;
  float ph_z_5;
  ivec4 ph_user_data_6;
  int instance_picture_task_address_7;
  int instance_clip_address_8;
  int instance_segment_index_9;
  int instance_flags_10;
  int instance_resource_address_11;
  instance_picture_task_address_7 = (aData.y >> 16);
  instance_clip_address_8 = (aData.y & 65535);
  instance_segment_index_9 = (aData.z & 65535);
  instance_flags_10 = (aData.z >> 16);
  instance_resource_address_11 = (aData.w & 16777215);
  ivec2 tmpvar_12;
  tmpvar_12.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_12.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(0, 0));
  vec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(1, 0));
  ivec2 tmpvar_15;
  tmpvar_15.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_15.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_15, 0, ivec2(0, 0));
  ph_z_5 = float(tmpvar_16.x);
  ph_user_data_6 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_15, 0, ivec2(1, 0));
  mat4 transform_m_17;
  int tmpvar_18;
  tmpvar_18 = (tmpvar_16.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  RectWithEndpoint area_task_rect_20;
  float area_device_pixel_scale_21;
  vec2 area_screen_origin_22;
  if ((instance_clip_address_8 >= 32767)) {
    area_task_rect_20 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_21 = 0.0;
    area_screen_origin_22 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_23;
    tmpvar_23.x = int((2u * (
      uint(instance_clip_address_8)
     % 512u)));
    tmpvar_23.y = int((uint(instance_clip_address_8) / 512u));
    vec4 tmpvar_24;
    tmpvar_24 = texelFetchOffset (sRenderTasks, tmpvar_23, 0, ivec2(0, 0));
    vec4 tmpvar_25;
    tmpvar_25 = texelFetchOffset (sRenderTasks, tmpvar_23, 0, ivec2(1, 0));
    area_task_rect_20.p0 = tmpvar_24.xy;
    area_task_rect_20.p1 = tmpvar_24.zw;
    area_device_pixel_scale_21 = tmpvar_25.x;
    area_screen_origin_22 = tmpvar_25.yz;
  };
  clip_area_task_rect_p0_3 = area_task_rect_20.p0;
  clip_area_task_rect_p1_4 = area_task_rect_20.p1;
  ivec2 tmpvar_26;
  tmpvar_26.x = int((2u * (
    uint(instance_picture_task_address_7)
   % 512u)));
  tmpvar_26.y = int((uint(instance_picture_task_address_7) / 512u));
  vec4 tmpvar_27;
  tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
  vec4 tmpvar_28;
  tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
  int tmpvar_29;
  tmpvar_29 = ((instance_flags_10 >> 8) & 255);
  int tmpvar_30;
  tmpvar_30 = (instance_flags_10 & 255);
  color_mode_2 = tmpvar_30;
  ivec2 tmpvar_31;
  tmpvar_31.x = int((uint(tmpvar_16.y) % 1024u));
  tmpvar_31.y = int((uint(tmpvar_16.y) / 1024u));
  vec4 tmpvar_32;
  vec4 tmpvar_33;
  tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
  tmpvar_33 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  if ((tmpvar_30 == 0)) {
    color_mode_2 = uMode;
  };
  int tmpvar_34;
  tmpvar_34 = ((tmpvar_16.y + 2) + int((
    uint(instance_segment_index_9)
   / 2u)));
  ivec2 tmpvar_35;
  tmpvar_35.x = int((uint(tmpvar_34) % 1024u));
  tmpvar_35.y = int((uint(tmpvar_34) / 1024u));
  vec4 tmpvar_36;
  tmpvar_36 = texelFetch (sGpuCache, tmpvar_35, 0);
  glyph_offset_1 = (mix(tmpvar_36.xy, tmpvar_36.zw, bvec2((
    (uint(instance_segment_index_9) % 2u)
   == 1u))) + tmpvar_13.xy);
  ivec2 tmpvar_37;
  tmpvar_37.x = int((uint(instance_resource_address_11) % 1024u));
  tmpvar_37.y = int((uint(instance_resource_address_11) / 1024u));
  vec4 tmpvar_38;
  vec4 tmpvar_39;
  tmpvar_38 = texelFetchOffset (sGpuCache, tmpvar_37, 0, ivec2(0, 0));
  tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_37, 0, ivec2(1, 0));
  vec2 tmpvar_40;
  bool tmpvar_41;
  tmpvar_41 = (0 == tmpvar_29);
  tmpvar_41 = (tmpvar_41 || !((
    ((1 == tmpvar_29) || (2 == tmpvar_29))
   || 
    (3 == tmpvar_29)
  )));
  if (tmpvar_41) {
    tmpvar_40 = vec2(0.5, 0.5);
  } else {
    tmpvar_41 = (tmpvar_41 || (1 == tmpvar_29));
    if (tmpvar_41) {
      tmpvar_40 = vec2(0.125, 0.5);
    } else {
      tmpvar_41 = (tmpvar_41 || (2 == tmpvar_29));
      if (tmpvar_41) {
        tmpvar_40 = vec2(0.5, 0.125);
      } else {
        tmpvar_41 = (tmpvar_41 || (3 == tmpvar_29));
        if (tmpvar_41) {
          tmpvar_40 = vec2(0.125, 0.125);
        };
      };
    };
  };
  float tmpvar_42;
  tmpvar_42 = ((float(ph_user_data_6.x) / 65535.0) * tmpvar_28.x);
  float tmpvar_43;
  tmpvar_43 = (tmpvar_39.z / tmpvar_42);
  vec2 tmpvar_44;
  tmpvar_44 = ((tmpvar_43 * (tmpvar_39.xy + 
    (floor(((glyph_offset_1 * tmpvar_42) + tmpvar_40)) / tmpvar_39.z)
  )) + tmpvar_13.zw);
  vec2 tmpvar_45;
  tmpvar_45 = (tmpvar_44 + (tmpvar_43 * (tmpvar_38.zw - tmpvar_38.xy)));
  vec2 tmpvar_46;
  tmpvar_46 = min (max (mix (tmpvar_44, tmpvar_45, aPosition), tmpvar_14.xy), tmpvar_14.zw);
  vec4 tmpvar_47;
  tmpvar_47.zw = vec2(0.0, 1.0);
  tmpvar_47.xy = tmpvar_46;
  vec4 tmpvar_48;
  tmpvar_48 = (transform_m_17 * tmpvar_47);
  vec4 tmpvar_49;
  tmpvar_49.xy = ((tmpvar_48.xy * tmpvar_28.x) + ((
    -(tmpvar_28.yz)
   + tmpvar_27.xy) * tmpvar_48.w));
  tmpvar_49.z = (ph_z_5 * tmpvar_48.w);
  tmpvar_49.w = tmpvar_48.w;
  gl_Position = (uTransform * tmpvar_49);
  vec2 tmpvar_50;
  tmpvar_50 = ((tmpvar_46 - tmpvar_44) / (tmpvar_45 - tmpvar_44));
  vec4 tmpvar_51;
  tmpvar_51.xy = clip_area_task_rect_p0_3;
  tmpvar_51.zw = clip_area_task_rect_p1_4;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_48.xy * area_device_pixel_scale_21) + (tmpvar_48.w * (clip_area_task_rect_p0_3 - area_screen_origin_22)));
  bool tmpvar_52;
  bool tmpvar_53;
  tmpvar_53 = bool(0);
  tmpvar_52 = (1 == color_mode_2);
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 1.0, 1.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (7 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 1.0, 0.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (5 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (2 == color_mode_2));
  tmpvar_52 = (tmpvar_52 || (3 == color_mode_2));
  tmpvar_52 = (tmpvar_52 || (8 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_32.wwww;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (4 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(-1.0, 1.0, 0.0);
    v_color = (tmpvar_32.wwww * tmpvar_33);
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (6 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    vec3 tmpvar_54;
    tmpvar_54.yz = vec2(0.0, 0.0);
    tmpvar_54.x = tmpvar_32.w;
    v_mask_swizzle = tmpvar_54;
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = !(tmpvar_53);
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  vec2 tmpvar_55;
  tmpvar_55 = vec2(textureSize (sColor0, 0));
  v_uv = mix ((tmpvar_38.xy / tmpvar_55), (tmpvar_38.zw / tmpvar_55), tmpvar_50);
  v_uv_bounds = ((tmpvar_38 + vec4(0.5, 0.5, -0.5, -0.5)) / tmpvar_55.xyxy);
}

#version 150
// ps_text_run
// features: ["DEBUG_OVERDRAW", "DUAL_SOURCE_BLENDING", "TEXTURE_2D"]

#extension GL_ARB_explicit_attrib_location : enable
precision highp float;
layout(location=0, index=0) out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
flat in vec4 v_color;
flat in vec3 v_mask_swizzle;
flat in vec4 v_uv_bounds;
in vec2 v_uv;
void main ()
{
  vec4 frag_color_1;
  vec4 tmpvar_2;
  tmpvar_2 = texture (sColor0, min (max (v_uv, v_uv_bounds.xy), v_uv_bounds.zw));
  frag_color_1 = (v_color * mix(tmpvar_2, tmpvar_2.xxxx, bvec4((v_mask_swizzle.z != 0.0))));
  float tmpvar_3;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_3 = 1.0;
  } else {
    vec2 tmpvar_4;
    tmpvar_4 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_5;
    tmpvar_5.xy = greaterThanEqual (tmpvar_4, vClipMaskUvBounds.xy);
    tmpvar_5.zw = lessThan (tmpvar_4, vClipMaskUvBounds.zw);
    bool tmpvar_6;
    tmpvar_6 = (tmpvar_5 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_6)) {
      tmpvar_3 = 0.0;
    } else {
      tmpvar_3 = texelFetch (sClipMask, ivec2(tmpvar_4), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_3);
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

ps_text_run_DEBUG_OVERDRAW_TEXTURE_2D#version 150
// ps_text_run
// features: ["DEBUG_OVERDRAW", "TEXTURE_2D"]

struct RectWithEndpoint {
  vec2 p0;
  vec2 p1;
};
uniform int uMode;
uniform mat4 uTransform;
in vec2 aPosition;
uniform sampler2D sColor0;
uniform sampler2D sRenderTasks;
uniform sampler2D sGpuCache;
uniform sampler2D sTransformPalette;
flat out vec4 vClipMaskUvBounds;
out vec2 vClipMaskUv;
uniform sampler2D sPrimitiveHeadersF;
uniform isampler2D sPrimitiveHeadersI;
in ivec4 aData;
flat out vec4 v_color;
flat out vec3 v_mask_swizzle;
flat out vec4 v_uv_bounds;
out vec2 v_uv;
void main ()
{
  vec2 glyph_offset_1;
  int color_mode_2;
  vec2 clip_area_task_rect_p0_3;
  vec2 clip_area_task_rect_p1_4;
  float ph_z_5;
  ivec4 ph_user_data_6;
  int instance_picture_task_address_7;
  int instance_clip_address_8;
  int instance_segment_index_9;
  int instance_flags_10;
  int instance_resource_address_11;
  instance_picture_task_address_7 = (aData.y >> 16);
  instance_clip_address_8 = (aData.y & 65535);
  instance_segment_index_9 = (aData.z & 65535);
  instance_flags_10 = (aData.z >> 16);
  instance_resource_address_11 = (aData.w & 16777215);
  ivec2 tmpvar_12;
  tmpvar_12.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_12.y = int((uint(aData.x) / 512u));
  vec4 tmpvar_13;
  tmpvar_13 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(0, 0));
  vec4 tmpvar_14;
  tmpvar_14 = texelFetchOffset (sPrimitiveHeadersF, tmpvar_12, 0, ivec2(1, 0));
  ivec2 tmpvar_15;
  tmpvar_15.x = int((2u * (
    uint(aData.x)
   % 512u)));
  tmpvar_15.y = int((uint(aData.x) / 512u));
  ivec4 tmpvar_16;
  tmpvar_16 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_15, 0, ivec2(0, 0));
  ph_z_5 = float(tmpvar_16.x);
  ph_user_data_6 = texelFetchOffset (sPrimitiveHeadersI, tmpvar_15, 0, ivec2(1, 0));
  mat4 transform_m_17;
  int tmpvar_18;
  tmpvar_18 = (tmpvar_16.z & 16777215);
  ivec2 tmpvar_19;
  tmpvar_19.x = int((8u * (
    uint(tmpvar_18)
   % 128u)));
  tmpvar_19.y = int((uint(tmpvar_18) / 128u));
  transform_m_17[0] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(0, 0));
  transform_m_17[1] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(1, 0));
  transform_m_17[2] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(2, 0));
  transform_m_17[3] = texelFetchOffset (sTransformPalette, tmpvar_19, 0, ivec2(3, 0));
  RectWithEndpoint area_task_rect_20;
  float area_device_pixel_scale_21;
  vec2 area_screen_origin_22;
  if ((instance_clip_address_8 >= 32767)) {
    area_task_rect_20 = RectWithEndpoint(vec2(0.0, 0.0), vec2(0.0, 0.0));
    area_device_pixel_scale_21 = 0.0;
    area_screen_origin_22 = vec2(0.0, 0.0);
  } else {
    ivec2 tmpvar_23;
    tmpvar_23.x = int((2u * (
      uint(instance_clip_address_8)
     % 512u)));
    tmpvar_23.y = int((uint(instance_clip_address_8) / 512u));
    vec4 tmpvar_24;
    tmpvar_24 = texelFetchOffset (sRenderTasks, tmpvar_23, 0, ivec2(0, 0));
    vec4 tmpvar_25;
    tmpvar_25 = texelFetchOffset (sRenderTasks, tmpvar_23, 0, ivec2(1, 0));
    area_task_rect_20.p0 = tmpvar_24.xy;
    area_task_rect_20.p1 = tmpvar_24.zw;
    area_device_pixel_scale_21 = tmpvar_25.x;
    area_screen_origin_22 = tmpvar_25.yz;
  };
  clip_area_task_rect_p0_3 = area_task_rect_20.p0;
  clip_area_task_rect_p1_4 = area_task_rect_20.p1;
  ivec2 tmpvar_26;
  tmpvar_26.x = int((2u * (
    uint(instance_picture_task_address_7)
   % 512u)));
  tmpvar_26.y = int((uint(instance_picture_task_address_7) / 512u));
  vec4 tmpvar_27;
  tmpvar_27 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(0, 0));
  vec4 tmpvar_28;
  tmpvar_28 = texelFetchOffset (sRenderTasks, tmpvar_26, 0, ivec2(1, 0));
  int tmpvar_29;
  tmpvar_29 = ((instance_flags_10 >> 8) & 255);
  int tmpvar_30;
  tmpvar_30 = (instance_flags_10 & 255);
  color_mode_2 = tmpvar_30;
  ivec2 tmpvar_31;
  tmpvar_31.x = int((uint(tmpvar_16.y) % 1024u));
  tmpvar_31.y = int((uint(tmpvar_16.y) / 1024u));
  vec4 tmpvar_32;
  vec4 tmpvar_33;
  tmpvar_32 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(0, 0));
  tmpvar_33 = texelFetchOffset (sGpuCache, tmpvar_31, 0, ivec2(1, 0));
  if ((tmpvar_30 == 0)) {
    color_mode_2 = uMode;
  };
  int tmpvar_34;
  tmpvar_34 = ((tmpvar_16.y + 2) + int((
    uint(instance_segment_index_9)
   / 2u)));
  ivec2 tmpvar_35;
  tmpvar_35.x = int((uint(tmpvar_34) % 1024u));
  tmpvar_35.y = int((uint(tmpvar_34) / 1024u));
  vec4 tmpvar_36;
  tmpvar_36 = texelFetch (sGpuCache, tmpvar_35, 0);
  glyph_offset_1 = (mix(tmpvar_36.xy, tmpvar_36.zw, bvec2((
    (uint(instance_segment_index_9) % 2u)
   == 1u))) + tmpvar_13.xy);
  ivec2 tmpvar_37;
  tmpvar_37.x = int((uint(instance_resource_address_11) % 1024u));
  tmpvar_37.y = int((uint(instance_resource_address_11) / 1024u));
  vec4 tmpvar_38;
  vec4 tmpvar_39;
  tmpvar_38 = texelFetchOffset (sGpuCache, tmpvar_37, 0, ivec2(0, 0));
  tmpvar_39 = texelFetchOffset (sGpuCache, tmpvar_37, 0, ivec2(1, 0));
  vec2 tmpvar_40;
  bool tmpvar_41;
  tmpvar_41 = (0 == tmpvar_29);
  tmpvar_41 = (tmpvar_41 || !((
    ((1 == tmpvar_29) || (2 == tmpvar_29))
   || 
    (3 == tmpvar_29)
  )));
  if (tmpvar_41) {
    tmpvar_40 = vec2(0.5, 0.5);
  } else {
    tmpvar_41 = (tmpvar_41 || (1 == tmpvar_29));
    if (tmpvar_41) {
      tmpvar_40 = vec2(0.125, 0.5);
    } else {
      tmpvar_41 = (tmpvar_41 || (2 == tmpvar_29));
      if (tmpvar_41) {
        tmpvar_40 = vec2(0.5, 0.125);
      } else {
        tmpvar_41 = (tmpvar_41 || (3 == tmpvar_29));
        if (tmpvar_41) {
          tmpvar_40 = vec2(0.125, 0.125);
        };
      };
    };
  };
  float tmpvar_42;
  tmpvar_42 = ((float(ph_user_data_6.x) / 65535.0) * tmpvar_28.x);
  float tmpvar_43;
  tmpvar_43 = (tmpvar_39.z / tmpvar_42);
  vec2 tmpvar_44;
  tmpvar_44 = ((tmpvar_43 * (tmpvar_39.xy + 
    (floor(((glyph_offset_1 * tmpvar_42) + tmpvar_40)) / tmpvar_39.z)
  )) + tmpvar_13.zw);
  vec2 tmpvar_45;
  tmpvar_45 = (tmpvar_44 + (tmpvar_43 * (tmpvar_38.zw - tmpvar_38.xy)));
  vec2 tmpvar_46;
  tmpvar_46 = min (max (mix (tmpvar_44, tmpvar_45, aPosition), tmpvar_14.xy), tmpvar_14.zw);
  vec4 tmpvar_47;
  tmpvar_47.zw = vec2(0.0, 1.0);
  tmpvar_47.xy = tmpvar_46;
  vec4 tmpvar_48;
  tmpvar_48 = (transform_m_17 * tmpvar_47);
  vec4 tmpvar_49;
  tmpvar_49.xy = ((tmpvar_48.xy * tmpvar_28.x) + ((
    -(tmpvar_28.yz)
   + tmpvar_27.xy) * tmpvar_48.w));
  tmpvar_49.z = (ph_z_5 * tmpvar_48.w);
  tmpvar_49.w = tmpvar_48.w;
  gl_Position = (uTransform * tmpvar_49);
  vec2 tmpvar_50;
  tmpvar_50 = ((tmpvar_46 - tmpvar_44) / (tmpvar_45 - tmpvar_44));
  vec4 tmpvar_51;
  tmpvar_51.xy = clip_area_task_rect_p0_3;
  tmpvar_51.zw = clip_area_task_rect_p1_4;
  vClipMaskUvBounds = tmpvar_51;
  vClipMaskUv = ((tmpvar_48.xy * area_device_pixel_scale_21) + (tmpvar_48.w * (clip_area_task_rect_p0_3 - area_screen_origin_22)));
  bool tmpvar_52;
  bool tmpvar_53;
  tmpvar_53 = bool(0);
  tmpvar_52 = (1 == color_mode_2);
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 1.0, 1.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (7 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 1.0, 0.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (5 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (2 == color_mode_2));
  tmpvar_52 = (tmpvar_52 || (3 == color_mode_2));
  tmpvar_52 = (tmpvar_52 || (8 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(1.0, 0.0, 0.0);
    v_color = tmpvar_32.wwww;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (4 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    v_mask_swizzle = vec3(-1.0, 1.0, 0.0);
    v_color = (tmpvar_32.wwww * tmpvar_33);
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = (tmpvar_52 || (6 == color_mode_2));
  tmpvar_52 = (tmpvar_52 && !(tmpvar_53));
  if (tmpvar_52) {
    vec3 tmpvar_54;
    tmpvar_54.yz = vec2(0.0, 0.0);
    tmpvar_54.x = tmpvar_32.w;
    v_mask_swizzle = tmpvar_54;
    v_color = tmpvar_32;
    tmpvar_53 = bool(1);
  };
  tmpvar_52 = !(tmpvar_53);
  if (tmpvar_52) {
    v_mask_swizzle = vec3(0.0, 0.0, 0.0);
    v_color = vec4(1.0, 1.0, 1.0, 1.0);
  };
  vec2 tmpvar_55;
  tmpvar_55 = vec2(textureSize (sColor0, 0));
  v_uv = mix ((tmpvar_38.xy / tmpvar_55), (tmpvar_38.zw / tmpvar_55), tmpvar_50);
  v_uv_bounds = ((tmpvar_38 + vec4(0.5, 0.5, -0.5, -0.5)) / tmpvar_55.xyxy);
}

#version 150
// ps_text_run
// features: ["DEBUG_OVERDRAW", "TEXTURE_2D"]

precision highp float;
out vec4 oFragColor;
uniform sampler2D sColor0;
uniform sampler2D sClipMask;
flat in vec4 vClipMaskUvBounds;
in vec2 vClipMaskUv;
flat in vec4 v_color;
flat in vec3 v_mask_swizzle;
flat in vec4 v_uv_bounds;
in vec2 v_uv;
void main ()
{
  vec4 frag_color_1;
  vec4 mask_2;
  vec4 tmpvar_3;
  tmpvar_3 = texture (sColor0, min (max (v_uv, v_uv_bounds.xy), v_uv_bounds.zw));
  vec4 tmpvar_4;
  tmpvar_4 = mix(tmpvar_3, tmpvar_3.xxxx, bvec4((v_mask_swizzle.z != 0.0)));
  mask_2.w = tmpvar_4.w;
  mask_2.xyz = ((tmpvar_4.xyz * v_mask_swizzle.x) + (tmpvar_4.www * v_mask_swizzle.y));
  frag_color_1 = (v_color * mask_2);
  float tmpvar_5;
  if ((vClipMaskUvBounds.xy == vClipMaskUvBounds.zw)) {
    tmpvar_5 = 1.0;
  } else {
    vec2 tmpvar_6;
    tmpvar_6 = (vClipMaskUv * gl_FragCoord.w);
    bvec4 tmpvar_7;
    tmpvar_7.xy = greaterThanEqual (tmpvar_6, vClipMaskUvBounds.xy);
    tmpvar_7.zw = lessThan (tmpvar_6, vClipMaskUvBounds.zw);
    bool tmpvar_8;
    tmpvar_8 = (tmpvar_7 == bvec4(1, 1, 1, 1));
    if (!(tmpvar_8)) {
      tmpvar_5 = 0.0;
    } else {
      tmpvar_5 = texelFetch (sClipMask, ivec2(tmpvar_6), 0).x;
    };
  };
  frag_color_1 = (frag_color_1 * tmpvar_5);
  oFragColor = vec4(0.11, 0.077, 0.027, 0.125);
}

FT_Get_MM_VarFT_Done_MM_VarFT_Set_Var_Design_CoordinatesFT_Get_Var_Design_Coordinates