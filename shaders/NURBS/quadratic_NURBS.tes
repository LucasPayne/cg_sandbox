#version 420
layout (quads, equal_spacing, ccw) in;


in TCS_OUT {
    vec3 position;
} tes_in[];

uniform mat4x4 mvp_matrix;
uniform int num_vertical_knots;
uniform samplerBuffer knots;


void main(void)
{
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    float vertical_knot_window[4];
    vertical_knot_window[0] = texelFetch(knots, gl_PrimitiveID + 0).r;
    vertical_knot_window[1] = texelFetch(knots, gl_PrimitiveID + 1).r;
    vertical_knot_window[2] = texelFetch(knots, gl_PrimitiveID + 2).r;
    vertical_knot_window[3] = texelFetch(knots, gl_PrimitiveID + 3).r;
    float va[3];
    va[0] = vertical_knot_window[1] - vertical_knot_window[0];
    va[1] = vertical_knot_window[2] - vertical_knot_window[1];
    va[2] = vertical_knot_window[3] - vertical_knot_window[2];
    float valpha = va[0] / va[1];
    float vbeta = va[2] / va[1];

    float horizontal_knot_window[4];
    horizontal_knot_window[0] = texelFetch(knots, gl_PrimitiveID + num_vertical_knots + 0).r;
    horizontal_knot_window[1] = texelFetch(knots, gl_PrimitiveID + num_vertical_knots + 1).r;
    horizontal_knot_window[2] = texelFetch(knots, gl_PrimitiveID + num_vertical_knots + 2).r;
    horizontal_knot_window[3] = texelFetch(knots, gl_PrimitiveID + num_vertical_knots + 3).r;
    float ha[3];
    ha[0] = horizontal_knot_window[1] - horizontal_knot_window[0];
    ha[1] = horizontal_knot_window[2] - horizontal_knot_window[1];
    ha[2] = horizontal_knot_window[3] - horizontal_knot_window[2];
    float halpha = ha[0] / ha[1];
    float hbeta = ha[2] / ha[1];

    vec3 combined_rows[3];
    {
        float tmp1 = 1.0 / (1 + halpha);
        float tmp2 = 1.0 / (1 + hbeta);
        float c1 = (1 - u)*(1 - (u + halpha)*tmp1);
        float c2 = (1 - u)*(u + halpha)*tmp1 + u*(u - u*tmp2);
        float c3 = u * u * tmp2;
        for (int i = 0; i < 3; i++) {
            vec3 p1 = tes_in[3*i + 0].position;
            vec3 p2 = tes_in[3*i + 1].position;
            vec3 p3 = tes_in[3*i + 2].position;
            combined_rows[i] = c1*p1 + c2*p2 + c3*p3;
        }
    }
    float tmp1 = 1.0 / (1 + valpha);
    float tmp2 = 1.0 / (1 + vbeta);
    float c1 = (1 - v)*(1 - (v + valpha)*tmp1);
    float c2 = (1 - v)*(v + valpha)*tmp1 + v*(v - v*tmp2);
    float c3 = v * v * tmp2;
    gl_Position = mvp_matrix * vec4(combined_rows[0]*c1 + combined_rows[1]*c2 + combined_rows[2]*c3, 1);
}
