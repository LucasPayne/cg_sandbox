#type shading_model

block properties {
    mat4x4 vp_matrix;
    mat4x4 prev_vp_matrix;
}
section geom_post {
    out vec4 gl_Position(in vec3 f_world_position) {
    GLSL
        return vp_matrix * vec4(f_world_position, 1);
    END
    }
}
section frag_post {
    out vec2 gbuffer_normal(in vec3 f_world_normal) {
    GLSL
        //NOTE: It is assumed that the input normals are unit length.


        // Octahedron-mapped normal vectors. Reference: https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/
        /*---------
        |   /|\   |
        |  / | \  |
        | /  |  \ |
        |/___|___\|
        |\   |   /|
        | \  |  / |
        |  \ | /  |
        |   \|/   |
        ---------*/
        vec3 n = f_world_normal;
        n /= abs(n.x) + abs(n.y) + abs(n.z);
        // The 4 facets of the octahedron with positive z are mapped to the center diamond.
        // The corresponding facet with negative z is folded over to the other triangle in the same quadrant.
        n.xy = n.z >= 0
                ? n.xy 
                : (vec2(
                    n.x >= 0 ? 1 - abs(n.y) : abs(n.y) - 1,
                    n.y >= 0 ? 1 - abs(n.x) : abs(n.x) - 1
                ));
        n.xy = 0.5*n.xy + 0.5;
        return n.xy;
    END
    }
    out vec4 gbuffer_albedo(in vec4 f_albedo) {
    GLSL
        return f_albedo;
    END
    }
    out vec4 gbuffer_velocity(in vec3 f_world_position, in vec3 f_prev_world_position) {
    GLSL
        vec4 p_h = vp_matrix * vec4(f_world_position, 1);
        vec4 pp_h = prev_vp_matrix * vec4(f_prev_world_position, 1);
        vec2 p = p_h.xy / p_h.w;
        vec2 pp = pp_h.xy / pp_h.w;
        return vec4(p - pp, 0,1);
    END
    }
}
